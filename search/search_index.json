{
    "docs": [
        {
            "location": "/",
            "text": "zend-cache\n\n\n\n\n\n\nZend\\Cache\n provides a general cache system for PHP. The \nZend\\Cache\n component\nis able to cache different patterns (class, object, output, etc) using different\nstorage adapters (DB, File, Memcache, etc).\n\n\n\n\nFile issues at https://github.com/zendframework/zend-cache/issues\n\n\nDocumentation is at https://docs.zendframework.com/zend-cache/\n\n\n\n\nBenchmarks\n\n\nWe provide scripts for benchmarking zend-cache using the\n\nPHPBench\n framework; these can be\nfound in the \nbenchmark/\n directory.\n\n\nTo execute the benchmarks you can run the following command:\n\n\n$ vendor/bin/phpbench run --report=aggregate",
            "title": "zend-cache"
        },
        {
            "location": "/#zend-cache",
            "text": "Zend\\Cache  provides a general cache system for PHP. The  Zend\\Cache  component\nis able to cache different patterns (class, object, output, etc) using different\nstorage adapters (DB, File, Memcache, etc).   File issues at https://github.com/zendframework/zend-cache/issues  Documentation is at https://docs.zendframework.com/zend-cache/",
            "title": "zend-cache"
        },
        {
            "location": "/#benchmarks",
            "text": "We provide scripts for benchmarking zend-cache using the PHPBench  framework; these can be\nfound in the  benchmark/  directory.  To execute the benchmarks you can run the following command:  $ vendor/bin/phpbench run --report=aggregate",
            "title": "Benchmarks"
        },
        {
            "location": "/storage/adapter/",
            "text": "Adapters\n\n\nStorage adapters are wrappers for real storage resources such as memory or the filesystem, using\nthe well known \nadapter\n pattern.\n\n\nThey come with tons of methods to read, write, and modify stored items, and to get information about\nstored items and the storage.\n\n\nAll adapters implement \nZend\\Cache\\Storage\\StorageInterface\n, and most extend\n\nZend\\Cache\\Storage\\Adapter\\AbstractAdapter\n, which provides a foundation of\ncommon logic.\n\n\nConfiguration is handled by either \nZend\\Cache\\Storage\\Adapter\\AdapterOptions\n,\nor an adapter-specific options class if it exists. You may pass the options\ninstance to the class at instantiation, via the \nsetOptions()\n method, or,\nalternately, pass an associative array of options in either place (internally,\nthese are then passed to an options class instance). Alternately, you can pass\neither the options instance or associative array to the\n\nZend\\Cache\\StorageFactory::factory\n method.\n\n\n\n\nMany methods throw exceptions\n\n\nBecause many caching operations throw an exception on error, you need to catch\nthem. You can do so manually, or you can use the plugin\n\nZend\\Cache\\Storage\\Plugin\\ExceptionHandler\n with \nthrow_exceptions\n set to\n\nfalse\n to automatically catch them. You can also define an\n\nexception_callback\n to log exceptions.\n\n\n\n\nQuick Start\n\n\nCaching adapters can either be created from the provided\n\nZend\\Cache\\StorageFactory\n, or by instantiating one of the\n\nZend\\Cache\\Storage\\Adapter\\*\n classes.  To make life easier, the\n\nZend\\Cache\\StorageFactory\n comes with a \nfactory()\n method to create an adapter\nand all requested plugins at once.\n\n\nuse Zend\\Cache\\StorageFactory;\n\n// Via factory:\n$cache = StorageFactory::factory([\n    'adapter' => [\n        'name'    => 'apc',\n        'options' => ['ttl' => 3600],\n    ],\n    'plugins' => [\n        'exception_handler' => ['throw_exceptions' => false],\n    ],\n]);\n\n// Alternately, create the adapter and plugin separately:\n$cache  = StorageFactory::adapterFactory('apc', ['ttl' => 3600]);\n$plugin = StorageFactory::pluginFactory('exception_handler', [\n    'throw_exceptions' => false,\n]);\n$cache->addPlugin($plugin);\n\n// Or do it completely manually:\n$cache  = new Zend\\Cache\\Storage\\Adapter\\Apc();\n$cache->getOptions()->setTtl(3600);\n\n$plugin = new Zend\\Cache\\Storage\\Plugin\\ExceptionHandler();\n$plugin->getOptions()->setThrowExceptions(false);\n$cache->addPlugin($plugin);\n\n\n\nBasic Configuration Options\n\n\nThe following configuration options are defined by \nZend\\Cache\\Storage\\Adapter\\AdapterOptions\n and\nare available for every supported adapter. Adapter-specific configuration options are described on\nadapter level below.\n\n\n\n\n\n\n\n\nOption\n\n\nData Type\n\n\nDefault Value\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nttl\n\n\ninteger\n\n\n0\n\n\nTime to live\n\n\n\n\n\n\nnamespace\n\n\nstring\n\n\n\u201czfcache\u201d\n\n\nThe \u201cnamespace\u201d in which cache items will live\n\n\n\n\n\n\nkey_pattern\n\n\nnull|string\n\n\nnull\n\n\nPattern against which to validate cache keys\n\n\n\n\n\n\nreadable\n\n\nboolean\n\n\ntrue\n\n\nEnable/Disable reading data from cache\n\n\n\n\n\n\nwritable\n\n\nboolean\n\n\ntrue\n\n\nEnable/Disable writing data to cache\n\n\n\n\n\n\n\n\nThe StorageInterface\n\n\nZend\\Cache\\Storage\\StorageInterface\n is the basic interface implemented by all\nstorage adapters.\n\n\nnamespace Zend\\Cache\\Storage;\n\nuse Traversable;\n\ninterface StorageInterface\n{\n    /**\n     * Set options.\n     *\n     * @param array|Traversable|Adapter\\AdapterOptions $options\n     * @return StorageInterface Fluent interface\n     */\n    public function setOptions($options);\n\n    /**\n     * Get options\n     *\n     * @return Adapter\\AdapterOptions\n     */\n    public function getOptions();\n\n    /* reading */\n\n    /**\n     * Get an item.\n     *\n     * @param  string  $key\n     * @param  bool $success\n     * @param  mixed   $casToken\n     * @return mixed Data on success, null on failure\n     * @throws \\Zend\\Cache\\Exception\\ExceptionInterface\n     */\n    public function getItem($key, & $success = null, & $casToken = null);\n\n    /**\n     * Get multiple items.\n     *\n     * @param  array $keys\n     * @return array Associative array of keys and values\n     * @throws \\Zend\\Cache\\Exception\\ExceptionInterface\n     */\n    public function getItems(array $keys);\n\n    /**\n     * Test if an item exists.\n     *\n     * @param  string $key\n     * @return bool\n     * @throws \\Zend\\Cache\\Exception\\ExceptionInterface\n     */\n    public function hasItem($key);\n\n    /**\n     * Test multiple items.\n     *\n     * @param  array $keys\n     * @return array Array of found keys\n     * @throws \\Zend\\Cache\\Exception\\ExceptionInterface\n     */\n    public function hasItems(array $keys);\n\n    /**\n     * Get metadata of an item.\n     *\n     * @param  string $key\n     * @return array|bool Metadata on success, false on failure\n     * @throws \\Zend\\Cache\\Exception\\ExceptionInterface\n     */\n    public function getMetadata($key);\n\n    /**\n     * Get multiple metadata\n     *\n     * @param  array $keys\n     * @return array Associative array of keys and metadata\n     * @throws \\Zend\\Cache\\Exception\\ExceptionInterface\n     */\n    public function getMetadatas(array $keys);\n\n    /* writing */\n\n    /**\n     * Store an item.\n     *\n     * @param  string $key\n     * @param  mixed  $value\n     * @return bool\n     * @throws \\Zend\\Cache\\Exception\\ExceptionInterface\n     */\n    public function setItem($key, $value);\n\n    /**\n     * Store multiple items.\n     *\n     * @param  array $keyValuePairs\n     * @return array Array of not stored keys\n     * @throws \\Zend\\Cache\\Exception\\ExceptionInterface\n     */\n    public function setItems(array $keyValuePairs);\n\n    /**\n     * Add an item.\n     *\n     * @param  string $key\n     * @param  mixed  $value\n     * @return bool\n     * @throws \\Zend\\Cache\\Exception\\ExceptionInterface\n     */\n    public function addItem($key, $value);\n\n    /**\n     * Add multiple items.\n     *\n     * @param  array $keyValuePairs\n     * @return array Array of not stored keys\n     * @throws \\Zend\\Cache\\Exception\\ExceptionInterface\n     */\n    public function addItems(array $keyValuePairs);\n\n    /**\n     * Replace an existing item.\n     *\n     * @param  string $key\n     * @param  mixed  $value\n     * @return bool\n     * @throws \\Zend\\Cache\\Exception\\ExceptionInterface\n     */\n    public function replaceItem($key, $value);\n\n    /**\n     * Replace multiple existing items.\n     *\n     * @param  array $keyValuePairs\n     * @return array Array of not stored keys\n     * @throws \\Zend\\Cache\\Exception\\ExceptionInterface\n     */\n    public function replaceItems(array $keyValuePairs);\n\n    /**\n     * Set an item only if token matches\n     *\n     * It uses the token received from getItem() to check if the item has\n     * changed before overwriting it.\n     *\n     * @param  mixed  $token\n     * @param  string $key\n     * @param  mixed  $value\n     * @return bool\n     * @throws \\Zend\\Cache\\Exception\\ExceptionInterface\n     * @see    getItem()\n     * @see    setItem()\n     */\n    public function checkAndSetItem($token, $key, $value);\n\n    /**\n     * Reset lifetime of an item\n     *\n     * @param  string $key\n     * @return bool\n     * @throws \\Zend\\Cache\\Exception\\ExceptionInterface\n     */\n    public function touchItem($key);\n\n    /**\n     * Reset lifetime of multiple items.\n     *\n     * @param  array $keys\n     * @return array Array of not updated keys\n     * @throws \\Zend\\Cache\\Exception\\ExceptionInterface\n     */\n    public function touchItems(array $keys);\n\n    /**\n     * Remove an item.\n     *\n     * @param  string $key\n     * @return bool\n     * @throws \\Zend\\Cache\\Exception\\ExceptionInterface\n     */\n    public function removeItem($key);\n\n    /**\n     * Remove multiple items.\n     *\n     * @param  array $keys\n     * @return array Array of not removed keys\n     * @throws \\Zend\\Cache\\Exception\\ExceptionInterface\n     */\n    public function removeItems(array $keys);\n\n    /**\n     * Increment an item.\n     *\n     * @param  string $key\n     * @param  int    $value\n     * @return int|bool The new value on success, false on failure\n     * @throws \\Zend\\Cache\\Exception\\ExceptionInterface\n     */\n    public function incrementItem($key, $value);\n\n    /**\n     * Increment multiple items.\n     *\n     * @param  array $keyValuePairs\n     * @return array Associative array of keys and new values\n     * @throws \\Zend\\Cache\\Exception\\ExceptionInterface\n     */\n    public function incrementItems(array $keyValuePairs);\n\n    /**\n     * Decrement an item.\n     *\n     * @param  string $key\n     * @param  int    $value\n     * @return int|bool The new value on success, false on failure\n     * @throws \\Zend\\Cache\\Exception\\ExceptionInterface\n     */\n    public function decrementItem($key, $value);\n\n    /**\n     * Decrement multiple items.\n     *\n     * @param  array $keyValuePairs\n     * @return array Associative array of keys and new values\n     * @throws \\Zend\\Cache\\Exception\\ExceptionInterface\n     */\n    public function decrementItems(array $keyValuePairs);\n\n    /* status */\n\n    /**\n     * Capabilities of this storage\n     *\n     * @return Capabilities\n     */\n    public function getCapabilities();\n}\n\n\n\nThe AvailableSpaceCapableInterface\n\n\nZend\\Cache\\Storage\\AvailableSpaceCapableInterface\n implements a method to allow\nretrieving the current available space remaining in storage.\n\n\nnamespace Zend\\Cache\\Storage;\n\ninterface AvailableSpaceCapableInterface\n{\n    /**\n     * Get available space in bytes\n     *\n     * @return int|float\n     */\n    public function getAvailableSpace();\n}\n\n\n\nThe TotalSpaceCapableInterface\n\n\nZend\\Cache\\Storage\\TotalSpaceCapableInterface\n implements a method to allow\nretrieving the total storage space.\n\n\nnamespace Zend\\Cache\\Storage;\n\ninterface TotalSpaceCapableInterface\n{\n    /**\n     * Get total space in bytes\n     *\n     * @return int|float\n     */\n    public function getTotalSpace();\n}\n\n\n\nThe ClearByNamespaceInterface\n\n\nZend\\Cache\\Storage\\ClearByNamespaceInterface\n implements a method to allow\nclearing all cached items within a given namespace.\n\n\nnamespace Zend\\Cache\\Storage;\n\ninterface ClearByNamespaceInterface\n{\n    /**\n     * Remove items of given namespace\n     *\n     * @param string $namespace\n     * @return bool\n     */\n    public function clearByNamespace($namespace);\n}\n\n\n\nThe ClearByPrefixInterface\n\n\nZend\\Cache\\Storage\\ClearByPrefixInterface\n implements a method to allow\nclearing all cached items that have a given prefix (within the currently\nconfigured namespace).\n\n\nnamespace Zend\\Cache\\Storage;\n\ninterface ClearByPrefixInterface\n{\n    /**\n     * Remove items matching given prefix\n     *\n     * @param string $prefix\n     * @return bool\n     */\n    public function clearByPrefix($prefix);\n}\n\n\n\nThe ClearExpiredInterface\n\n\nZend\\Cache\\Storage\\ClearExpiredInterface\n implements a method to allow clearing\nall expired items (within the current configured namespace).\n\n\nnamespace Zend\\Cache\\Storage;\n\ninterface ClearExpiredInterface\n{\n    /**\n     * Remove expired items\n     *\n     * @return bool\n     */\n    public function clearExpired();\n}\n\n\n\nThe FlushableInterface\n\n\nZend\\Cache\\Storage\\FlushableInterface\n implements a method for flushing the\nentire cache storage.\n\n\nnamespace Zend\\Cache\\Storage;\n\ninterface FlushableInterface\n{\n    /**\n     * Flush the whole storage\n     *\n     * @return bool\n     */\n    public function flush();\n}\n\n\n\nThe IterableInterface\n\n\nZend\\Cache\\Storage\\IterableInterface\n implements a method for retrieving an\niterator of all items in storage. It extends \nIteratorAggregate\n, so it's\npossible to directly iterate over the storage implementations that implement\nthis interface using \nforeach\n.\n\n\nnamespace Zend\\Cache\\Storage;\n\nuse IteratorAggregate;\n\n/**\n *\n * @method IteratorInterface getIterator() Get the storage iterator\n */\ninterface IterableInterface extends IteratorAggregate\n{\n    /**\n     * @return \\Traversable\n     */\n    public function getIterator();\n}\n\n\n\nThe OptimizableInterface\n\n\nZend\\Cache\\Storage\\OptimizableInterface\n implements a method for running\noptimization processes on the storage adapter.\n\n\nnamespace Zend\\Cache\\Storage;\n\ninterface OptimizableInterface\n{\n    /**\n     * Optimize the storage\n     *\n     * @return bool\n     */\n    public function optimize();\n}\n\n\n\nThe TaggableInterface\n\n\nZend\\Cache\\Storage\\TaggableInterface\n implements methods for tagging items, and\ncleaning (expiring) items matching tags.\n\n\nnamespace Zend\\Cache\\Storage;\n\ninterface TaggableInterface\n{\n    /**\n     * Set tags to an item by given key.\n     * An empty array will remove all tags.\n     *\n     * @param string   $key\n     * @param string[] $tags\n     * @return bool\n     */\n    public function setTags($key, array $tags);\n\n    /**\n     * Get tags of an item by given key\n     *\n     * @param string $key\n     * @return string[]|FALSE\n     */\n    public function getTags($key);\n\n    /**\n     * Remove items matching given tags.\n     *\n     * If $disjunction only one of the given tags must match\n     * else all given tags must match.\n     *\n     * @param string[] $tags\n     * @param  bool  $disjunction\n     * @return bool\n     */\n    public function clearByTags(array $tags, $disjunction = false);\n}\n\n\n\nThe Apc Adapter\n\n\nZend\\Cache\\Storage\\Adapter\\Apc\n stores cache items in shared memory through the\nPHP extension \nAPC\n (Alternative PHP Cache).\n\n\nThis adapter implements the following interfaces:\n\n\n\n\nZend\\Cache\\Storage\\StorageInterface\n\n\nZend\\Cache\\Storage\\AvailableSpaceCapableInterface\n\n\nZend\\Cache\\Storage\\ClearByNamespaceInterface\n\n\nZend\\Cache\\Storage\\ClearByPrefixInterface\n\n\nZend\\Cache\\Storage\\FlushableInterface\n\n\nZend\\Cache\\Storage\\IterableInterface\n\n\nZend\\Cache\\Storage\\TotalSpaceCapableInterface\n\n\n\n\nCapabilities\n\n\n\n\n\n\n\n\nCapability\n\n\nValue\n\n\n\n\n\n\n\n\n\n\nsupportedDatatypes\n\n\nnull\n, \nbool\n, \nint\n, \nfloat\n, \nstring\n, \narray\n (serialized), \nobject\n (serialized)\n\n\n\n\n\n\nsupportedMetadata\n\n\ninternal_key, atime, ctime, mtime, rtime, size, hits, ttl\n\n\n\n\n\n\nminTtl\n\n\n1\n\n\n\n\n\n\nmaxTtl\n\n\n0\n\n\n\n\n\n\nstaticTtl\n\n\ntrue\n\n\n\n\n\n\nttlPrecision\n\n\n1\n\n\n\n\n\n\nuseRequestTime\n\n\nvalue of \napc.use_request_time\n from \nphp.ini\n\n\n\n\n\n\nlockOnExpire\n\n\n0\n\n\n\n\n\n\nmaxKeyLength\n\n\n5182\n\n\n\n\n\n\nnamespaceIsPrefix\n\n\ntrue\n\n\n\n\n\n\nnamespaceSeparator\n\n\nOption value of \nnamespace_separator\n\n\n\n\n\n\n\n\nAdapter specific options\n\n\n\n\n\n\n\n\nName\n\n\nData Type\n\n\nDefault Value\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nnamespace_separator\n\n\nstring\n\n\n\":\"\n\n\nA separator for the namespace and prefix.\n\n\n\n\n\n\n\n\nThe Dba Adapter\n\n\nZend\\Cache\\Storage\\Adapter\\Dba\n stores cache items into\n\ndbm\n-like databases using the PHP extension\n\ndba\n.\n\n\nThis adapter implements the following interfaces:\n\n\n\n\nZend\\Cache\\Storage\\StorageInterface\n\n\nZend\\Cache\\Storage\\AvailableSpaceCapableInterface\n\n\nZend\\Cache\\Storage\\ClearByNamespaceInterface\n\n\nZend\\Cache\\Storage\\ClearByPrefixInterface\n\n\nZend\\Cache\\Storage\\FlushableInterface\n\n\nZend\\Cache\\Storage\\IterableInterface\n\n\nZend\\Cache\\Storage\\OptimizableInterface\n\n\nZend\\Cache\\Storage\\TotalSpaceCapableInterface\n\n\n\n\nCapabilities\n\n\n\n\n\n\n\n\nCapability\n\n\nValue\n\n\n\n\n\n\n\n\n\n\nsupportedDatatypes\n\n\nstring\n, \nnull\n => \nstring\n, \nboolean\n => \nstring\n, \ninteger\n => \nstring\n, \ndouble\n => \nstring\n\n\n\n\n\n\nsupportedMetadata\n\n\nnone\n\n\n\n\n\n\nminTtl\n\n\n0\n\n\n\n\n\n\nmaxKeyLength\n\n\n0\n\n\n\n\n\n\nnamespaceIsPrefix\n\n\ntrue\n\n\n\n\n\n\nnamespaceSeparator\n\n\nOption value of \nnamespace_separator\n\n\n\n\n\n\n\n\nAdapter specific options\n\n\n\n\n\n\n\n\nName\n\n\nData Type\n\n\nDefault Value\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nnamespace_separator\n\n\nstring\n\n\n\":\"\n\n\nA separator for the namespace and prefix.\n\n\n\n\n\n\npathname\n\n\nstring\n\n\n\"\"\n\n\nPathname to the database file.\n\n\n\n\n\n\nmode\n\n\nstring\n\n\n\"c\"\n\n\nThe mode with which to open the database; please read \ndba_open\n for more information.\n\n\n\n\n\n\nhandler\n\n\nstring\n\n\n\"flatfile\"\n\n\nThe name of the handler which shall be used for accessing the database.\n\n\n\n\n\n\n\n\n\n\nThis adapter doesn't support automatic expiry\n\n\nBecause this adapter doesn't support automatic expiry, it's very important to clean\noutdated items periodically!\n\n\n\n\nThe Filesystem Adapter\n\n\nZend\\Cache\\Storage\\Adapter\\Filesystem\n stores cache items on the filesystem.\n\n\nThis adapter implements the following interfaces:\n\n\n\n\nZend\\Cache\\Storage\\StorageInterface\n\n\nZend\\Cache\\Storage\\AvailableSpaceCapableInterface\n\n\nZend\\Cache\\Storage\\ClearByNamespaceInterface\n\n\nZend\\Cache\\Storage\\ClearByPrefixInterface\n\n\nZend\\Cache\\Storage\\ClearExpiredInterface\n\n\nZend\\Cache\\Storage\\FlushableInterface\n\n\nZend\\Cache\\Storage\\IterableInterface\n\n\nZend\\Cache\\Storage\\OptimizableInterface\n\n\nZend\\Cache\\Storage\\TaggableInterface\n\n\nZend\\Cache\\Storage\\TotalSpaceCapableInterface\n\n\n\n\nCapabilities\n\n\n\n\n\n\n\n\nCapability\n\n\nValue\n\n\n\n\n\n\n\n\n\n\nsupportedDatatypes\n\n\nstring\n, \nnull\n => \nstring\n, \nboolean\n => \nstring\n, \ninteger\n => \nstring\n, \ndouble\n => \nstring\n\n\n\n\n\n\nsupportedMetadata\n\n\nmtime, filespec, atime, ctime\n\n\n\n\n\n\nminTtl\n\n\n1\n\n\n\n\n\n\nmaxTtl\n\n\n0\n\n\n\n\n\n\nstaticTtl\n\n\nfalse\n\n\n\n\n\n\nttlPrecision\n\n\n1\n\n\n\n\n\n\nuseRequestTime\n\n\nfalse\n\n\n\n\n\n\nlockOnExpire\n\n\n0\n\n\n\n\n\n\nmaxKeyLength\n\n\n251\n\n\n\n\n\n\nnamespaceIsPrefix\n\n\ntrue\n\n\n\n\n\n\nnamespaceSeparator\n\n\nOption value of \nnamespace_separator\n\n\n\n\n\n\n\n\nAdapter specific options\n\n\n\n\n\n\n\n\nName\n\n\nData Type\n\n\nDefault Value\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nnamespace_separator\n\n\nstring\n\n\n\":\"\n\n\nA separator for the namespace and prefix\n\n\n\n\n\n\ncache_dir\n\n\nstring\n\n\n\"\"\n\n\nDirectory to store cache files.\n\n\n\n\n\n\nclear_stat_cache\n\n\nboolean\n\n\ntrue\n\n\nCall \nclearstatcache()\n enabled?\n\n\n\n\n\n\ndir_level\n\n\ninteger\n\n\n1\n\n\nDefines how much sub-directories should be created.\n\n\n\n\n\n\ndir_permission\n\n\ninteger\n\n\nfalse\n\n\n0700    Set explicit permission on creating new directories.\n\n\n\n\n\n\nfile_locking\n\n\nboolean\n\n\ntrue\n\n\nLock files on writing.\n\n\n\n\n\n\nfile_permission\n\n\ninteger\n\n\nfalse\n\n\n0600    Set explicit permission on creating new files.\n\n\n\n\n\n\nkey_pattern\n\n\nstring\n\n\n/^[a-z0-9_\\+\\-]*$/Di\n\n\nValidate key against pattern.\n\n\n\n\n\n\nno_atime\n\n\nboolean\n\n\ntrue\n\n\nDon\u2019t get \u2018fileatime\u2019 as \u2018atime\u2019 on metadata.\n\n\n\n\n\n\nno_ctime\n\n\nboolean\n\n\ntrue\n\n\nDon\u2019t get \u2018filectime\u2019 as \u2018ctime\u2019 on metadata.\n\n\n\n\n\n\numask\n\n\ninteger|false\n\n\nfalse\n\n\nUse \numask\n to set file and directory permissions.\n\n\n\n\n\n\nsuffix\n\n\nstring\n\n\ndat\n\n\nSuffix for cache files\n\n\n\n\n\n\ntag_suffix\n\n\nstring\n\n\ntag\n\n\nSuffix for tag files\n\n\n\n\n\n\n\n\nNote: the \nsuffix\n and \ntag_suffix\n options will be escaped in order to be safe\nfor glob operations.\n\n\nThe Memcached Adapter\n\n\nZend\\Cache\\Storage\\Adapter\\Memcached\n stores cache items over the memcached\nprotocol, using the PHP extension \nmemcached\n,\nbased on \nLibmemcached\n.\n\n\nThis adapter implements the following interfaces:\n\n\n\n\nZend\\Cache\\Storage\\StorageInterface\n\n\nZend\\Cache\\Storage\\AvailableSpaceCapableInterface\n\n\nZend\\Cache\\Storage\\FlushableInterface\n\n\nZend\\Cache\\Storage\\TotalSpaceCapableInterface\n\n\n\n\nCapabilities\n\n\n\n\n\n\n\n\nCapability\n\n\nValue\n\n\n\n\n\n\n\n\n\n\nsupportedDatatypes\n\n\nnull\n, \nboolean\n, \ninteger\n, \ndouble\n, \nstring\n, \narray\n (serialized), \nobject\n (serialized)\n\n\n\n\n\n\nsupportedMetadata\n\n\nnone\n\n\n\n\n\n\nminTtl\n\n\n1\n\n\n\n\n\n\nmaxTtl\n\n\n0\n\n\n\n\n\n\nstaticTtl\n\n\ntrue\n\n\n\n\n\n\nttlPrecision\n\n\n1\n\n\n\n\n\n\nuseRequestTime\n\n\nfalse\n\n\n\n\n\n\nlockOnExpire\n\n\n0\n\n\n\n\n\n\nmaxKeyLength\n\n\n255\n\n\n\n\n\n\nnamespaceIsPrefix\n\n\ntrue\n\n\n\n\n\n\nnamespaceSeparator\n\n\nnone\n\n\n\n\n\n\n\n\nAdapter specific options\n\n\n\n\n\n\n\n\nName\n\n\nData Type\n\n\nDefault Value\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nservers\n\n\narray\n\n\n[]\n\n\nList of servers in the format \n[] = [string host, integer port]\n\n\n\n\n\n\nlib_options\n\n\narray\n\n\n[]\n\n\nAssociative array of Libmemcached options where the array key is the option name (without the prefix \nOPT_\n) or the constant value. The array value is the option value. Please read \nthe memcached setOption() page\n for more information\n\n\n\n\n\n\n\n\nThe Redis Adapter\n\n\nZend\\Cache\\Storage\\Adapter\\Redis\n stores cache items over the redis protocol\nusing the PHP extension \nredis\n.\n\n\nThis adapter implements the following interfaces:\n\n\n\n\nZend\\Cache\\Storage\\FlushableInterface\n\n\nZend\\Cache\\Storage\\TotalSpaceCapableInterface\n\n\n\n\nCapabilities\n\n\n\n\n\n\n\n\nCapability\n\n\nValue\n\n\n\n\n\n\n\n\n\n\nsupportedDatatypes\n\n\nstring\n, \narray\n (serialized), \nobject\n (serialized)\n\n\n\n\n\n\nsupportedMetadata\n\n\nnone\n\n\n\n\n\n\nminTtl\n\n\n1\n\n\n\n\n\n\nmaxTtl\n\n\n0\n\n\n\n\n\n\nstaticTtl\n\n\ntrue\n\n\n\n\n\n\nttlPrecision\n\n\n1\n\n\n\n\n\n\nuseRequestTime\n\n\nfalse\n\n\n\n\n\n\nlockOnExpire\n\n\n0\n\n\n\n\n\n\nmaxKeyLength\n\n\n255\n\n\n\n\n\n\nnamespaceIsPrefix\n\n\ntrue\n\n\n\n\n\n\nnamespaceSeparator\n\n\nnone\n\n\n\n\n\n\n\n\nAdapter specific options\n\n\n\n\n\n\n\n\nName\n\n\nData Type\n\n\nDefault Value\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\ndatabase\n\n\ninteger\n\n\n0\n\n\nSet database identifier.\n\n\n\n\n\n\nlib_options\n\n\narray\n\n\n[]\n\n\nAssociative array of redis options where the array key is the option name.\n\n\n\n\n\n\nnamespace_separator\n\n\nstring\n\n\n\":\"\n\n\nA separator for the namespace and prefix.\n\n\n\n\n\n\npassword\n\n\nstring\n\n\n\"\"\n\n\nSet password.\n\n\n\n\n\n\npersistent_id\n\n\nstring\n\n\n\n\nSet persistent id (name of the connection, leave blank to not use a persistent connection).\n\n\n\n\n\n\nresource_manager\n\n\nstring\n\n\n\n\nSet the redis resource manager to use\n\n\n\n\n\n\nserver\n\n\n\n\n\n\nSee below.\n\n\n\n\n\n\n\n\nserver\n can be described as any of the following:\n\n\n\n\nURI: \n/path/to/sock.sock\n\n\nAssociative array: \n['host' => <host>[, 'port' => <port>[, 'timeout' => <timeout>]]]\n\n\nList: \n[<host>[, <port>, [, <timeout>]]]\n\n\n\n\nThe Memory Adapter\n\n\nThe \nZend\\Cache\\Storage\\Adapter\\Memory\n stores items in-memory in the current\nprocess only.\n\n\nThis adapter implements the following interfaces:\n\n\n\n\nZend\\Cache\\Storage\\StorageInterface\n\n\nZend\\Cache\\Storage\\AvailableSpaceCapableInterface\n\n\nZend\\Cache\\Storage\\ClearByPrefixInterface\n\n\nZend\\Cache\\Storage\\ClearExpiredInterface\n\n\nZend\\Cache\\Storage\\FlushableInterface\n\n\nZend\\Cache\\Storage\\IterableInterface\n\n\nZend\\Cache\\Storage\\TaggableInterface\n\n\nZend\\Cache\\Storage\\TotalSpaceCapableInterface\n\n\n\n\nCapabilities\n\n\n\n\n\n\n\n\nCapability\n\n\nValue\n\n\n\n\n\n\n\n\n\n\nsupportedDatatypes\n\n\nstring\n, \nnull\n, \nboolean\n, \ninteger\n, \ndouble\n, \narray\n, \nobject\n, \nresource\n\n\n\n\n\n\nsupportedMetadata\n\n\nmtime\n\n\n\n\n\n\nminTtl\n\n\n1\n\n\n\n\n\n\nmaxTtl\n\n\nValue of \nPHP_INT_MAX\n\n\n\n\n\n\nstaticTtl\n\n\nfalse\n\n\n\n\n\n\nttlPrecision\n\n\n0.05\n\n\n\n\n\n\nuseRequestTime\n\n\nfalse\n\n\n\n\n\n\nlockOnExpire\n\n\n0\n\n\n\n\n\n\nmaxKeyLength\n\n\n0\n\n\n\n\n\n\nnamespaceIsPrefix\n\n\nfalse\n\n\n\n\n\n\n\n\nAdapter specific options\n\n\n\n\n\n\n\n\nName\n\n\nData Type\n\n\nDefault Value\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nmemory_limit\n\n\nstring|integer\n\n\n50% of \nmemory_limit\n INI value\n\n\nLimit of how much memory can PHP allocate to allow store items.\n\n\n\n\n\n\n\n\n\n\nMemory limit\n\n\nThe adapter has the following behavior with regards to the memory limit:\n\n\n\n\nIf the consumed memory exceeds the limit provided, an \nOutOfSpaceException\n\n  is thrown.\n\n\nA number less the or equal to zero disables the memory limit.\n\n\nWhen a value is provided for the memory limit, the value is measured in\n  bytes. Shorthand notation may also be provided.\n\n\n\n\nCurrent process only!\n\n\nAll stored items will be lost on termination of the script. For web-facing\nrequests, this typically means the cache is volatile.\n\n\n\n\nThe MongoDB Adapter\n\n\nZend\\Cache\\Storage\\Adapter\\MongoDB\n stores cache items using MongoDB, via either the\nPHP extension \nmongo\n, or a MongoDB polyfill library, such as\n\nMongofill\n.\n\n\n\n\next-mongodb\n\n\nIf you are using the mongodb extension (vs the mongo extension), you will need\nto use the \nExtMongoDb adapter\n instead.\n\n\n\n\nThis adapter implements the following interfaces:\n\n\n\n\nZend\\Cache\\Storage\\FlushableInterface\n\n\n\n\nCapabilities\n\n\n\n\n\n\n\n\nCapability\n\n\nValue\n\n\n\n\n\n\n\n\n\n\nsupportedDatatypes\n\n\nstring\n, \nnull\n, \nboolean\n, \ninteger\n, \ndouble\n, \narray\n\n\n\n\n\n\nsupportedMetadata\n\n\n_id\n\n\n\n\n\n\nminTtl\n\n\n0\n\n\n\n\n\n\nmaxTtl\n\n\n0\n\n\n\n\n\n\nstaticTtl\n\n\ntrue\n\n\n\n\n\n\nttlPrecision\n\n\n1\n\n\n\n\n\n\nuseRequestTime\n\n\nfalse\n\n\n\n\n\n\nlockOnExpire\n\n\n0\n\n\n\n\n\n\nmaxKeyLength\n\n\n255\n\n\n\n\n\n\nnamespaceIsPrefix\n\n\ntrue\n\n\n\n\n\n\nnamespaceSeparator\n\n\n\n\n\n\n\n\n\n\nAdapter specific options\n\n\n\n\n\n\n\n\nName\n\n\nData Type\n\n\nDefault Value\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nlib_option\n\n\narray\n\n\n\n\nAssociative array of options where the array key is the option name.\n\n\n\n\n\n\nnamespace_separator\n\n\nstring\n\n\n\":\"\n\n\nA separator for the namespace and prefix.\n\n\n\n\n\n\n\n\nAvailable keys for \nlib_option\n include:\n\n\n\n\n\n\n\n\nKey\n\n\nDefault\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nserver\n\n\nmongodb://localhost:27017\n\n\nThe MongoDB server connection string (see the \nMongoClient docs\n).\n\n\n\n\n\n\ndatabase\n\n\nzend\n\n\nName of the database to use; MongoDB will create this database if it does not exist.\n\n\n\n\n\n\ncollection\n\n\ncache\n\n\nName of the collection to use; MongoDB will create this collection if it does not exist.\n\n\n\n\n\n\nconnectionOptions\n\n\n['fsync' => false, 'journal' => true]\n\n\nAssociative array of options to pass to \nMongoClient\n (see the \nMongoClient docs\n).\n\n\n\n\n\n\ndriverOptions\n\n\n[]\n\n\nAssociative array of driver options to pass to \nMongoClient\n (see the \nMongoClient docs\n).\n\n\n\n\n\n\n\n\nThe ExtMongoDB Adapter\n\n\n\n\nSince 2.8.0\n\n\n\n\nZend\\Cache\\Storage\\Adapter\\ExtMongoDB\n stores cache items using the mongodb extension, and\nrequires that the MongoDB PHP Client library is also installed. You can install the client\nlibrary using the following:\n\n\n$ composer require mongodb/mongodb\n\n\n\n\n\next-mongo\n\n\nIf you are using the mongo extension (vs the mongodb extension), you will need\nto use the \nMongoDb adapter\n instead.\n\n\n\n\nThis adapter implements the following interfaces:\n\n\n\n\nZend\\Cache\\Storage\\FlushableInterface\n\n\n\n\nCapabilities\n\n\n\n\n\n\n\n\nCapability\n\n\nValue\n\n\n\n\n\n\n\n\n\n\nsupportedDatatypes\n\n\nstring\n, \nnull\n, \nboolean\n, \ninteger\n, \ndouble\n, \narray\n\n\n\n\n\n\nsupportedMetadata\n\n\n_id\n\n\n\n\n\n\nminTtl\n\n\n0\n\n\n\n\n\n\nmaxTtl\n\n\n0\n\n\n\n\n\n\nstaticTtl\n\n\ntrue\n\n\n\n\n\n\nttlPrecision\n\n\n1\n\n\n\n\n\n\nuseRequestTime\n\n\nfalse\n\n\n\n\n\n\nlockOnExpire\n\n\n0\n\n\n\n\n\n\nmaxKeyLength\n\n\n255\n\n\n\n\n\n\nnamespaceIsPrefix\n\n\ntrue\n\n\n\n\n\n\nnamespaceSeparator\n\n\n\n\n\n\n\n\n\n\nAdapter specific options\n\n\n\n\n\n\n\n\nName\n\n\nData Type\n\n\nDefault Value\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nlib_option\n\n\narray\n\n\n\n\nAssociative array of options where the array key is the option name.\n\n\n\n\n\n\nnamespace_separator\n\n\nstring\n\n\n\":\"\n\n\nA separator for the namespace and prefix.\n\n\n\n\n\n\n\n\nAvailable keys for \nlib_option\n include:\n\n\n\n\n\n\n\n\nKey\n\n\nDefault\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nserver\n\n\nmongodb://localhost:27017\n\n\nThe MongoDB server connection string (see the \nMongoDB\\Client docs\n).\n\n\n\n\n\n\ndatabase\n\n\nzend\n\n\nName of the database to use; MongoDB will create this database if it does not exist.\n\n\n\n\n\n\ncollection\n\n\ncache\n\n\nName of the collection to use; MongoDB will create this collection if it does not exist.\n\n\n\n\n\n\nconnectionOptions\n\n\n['fsync' => false, 'journal' => true]\n\n\nAssociative array of URI options (such as authentication credentials or query string parameters) to pass to \nMongoDB\\\\Client\n (see the \nMongoDB\\Client docs\n).\n\n\n\n\n\n\ndriverOptions\n\n\n[]\n\n\nAssociative array of driver options to pass to \nMongoDB\\\\Client\n (see the \nMongoDB\\Client docs\n).\n\n\n\n\n\n\n\n\nThe WinCache Adapter\n\n\nZend\\Cache\\Storage\\Adapter\\WinCache\n stores cache items into shared memory\nthrough the PHP extension \nWinCache\n.\n\n\nThis adapter implements the following interfaces:\n\n\n\n\nZend\\Cache\\Storage\\StorageInterface\n\n\nZend\\Cache\\Storage\\AvailableSpaceCapableInterface\n\n\nZend\\Cache\\Storage\\FlushableInterface\n\n\nZend\\Cache\\Storage\\TotalSpaceCapableInterface\n\n\n\n\nCapabilities\n\n\n\n\n\n\n\n\nCapability\n\n\nValue\n\n\n\n\n\n\n\n\n\n\nsupportedDatatypes\n\n\nnull\n, \nboolean\n, \ninteger\n, \ndouble\n, \nstring\n, \narray\n (serialized), \nobject\n (serialized)\n\n\n\n\n\n\nsupportedMetadata\n\n\ninternal_key, ttl, hits, size\n\n\n\n\n\n\nminTtl\n\n\n1\n\n\n\n\n\n\nmaxTtl\n\n\n0\n\n\n\n\n\n\nstaticTtl\n\n\ntrue\n\n\n\n\n\n\nttlPrecision\n\n\n1\n\n\n\n\n\n\nuseRequestTime\n\n\napc.use_request_time\n \nphp.ini\n value.\n\n\n\n\n\n\nlockOnExpire\n\n\n0\n\n\n\n\n\n\nnamespaceIsPrefix\n\n\ntrue\n\n\n\n\n\n\nnamespaceSeparator\n\n\nOption value of \nnamespace_separator\n\n\n\n\n\n\n\n\nAdapter specific options\n\n\n\n\n\n\n\n\nName\n\n\nData Type\n\n\nDefault Value\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nnamespace_separator\n\n\nstring\n\n\n\":\"\n\n\nA separator for the namespace and prefix.\n\n\n\n\n\n\n\n\nThe XCache Adapter\n\n\nZend\\Cache\\Storage\\Adapter\\XCache\n stores cache items into shared memory through the\nPHP extension \nXCache\n.\n\n\nThis adapter implements the following interfaces:\n\n\n\n\nZend\\Cache\\Storage\\StorageInterface\n\n\nZend\\Cache\\Storage\\AvailableSpaceCapableInterface\n\n\nZend\\Cache\\Storage\\ClearByNamespaceInterface\n\n\nZend\\Cache\\Storage\\ClearByPrefixInterface\n\n\nZend\\Cache\\Storage\\FlushableInterface\n\n\nZend\\Cache\\Storage\\IterableInterface\n\n\nZend\\Cache\\Storage\\TotalSpaceCapableInterface\n\n\n\n\nCapabilities\n\n\n\n\n\n\n\n\nCapability\n\n\nValue\n\n\n\n\n\n\n\n\n\n\nsupportedDatatypes\n\n\nboolean\n, \ninteger\n, \ndouble\n, \nstring\n, \narray\n (serialized), \nobject\n (serialized)\n\n\n\n\n\n\nsupportedMetadata\n\n\ninternal_key, size, refcount, hits, ctime, atime, hvalue\n\n\n\n\n\n\nminTtl\n\n\n1\n\n\n\n\n\n\nmaxTtl\n\n\nxcache.var_maxttl\n \nphp.ini\n value\n\n\n\n\n\n\nstaticTtl\n\n\ntrue\n\n\n\n\n\n\nttlPrecision\n\n\n1\n\n\n\n\n\n\nuseRequestTime\n\n\ntrue\n\n\n\n\n\n\nlockOnExpire\n\n\n0\n\n\n\n\n\n\nmaxKeyLength\n\n\n5182\n\n\n\n\n\n\nnamespaceIsPrefix\n\n\ntrue\n\n\n\n\n\n\nnamespaceSeparator\n\n\nOption value of \nnamespace_separator\n\n\n\n\n\n\n\n\nAdapter specific options\n\n\n\n\n\n\n\n\nName\n\n\nData Type\n\n\nDefault Value\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nnamespace_separator\n\n\nstring\n\n\n\":\"\n\n\nA separator for the namespace and prefix.\n\n\n\n\n\n\nadmin_auth\n\n\nboolean\n\n\nfalse\n\n\nEnable admin authentication by configuration options \nadmin_user\n and \nadmin_pass\n.  This makes XCache administration functions accessible without the need of HTTP-Authentication if \nxcache.admin.enable_auth\n is enabled.\n\n\n\n\n\n\nadmin_user\n\n\nstring\n\n\n\"\"\n\n\nThe username of \nxcache.admin.user\n.\n\n\n\n\n\n\nadmin_pass\n\n\nstring\n\n\n\"\"\n\n\nThe password of \nxcache.admin.pass\n in plain text.\n\n\n\n\n\n\n\n\nThe ZendServerDisk Adapter\n\n\nZend\\Cache\\Storage\\Adapter\\ZendServerDisk\n stores cache items on the filesystem\nusing the \nZend Server Data Caching API\n.\n\n\nThis adapter implements the following interfaces:\n\n\n\n\nZend\\Cache\\Storage\\StorageInterface\n\n\nZend\\Cache\\Storage\\AvailableSpaceCapableInterface\n\n\nZend\\Cache\\Storage\\ClearByNamespaceInterface\n\n\nZend\\Cache\\Storage\\FlushableInterface\n\n\nZend\\Cache\\Storage\\TotalSpaceCapableInterface\n\n\n\n\nCapabilities\n\n\n\n\n\n\n\n\nCapability\n\n\nValue\n\n\n\n\n\n\n\n\n\n\nsupportedDatatypes\n\n\nnull\n, \nboolean\n, \ninteger\n, \ndouble\n, \nstring\n, \narray\n (serialized), \nobject\n (serialized)\n\n\n\n\n\n\nsupportedMetadata\n\n\nnone\n\n\n\n\n\n\nminTtl\n\n\n1\n\n\n\n\n\n\nmaxTtl\n\n\n0\n\n\n\n\n\n\nmaxKeyLength\n\n\n0\n\n\n\n\n\n\nstaticTtl\n\n\ntrue\n\n\n\n\n\n\nttlPrecision\n\n\n1\n\n\n\n\n\n\nuseRequestTime\n\n\nfalse\n\n\n\n\n\n\nlockOnExpire\n\n\nif 'zend_datacache.lock_on_expire' is enabled 120 else 0\n\n\n\n\n\n\nnamespaceIsPrefix\n\n\ntrue\n\n\n\n\n\n\nnamespaceSeparator\n\n\n::\n\n\n\n\n\n\n\n\nThe ZendServerShm Adapter\n\n\nZend\\Cache\\Storage\\Adapter\\ZendServerShm\n stores cache items in shared memory\nthrough the \nZend Server Data Caching API\n.\n\n\nThis adapter implements the following interfaces:\n\n\n\n\nZend\\Cache\\Storage\\StorageInterface\n\n\nZend\\Cache\\Storage\\ClearByNamespaceInterface\n\n\nZend\\Cache\\Storage\\FlushableInterface\n\n\nZend\\Cache\\Storage\\TotalSpaceCapableInterface\n\n\n\n\nCapabilities\n\n\n\n\n\n\n\n\nCapability\n\n\nValue\n\n\n\n\n\n\n\n\n\n\nsupportedDatatypes\n\n\nnull\n, \nboolean\n, \ninteger\n, \ndouble\n, \nstring\n, \narray\n (serialized), \nobject\n (serialized)\n\n\n\n\n\n\nsupportedMetadata\n\n\nnone\n\n\n\n\n\n\nminTtl\n\n\n1\n\n\n\n\n\n\nmaxTtl\n\n\n0\n\n\n\n\n\n\nmaxKeyLength\n\n\n0\n\n\n\n\n\n\nstaticTtl\n\n\ntrue\n\n\n\n\n\n\nttlPrecision\n\n\n1\n\n\n\n\n\n\nuseRequestTime\n\n\nfalse\n\n\n\n\n\n\nlockOnExpire\n\n\nif 'zend_datacache.lock_on_expire' is enabled 120 else 0\n\n\n\n\n\n\nnamespaceIsPrefix\n\n\ntrue\n\n\n\n\n\n\nnamespaceSeparator\n\n\n::\n\n\n\n\n\n\n\n\nExamples\n\n\nBasic usage\n\n\nuse Zend\\Cache\\StorageFactory;\n\n$cache = StorageFactory::factory([\n    'adapter' => [\n        'name' => 'filesystem'\n    ],\n    'plugins' => [\n        // Don't throw exceptions on cache errors\n        'exception_handler' => [\n            'throw_exceptions' => false\n        ],\n    ],\n]);\n\n$key    = 'unique-cache-key';\n$result = $cache->getItem($key, $success);\nif (! $success) {\n    $result = doExpensiveStuff();\n    $cache->setItem($key, $result);\n}\n\n\n\nGet multiple rows from a database\n\n\nuse Zend\\Cache\\StorageFactory;\n\n// Instantiate the cache instance using a namespace for the same type of items\n$cache = StorageFactory::factory([\n    'adapter' => [\n        'name' => 'filesystem',\n        // With a namespace, we can indicate the same type of items,\n        // so we can simply use the database id as the cache key\n        'options' => [\n            'namespace' => 'dbtable',\n        ],\n    ],\n    'plugins' => [\n        // Don't throw exceptions on cache errors\n        'exception_handler' => [\n            'throw_exceptions' => false,\n        ],\n        // We store database rows on filesystem so we need to serialize them\n        'Serializer',\n    ],\n]);\n\n// Load two rows from cache if possible\n$ids     = [1, 2];\n$results = $cache->getItems($ids);\nif (count($results) < count($ids)) {\n    // Load rows from db if loading from cache failed\n    $missingIds     = array_diff($ids, array_keys($results));\n    $missingResults = [];\n    $query          = 'SELECT * FROM dbtable WHERE id IN (' . implode(',', $missingIds) . ')';\n    foreach ($pdo->query($query, PDO::FETCH_ASSOC) as $row) {\n        $missingResults[ $row['id'] ] = $row;\n    }\n\n    // Update cache items of the loaded rows from db\n    $cache->setItems($missingResults);\n\n    // merge results from cache and db\n    $results = array_merge($results, $missingResults);\n}",
            "title": "Adapters"
        },
        {
            "location": "/storage/adapter/#adapters",
            "text": "Storage adapters are wrappers for real storage resources such as memory or the filesystem, using\nthe well known  adapter  pattern.  They come with tons of methods to read, write, and modify stored items, and to get information about\nstored items and the storage.  All adapters implement  Zend\\Cache\\Storage\\StorageInterface , and most extend Zend\\Cache\\Storage\\Adapter\\AbstractAdapter , which provides a foundation of\ncommon logic.  Configuration is handled by either  Zend\\Cache\\Storage\\Adapter\\AdapterOptions ,\nor an adapter-specific options class if it exists. You may pass the options\ninstance to the class at instantiation, via the  setOptions()  method, or,\nalternately, pass an associative array of options in either place (internally,\nthese are then passed to an options class instance). Alternately, you can pass\neither the options instance or associative array to the Zend\\Cache\\StorageFactory::factory  method.",
            "title": "Adapters"
        },
        {
            "location": "/storage/adapter/#many-methods-throw-exceptions",
            "text": "Because many caching operations throw an exception on error, you need to catch\nthem. You can do so manually, or you can use the plugin Zend\\Cache\\Storage\\Plugin\\ExceptionHandler  with  throw_exceptions  set to false  to automatically catch them. You can also define an exception_callback  to log exceptions.",
            "title": "Many methods throw exceptions"
        },
        {
            "location": "/storage/adapter/#quick-start",
            "text": "Caching adapters can either be created from the provided Zend\\Cache\\StorageFactory , or by instantiating one of the Zend\\Cache\\Storage\\Adapter\\*  classes.  To make life easier, the Zend\\Cache\\StorageFactory  comes with a  factory()  method to create an adapter\nand all requested plugins at once.  use Zend\\Cache\\StorageFactory;\n\n// Via factory:\n$cache = StorageFactory::factory([\n    'adapter' => [\n        'name'    => 'apc',\n        'options' => ['ttl' => 3600],\n    ],\n    'plugins' => [\n        'exception_handler' => ['throw_exceptions' => false],\n    ],\n]);\n\n// Alternately, create the adapter and plugin separately:\n$cache  = StorageFactory::adapterFactory('apc', ['ttl' => 3600]);\n$plugin = StorageFactory::pluginFactory('exception_handler', [\n    'throw_exceptions' => false,\n]);\n$cache->addPlugin($plugin);\n\n// Or do it completely manually:\n$cache  = new Zend\\Cache\\Storage\\Adapter\\Apc();\n$cache->getOptions()->setTtl(3600);\n\n$plugin = new Zend\\Cache\\Storage\\Plugin\\ExceptionHandler();\n$plugin->getOptions()->setThrowExceptions(false);\n$cache->addPlugin($plugin);",
            "title": "Quick Start"
        },
        {
            "location": "/storage/adapter/#basic-configuration-options",
            "text": "The following configuration options are defined by  Zend\\Cache\\Storage\\Adapter\\AdapterOptions  and\nare available for every supported adapter. Adapter-specific configuration options are described on\nadapter level below.     Option  Data Type  Default Value  Description      ttl  integer  0  Time to live    namespace  string  \u201czfcache\u201d  The \u201cnamespace\u201d in which cache items will live    key_pattern  null|string  null  Pattern against which to validate cache keys    readable  boolean  true  Enable/Disable reading data from cache    writable  boolean  true  Enable/Disable writing data to cache",
            "title": "Basic Configuration Options"
        },
        {
            "location": "/storage/adapter/#the-storageinterface",
            "text": "Zend\\Cache\\Storage\\StorageInterface  is the basic interface implemented by all\nstorage adapters.  namespace Zend\\Cache\\Storage;\n\nuse Traversable;\n\ninterface StorageInterface\n{\n    /**\n     * Set options.\n     *\n     * @param array|Traversable|Adapter\\AdapterOptions $options\n     * @return StorageInterface Fluent interface\n     */\n    public function setOptions($options);\n\n    /**\n     * Get options\n     *\n     * @return Adapter\\AdapterOptions\n     */\n    public function getOptions();\n\n    /* reading */\n\n    /**\n     * Get an item.\n     *\n     * @param  string  $key\n     * @param  bool $success\n     * @param  mixed   $casToken\n     * @return mixed Data on success, null on failure\n     * @throws \\Zend\\Cache\\Exception\\ExceptionInterface\n     */\n    public function getItem($key, & $success = null, & $casToken = null);\n\n    /**\n     * Get multiple items.\n     *\n     * @param  array $keys\n     * @return array Associative array of keys and values\n     * @throws \\Zend\\Cache\\Exception\\ExceptionInterface\n     */\n    public function getItems(array $keys);\n\n    /**\n     * Test if an item exists.\n     *\n     * @param  string $key\n     * @return bool\n     * @throws \\Zend\\Cache\\Exception\\ExceptionInterface\n     */\n    public function hasItem($key);\n\n    /**\n     * Test multiple items.\n     *\n     * @param  array $keys\n     * @return array Array of found keys\n     * @throws \\Zend\\Cache\\Exception\\ExceptionInterface\n     */\n    public function hasItems(array $keys);\n\n    /**\n     * Get metadata of an item.\n     *\n     * @param  string $key\n     * @return array|bool Metadata on success, false on failure\n     * @throws \\Zend\\Cache\\Exception\\ExceptionInterface\n     */\n    public function getMetadata($key);\n\n    /**\n     * Get multiple metadata\n     *\n     * @param  array $keys\n     * @return array Associative array of keys and metadata\n     * @throws \\Zend\\Cache\\Exception\\ExceptionInterface\n     */\n    public function getMetadatas(array $keys);\n\n    /* writing */\n\n    /**\n     * Store an item.\n     *\n     * @param  string $key\n     * @param  mixed  $value\n     * @return bool\n     * @throws \\Zend\\Cache\\Exception\\ExceptionInterface\n     */\n    public function setItem($key, $value);\n\n    /**\n     * Store multiple items.\n     *\n     * @param  array $keyValuePairs\n     * @return array Array of not stored keys\n     * @throws \\Zend\\Cache\\Exception\\ExceptionInterface\n     */\n    public function setItems(array $keyValuePairs);\n\n    /**\n     * Add an item.\n     *\n     * @param  string $key\n     * @param  mixed  $value\n     * @return bool\n     * @throws \\Zend\\Cache\\Exception\\ExceptionInterface\n     */\n    public function addItem($key, $value);\n\n    /**\n     * Add multiple items.\n     *\n     * @param  array $keyValuePairs\n     * @return array Array of not stored keys\n     * @throws \\Zend\\Cache\\Exception\\ExceptionInterface\n     */\n    public function addItems(array $keyValuePairs);\n\n    /**\n     * Replace an existing item.\n     *\n     * @param  string $key\n     * @param  mixed  $value\n     * @return bool\n     * @throws \\Zend\\Cache\\Exception\\ExceptionInterface\n     */\n    public function replaceItem($key, $value);\n\n    /**\n     * Replace multiple existing items.\n     *\n     * @param  array $keyValuePairs\n     * @return array Array of not stored keys\n     * @throws \\Zend\\Cache\\Exception\\ExceptionInterface\n     */\n    public function replaceItems(array $keyValuePairs);\n\n    /**\n     * Set an item only if token matches\n     *\n     * It uses the token received from getItem() to check if the item has\n     * changed before overwriting it.\n     *\n     * @param  mixed  $token\n     * @param  string $key\n     * @param  mixed  $value\n     * @return bool\n     * @throws \\Zend\\Cache\\Exception\\ExceptionInterface\n     * @see    getItem()\n     * @see    setItem()\n     */\n    public function checkAndSetItem($token, $key, $value);\n\n    /**\n     * Reset lifetime of an item\n     *\n     * @param  string $key\n     * @return bool\n     * @throws \\Zend\\Cache\\Exception\\ExceptionInterface\n     */\n    public function touchItem($key);\n\n    /**\n     * Reset lifetime of multiple items.\n     *\n     * @param  array $keys\n     * @return array Array of not updated keys\n     * @throws \\Zend\\Cache\\Exception\\ExceptionInterface\n     */\n    public function touchItems(array $keys);\n\n    /**\n     * Remove an item.\n     *\n     * @param  string $key\n     * @return bool\n     * @throws \\Zend\\Cache\\Exception\\ExceptionInterface\n     */\n    public function removeItem($key);\n\n    /**\n     * Remove multiple items.\n     *\n     * @param  array $keys\n     * @return array Array of not removed keys\n     * @throws \\Zend\\Cache\\Exception\\ExceptionInterface\n     */\n    public function removeItems(array $keys);\n\n    /**\n     * Increment an item.\n     *\n     * @param  string $key\n     * @param  int    $value\n     * @return int|bool The new value on success, false on failure\n     * @throws \\Zend\\Cache\\Exception\\ExceptionInterface\n     */\n    public function incrementItem($key, $value);\n\n    /**\n     * Increment multiple items.\n     *\n     * @param  array $keyValuePairs\n     * @return array Associative array of keys and new values\n     * @throws \\Zend\\Cache\\Exception\\ExceptionInterface\n     */\n    public function incrementItems(array $keyValuePairs);\n\n    /**\n     * Decrement an item.\n     *\n     * @param  string $key\n     * @param  int    $value\n     * @return int|bool The new value on success, false on failure\n     * @throws \\Zend\\Cache\\Exception\\ExceptionInterface\n     */\n    public function decrementItem($key, $value);\n\n    /**\n     * Decrement multiple items.\n     *\n     * @param  array $keyValuePairs\n     * @return array Associative array of keys and new values\n     * @throws \\Zend\\Cache\\Exception\\ExceptionInterface\n     */\n    public function decrementItems(array $keyValuePairs);\n\n    /* status */\n\n    /**\n     * Capabilities of this storage\n     *\n     * @return Capabilities\n     */\n    public function getCapabilities();\n}",
            "title": "The StorageInterface"
        },
        {
            "location": "/storage/adapter/#the-availablespacecapableinterface",
            "text": "Zend\\Cache\\Storage\\AvailableSpaceCapableInterface  implements a method to allow\nretrieving the current available space remaining in storage.  namespace Zend\\Cache\\Storage;\n\ninterface AvailableSpaceCapableInterface\n{\n    /**\n     * Get available space in bytes\n     *\n     * @return int|float\n     */\n    public function getAvailableSpace();\n}",
            "title": "The AvailableSpaceCapableInterface"
        },
        {
            "location": "/storage/adapter/#the-totalspacecapableinterface",
            "text": "Zend\\Cache\\Storage\\TotalSpaceCapableInterface  implements a method to allow\nretrieving the total storage space.  namespace Zend\\Cache\\Storage;\n\ninterface TotalSpaceCapableInterface\n{\n    /**\n     * Get total space in bytes\n     *\n     * @return int|float\n     */\n    public function getTotalSpace();\n}",
            "title": "The TotalSpaceCapableInterface"
        },
        {
            "location": "/storage/adapter/#the-clearbynamespaceinterface",
            "text": "Zend\\Cache\\Storage\\ClearByNamespaceInterface  implements a method to allow\nclearing all cached items within a given namespace.  namespace Zend\\Cache\\Storage;\n\ninterface ClearByNamespaceInterface\n{\n    /**\n     * Remove items of given namespace\n     *\n     * @param string $namespace\n     * @return bool\n     */\n    public function clearByNamespace($namespace);\n}",
            "title": "The ClearByNamespaceInterface"
        },
        {
            "location": "/storage/adapter/#the-clearbyprefixinterface",
            "text": "Zend\\Cache\\Storage\\ClearByPrefixInterface  implements a method to allow\nclearing all cached items that have a given prefix (within the currently\nconfigured namespace).  namespace Zend\\Cache\\Storage;\n\ninterface ClearByPrefixInterface\n{\n    /**\n     * Remove items matching given prefix\n     *\n     * @param string $prefix\n     * @return bool\n     */\n    public function clearByPrefix($prefix);\n}",
            "title": "The ClearByPrefixInterface"
        },
        {
            "location": "/storage/adapter/#the-clearexpiredinterface",
            "text": "Zend\\Cache\\Storage\\ClearExpiredInterface  implements a method to allow clearing\nall expired items (within the current configured namespace).  namespace Zend\\Cache\\Storage;\n\ninterface ClearExpiredInterface\n{\n    /**\n     * Remove expired items\n     *\n     * @return bool\n     */\n    public function clearExpired();\n}",
            "title": "The ClearExpiredInterface"
        },
        {
            "location": "/storage/adapter/#the-flushableinterface",
            "text": "Zend\\Cache\\Storage\\FlushableInterface  implements a method for flushing the\nentire cache storage.  namespace Zend\\Cache\\Storage;\n\ninterface FlushableInterface\n{\n    /**\n     * Flush the whole storage\n     *\n     * @return bool\n     */\n    public function flush();\n}",
            "title": "The FlushableInterface"
        },
        {
            "location": "/storage/adapter/#the-iterableinterface",
            "text": "Zend\\Cache\\Storage\\IterableInterface  implements a method for retrieving an\niterator of all items in storage. It extends  IteratorAggregate , so it's\npossible to directly iterate over the storage implementations that implement\nthis interface using  foreach .  namespace Zend\\Cache\\Storage;\n\nuse IteratorAggregate;\n\n/**\n *\n * @method IteratorInterface getIterator() Get the storage iterator\n */\ninterface IterableInterface extends IteratorAggregate\n{\n    /**\n     * @return \\Traversable\n     */\n    public function getIterator();\n}",
            "title": "The IterableInterface"
        },
        {
            "location": "/storage/adapter/#the-optimizableinterface",
            "text": "Zend\\Cache\\Storage\\OptimizableInterface  implements a method for running\noptimization processes on the storage adapter.  namespace Zend\\Cache\\Storage;\n\ninterface OptimizableInterface\n{\n    /**\n     * Optimize the storage\n     *\n     * @return bool\n     */\n    public function optimize();\n}",
            "title": "The OptimizableInterface"
        },
        {
            "location": "/storage/adapter/#the-taggableinterface",
            "text": "Zend\\Cache\\Storage\\TaggableInterface  implements methods for tagging items, and\ncleaning (expiring) items matching tags.  namespace Zend\\Cache\\Storage;\n\ninterface TaggableInterface\n{\n    /**\n     * Set tags to an item by given key.\n     * An empty array will remove all tags.\n     *\n     * @param string   $key\n     * @param string[] $tags\n     * @return bool\n     */\n    public function setTags($key, array $tags);\n\n    /**\n     * Get tags of an item by given key\n     *\n     * @param string $key\n     * @return string[]|FALSE\n     */\n    public function getTags($key);\n\n    /**\n     * Remove items matching given tags.\n     *\n     * If $disjunction only one of the given tags must match\n     * else all given tags must match.\n     *\n     * @param string[] $tags\n     * @param  bool  $disjunction\n     * @return bool\n     */\n    public function clearByTags(array $tags, $disjunction = false);\n}",
            "title": "The TaggableInterface"
        },
        {
            "location": "/storage/adapter/#the-apc-adapter",
            "text": "Zend\\Cache\\Storage\\Adapter\\Apc  stores cache items in shared memory through the\nPHP extension  APC  (Alternative PHP Cache).  This adapter implements the following interfaces:   Zend\\Cache\\Storage\\StorageInterface  Zend\\Cache\\Storage\\AvailableSpaceCapableInterface  Zend\\Cache\\Storage\\ClearByNamespaceInterface  Zend\\Cache\\Storage\\ClearByPrefixInterface  Zend\\Cache\\Storage\\FlushableInterface  Zend\\Cache\\Storage\\IterableInterface  Zend\\Cache\\Storage\\TotalSpaceCapableInterface",
            "title": "The Apc Adapter"
        },
        {
            "location": "/storage/adapter/#capabilities",
            "text": "Capability  Value      supportedDatatypes  null ,  bool ,  int ,  float ,  string ,  array  (serialized),  object  (serialized)    supportedMetadata  internal_key, atime, ctime, mtime, rtime, size, hits, ttl    minTtl  1    maxTtl  0    staticTtl  true    ttlPrecision  1    useRequestTime  value of  apc.use_request_time  from  php.ini    lockOnExpire  0    maxKeyLength  5182    namespaceIsPrefix  true    namespaceSeparator  Option value of  namespace_separator",
            "title": "Capabilities"
        },
        {
            "location": "/storage/adapter/#adapter-specific-options",
            "text": "Name  Data Type  Default Value  Description      namespace_separator  string  \":\"  A separator for the namespace and prefix.",
            "title": "Adapter specific options"
        },
        {
            "location": "/storage/adapter/#the-dba-adapter",
            "text": "Zend\\Cache\\Storage\\Adapter\\Dba  stores cache items into dbm -like databases using the PHP extension dba .  This adapter implements the following interfaces:   Zend\\Cache\\Storage\\StorageInterface  Zend\\Cache\\Storage\\AvailableSpaceCapableInterface  Zend\\Cache\\Storage\\ClearByNamespaceInterface  Zend\\Cache\\Storage\\ClearByPrefixInterface  Zend\\Cache\\Storage\\FlushableInterface  Zend\\Cache\\Storage\\IterableInterface  Zend\\Cache\\Storage\\OptimizableInterface  Zend\\Cache\\Storage\\TotalSpaceCapableInterface",
            "title": "The Dba Adapter"
        },
        {
            "location": "/storage/adapter/#capabilities_1",
            "text": "Capability  Value      supportedDatatypes  string ,  null  =>  string ,  boolean  =>  string ,  integer  =>  string ,  double  =>  string    supportedMetadata  none    minTtl  0    maxKeyLength  0    namespaceIsPrefix  true    namespaceSeparator  Option value of  namespace_separator",
            "title": "Capabilities"
        },
        {
            "location": "/storage/adapter/#adapter-specific-options_1",
            "text": "Name  Data Type  Default Value  Description      namespace_separator  string  \":\"  A separator for the namespace and prefix.    pathname  string  \"\"  Pathname to the database file.    mode  string  \"c\"  The mode with which to open the database; please read  dba_open  for more information.    handler  string  \"flatfile\"  The name of the handler which shall be used for accessing the database.",
            "title": "Adapter specific options"
        },
        {
            "location": "/storage/adapter/#this-adapter-doesnt-support-automatic-expiry",
            "text": "Because this adapter doesn't support automatic expiry, it's very important to clean\noutdated items periodically!",
            "title": "This adapter doesn't support automatic expiry"
        },
        {
            "location": "/storage/adapter/#the-filesystem-adapter",
            "text": "Zend\\Cache\\Storage\\Adapter\\Filesystem  stores cache items on the filesystem.  This adapter implements the following interfaces:   Zend\\Cache\\Storage\\StorageInterface  Zend\\Cache\\Storage\\AvailableSpaceCapableInterface  Zend\\Cache\\Storage\\ClearByNamespaceInterface  Zend\\Cache\\Storage\\ClearByPrefixInterface  Zend\\Cache\\Storage\\ClearExpiredInterface  Zend\\Cache\\Storage\\FlushableInterface  Zend\\Cache\\Storage\\IterableInterface  Zend\\Cache\\Storage\\OptimizableInterface  Zend\\Cache\\Storage\\TaggableInterface  Zend\\Cache\\Storage\\TotalSpaceCapableInterface",
            "title": "The Filesystem Adapter"
        },
        {
            "location": "/storage/adapter/#capabilities_2",
            "text": "Capability  Value      supportedDatatypes  string ,  null  =>  string ,  boolean  =>  string ,  integer  =>  string ,  double  =>  string    supportedMetadata  mtime, filespec, atime, ctime    minTtl  1    maxTtl  0    staticTtl  false    ttlPrecision  1    useRequestTime  false    lockOnExpire  0    maxKeyLength  251    namespaceIsPrefix  true    namespaceSeparator  Option value of  namespace_separator",
            "title": "Capabilities"
        },
        {
            "location": "/storage/adapter/#adapter-specific-options_2",
            "text": "Name  Data Type  Default Value  Description      namespace_separator  string  \":\"  A separator for the namespace and prefix    cache_dir  string  \"\"  Directory to store cache files.    clear_stat_cache  boolean  true  Call  clearstatcache()  enabled?    dir_level  integer  1  Defines how much sub-directories should be created.    dir_permission  integer  false  0700    Set explicit permission on creating new directories.    file_locking  boolean  true  Lock files on writing.    file_permission  integer  false  0600    Set explicit permission on creating new files.    key_pattern  string  /^[a-z0-9_\\+\\-]*$/Di  Validate key against pattern.    no_atime  boolean  true  Don\u2019t get \u2018fileatime\u2019 as \u2018atime\u2019 on metadata.    no_ctime  boolean  true  Don\u2019t get \u2018filectime\u2019 as \u2018ctime\u2019 on metadata.    umask  integer|false  false  Use  umask  to set file and directory permissions.    suffix  string  dat  Suffix for cache files    tag_suffix  string  tag  Suffix for tag files     Note: the  suffix  and  tag_suffix  options will be escaped in order to be safe\nfor glob operations.",
            "title": "Adapter specific options"
        },
        {
            "location": "/storage/adapter/#the-memcached-adapter",
            "text": "Zend\\Cache\\Storage\\Adapter\\Memcached  stores cache items over the memcached\nprotocol, using the PHP extension  memcached ,\nbased on  Libmemcached .  This adapter implements the following interfaces:   Zend\\Cache\\Storage\\StorageInterface  Zend\\Cache\\Storage\\AvailableSpaceCapableInterface  Zend\\Cache\\Storage\\FlushableInterface  Zend\\Cache\\Storage\\TotalSpaceCapableInterface",
            "title": "The Memcached Adapter"
        },
        {
            "location": "/storage/adapter/#capabilities_3",
            "text": "Capability  Value      supportedDatatypes  null ,  boolean ,  integer ,  double ,  string ,  array  (serialized),  object  (serialized)    supportedMetadata  none    minTtl  1    maxTtl  0    staticTtl  true    ttlPrecision  1    useRequestTime  false    lockOnExpire  0    maxKeyLength  255    namespaceIsPrefix  true    namespaceSeparator  none",
            "title": "Capabilities"
        },
        {
            "location": "/storage/adapter/#adapter-specific-options_3",
            "text": "Name  Data Type  Default Value  Description      servers  array  []  List of servers in the format  [] = [string host, integer port]    lib_options  array  []  Associative array of Libmemcached options where the array key is the option name (without the prefix  OPT_ ) or the constant value. The array value is the option value. Please read  the memcached setOption() page  for more information",
            "title": "Adapter specific options"
        },
        {
            "location": "/storage/adapter/#the-redis-adapter",
            "text": "Zend\\Cache\\Storage\\Adapter\\Redis  stores cache items over the redis protocol\nusing the PHP extension  redis .  This adapter implements the following interfaces:   Zend\\Cache\\Storage\\FlushableInterface  Zend\\Cache\\Storage\\TotalSpaceCapableInterface",
            "title": "The Redis Adapter"
        },
        {
            "location": "/storage/adapter/#capabilities_4",
            "text": "Capability  Value      supportedDatatypes  string ,  array  (serialized),  object  (serialized)    supportedMetadata  none    minTtl  1    maxTtl  0    staticTtl  true    ttlPrecision  1    useRequestTime  false    lockOnExpire  0    maxKeyLength  255    namespaceIsPrefix  true    namespaceSeparator  none",
            "title": "Capabilities"
        },
        {
            "location": "/storage/adapter/#adapter-specific-options_4",
            "text": "Name  Data Type  Default Value  Description      database  integer  0  Set database identifier.    lib_options  array  []  Associative array of redis options where the array key is the option name.    namespace_separator  string  \":\"  A separator for the namespace and prefix.    password  string  \"\"  Set password.    persistent_id  string   Set persistent id (name of the connection, leave blank to not use a persistent connection).    resource_manager  string   Set the redis resource manager to use    server    See below.     server  can be described as any of the following:   URI:  /path/to/sock.sock  Associative array:  ['host' => <host>[, 'port' => <port>[, 'timeout' => <timeout>]]]  List:  [<host>[, <port>, [, <timeout>]]]",
            "title": "Adapter specific options"
        },
        {
            "location": "/storage/adapter/#the-memory-adapter",
            "text": "The  Zend\\Cache\\Storage\\Adapter\\Memory  stores items in-memory in the current\nprocess only.  This adapter implements the following interfaces:   Zend\\Cache\\Storage\\StorageInterface  Zend\\Cache\\Storage\\AvailableSpaceCapableInterface  Zend\\Cache\\Storage\\ClearByPrefixInterface  Zend\\Cache\\Storage\\ClearExpiredInterface  Zend\\Cache\\Storage\\FlushableInterface  Zend\\Cache\\Storage\\IterableInterface  Zend\\Cache\\Storage\\TaggableInterface  Zend\\Cache\\Storage\\TotalSpaceCapableInterface",
            "title": "The Memory Adapter"
        },
        {
            "location": "/storage/adapter/#capabilities_5",
            "text": "Capability  Value      supportedDatatypes  string ,  null ,  boolean ,  integer ,  double ,  array ,  object ,  resource    supportedMetadata  mtime    minTtl  1    maxTtl  Value of  PHP_INT_MAX    staticTtl  false    ttlPrecision  0.05    useRequestTime  false    lockOnExpire  0    maxKeyLength  0    namespaceIsPrefix  false",
            "title": "Capabilities"
        },
        {
            "location": "/storage/adapter/#adapter-specific-options_5",
            "text": "Name  Data Type  Default Value  Description      memory_limit  string|integer  50% of  memory_limit  INI value  Limit of how much memory can PHP allocate to allow store items.",
            "title": "Adapter specific options"
        },
        {
            "location": "/storage/adapter/#memory-limit",
            "text": "The adapter has the following behavior with regards to the memory limit:   If the consumed memory exceeds the limit provided, an  OutOfSpaceException \n  is thrown.  A number less the or equal to zero disables the memory limit.  When a value is provided for the memory limit, the value is measured in\n  bytes. Shorthand notation may also be provided.",
            "title": "Memory limit"
        },
        {
            "location": "/storage/adapter/#current-process-only",
            "text": "All stored items will be lost on termination of the script. For web-facing\nrequests, this typically means the cache is volatile.",
            "title": "Current process only!"
        },
        {
            "location": "/storage/adapter/#the-mongodb-adapter",
            "text": "Zend\\Cache\\Storage\\Adapter\\MongoDB  stores cache items using MongoDB, via either the\nPHP extension  mongo , or a MongoDB polyfill library, such as Mongofill .",
            "title": "The MongoDB Adapter"
        },
        {
            "location": "/storage/adapter/#ext-mongodb",
            "text": "If you are using the mongodb extension (vs the mongo extension), you will need\nto use the  ExtMongoDb adapter  instead.   This adapter implements the following interfaces:   Zend\\Cache\\Storage\\FlushableInterface",
            "title": "ext-mongodb"
        },
        {
            "location": "/storage/adapter/#capabilities_6",
            "text": "Capability  Value      supportedDatatypes  string ,  null ,  boolean ,  integer ,  double ,  array    supportedMetadata  _id    minTtl  0    maxTtl  0    staticTtl  true    ttlPrecision  1    useRequestTime  false    lockOnExpire  0    maxKeyLength  255    namespaceIsPrefix  true    namespaceSeparator",
            "title": "Capabilities"
        },
        {
            "location": "/storage/adapter/#adapter-specific-options_6",
            "text": "Name  Data Type  Default Value  Description      lib_option  array   Associative array of options where the array key is the option name.    namespace_separator  string  \":\"  A separator for the namespace and prefix.     Available keys for  lib_option  include:     Key  Default  Description      server  mongodb://localhost:27017  The MongoDB server connection string (see the  MongoClient docs ).    database  zend  Name of the database to use; MongoDB will create this database if it does not exist.    collection  cache  Name of the collection to use; MongoDB will create this collection if it does not exist.    connectionOptions  ['fsync' => false, 'journal' => true]  Associative array of options to pass to  MongoClient  (see the  MongoClient docs ).    driverOptions  []  Associative array of driver options to pass to  MongoClient  (see the  MongoClient docs ).",
            "title": "Adapter specific options"
        },
        {
            "location": "/storage/adapter/#the-extmongodb-adapter",
            "text": "Since 2.8.0   Zend\\Cache\\Storage\\Adapter\\ExtMongoDB  stores cache items using the mongodb extension, and\nrequires that the MongoDB PHP Client library is also installed. You can install the client\nlibrary using the following:  $ composer require mongodb/mongodb",
            "title": "The ExtMongoDB Adapter"
        },
        {
            "location": "/storage/adapter/#ext-mongo",
            "text": "If you are using the mongo extension (vs the mongodb extension), you will need\nto use the  MongoDb adapter  instead.   This adapter implements the following interfaces:   Zend\\Cache\\Storage\\FlushableInterface",
            "title": "ext-mongo"
        },
        {
            "location": "/storage/adapter/#capabilities_7",
            "text": "Capability  Value      supportedDatatypes  string ,  null ,  boolean ,  integer ,  double ,  array    supportedMetadata  _id    minTtl  0    maxTtl  0    staticTtl  true    ttlPrecision  1    useRequestTime  false    lockOnExpire  0    maxKeyLength  255    namespaceIsPrefix  true    namespaceSeparator",
            "title": "Capabilities"
        },
        {
            "location": "/storage/adapter/#adapter-specific-options_7",
            "text": "Name  Data Type  Default Value  Description      lib_option  array   Associative array of options where the array key is the option name.    namespace_separator  string  \":\"  A separator for the namespace and prefix.     Available keys for  lib_option  include:     Key  Default  Description      server  mongodb://localhost:27017  The MongoDB server connection string (see the  MongoDB\\Client docs ).    database  zend  Name of the database to use; MongoDB will create this database if it does not exist.    collection  cache  Name of the collection to use; MongoDB will create this collection if it does not exist.    connectionOptions  ['fsync' => false, 'journal' => true]  Associative array of URI options (such as authentication credentials or query string parameters) to pass to  MongoDB\\\\Client  (see the  MongoDB\\Client docs ).    driverOptions  []  Associative array of driver options to pass to  MongoDB\\\\Client  (see the  MongoDB\\Client docs ).",
            "title": "Adapter specific options"
        },
        {
            "location": "/storage/adapter/#the-wincache-adapter",
            "text": "Zend\\Cache\\Storage\\Adapter\\WinCache  stores cache items into shared memory\nthrough the PHP extension  WinCache .  This adapter implements the following interfaces:   Zend\\Cache\\Storage\\StorageInterface  Zend\\Cache\\Storage\\AvailableSpaceCapableInterface  Zend\\Cache\\Storage\\FlushableInterface  Zend\\Cache\\Storage\\TotalSpaceCapableInterface",
            "title": "The WinCache Adapter"
        },
        {
            "location": "/storage/adapter/#capabilities_8",
            "text": "Capability  Value      supportedDatatypes  null ,  boolean ,  integer ,  double ,  string ,  array  (serialized),  object  (serialized)    supportedMetadata  internal_key, ttl, hits, size    minTtl  1    maxTtl  0    staticTtl  true    ttlPrecision  1    useRequestTime  apc.use_request_time   php.ini  value.    lockOnExpire  0    namespaceIsPrefix  true    namespaceSeparator  Option value of  namespace_separator",
            "title": "Capabilities"
        },
        {
            "location": "/storage/adapter/#adapter-specific-options_8",
            "text": "Name  Data Type  Default Value  Description      namespace_separator  string  \":\"  A separator for the namespace and prefix.",
            "title": "Adapter specific options"
        },
        {
            "location": "/storage/adapter/#the-xcache-adapter",
            "text": "Zend\\Cache\\Storage\\Adapter\\XCache  stores cache items into shared memory through the\nPHP extension  XCache .  This adapter implements the following interfaces:   Zend\\Cache\\Storage\\StorageInterface  Zend\\Cache\\Storage\\AvailableSpaceCapableInterface  Zend\\Cache\\Storage\\ClearByNamespaceInterface  Zend\\Cache\\Storage\\ClearByPrefixInterface  Zend\\Cache\\Storage\\FlushableInterface  Zend\\Cache\\Storage\\IterableInterface  Zend\\Cache\\Storage\\TotalSpaceCapableInterface",
            "title": "The XCache Adapter"
        },
        {
            "location": "/storage/adapter/#capabilities_9",
            "text": "Capability  Value      supportedDatatypes  boolean ,  integer ,  double ,  string ,  array  (serialized),  object  (serialized)    supportedMetadata  internal_key, size, refcount, hits, ctime, atime, hvalue    minTtl  1    maxTtl  xcache.var_maxttl   php.ini  value    staticTtl  true    ttlPrecision  1    useRequestTime  true    lockOnExpire  0    maxKeyLength  5182    namespaceIsPrefix  true    namespaceSeparator  Option value of  namespace_separator",
            "title": "Capabilities"
        },
        {
            "location": "/storage/adapter/#adapter-specific-options_9",
            "text": "Name  Data Type  Default Value  Description      namespace_separator  string  \":\"  A separator for the namespace and prefix.    admin_auth  boolean  false  Enable admin authentication by configuration options  admin_user  and  admin_pass .  This makes XCache administration functions accessible without the need of HTTP-Authentication if  xcache.admin.enable_auth  is enabled.    admin_user  string  \"\"  The username of  xcache.admin.user .    admin_pass  string  \"\"  The password of  xcache.admin.pass  in plain text.",
            "title": "Adapter specific options"
        },
        {
            "location": "/storage/adapter/#the-zendserverdisk-adapter",
            "text": "Zend\\Cache\\Storage\\Adapter\\ZendServerDisk  stores cache items on the filesystem\nusing the  Zend Server Data Caching API .  This adapter implements the following interfaces:   Zend\\Cache\\Storage\\StorageInterface  Zend\\Cache\\Storage\\AvailableSpaceCapableInterface  Zend\\Cache\\Storage\\ClearByNamespaceInterface  Zend\\Cache\\Storage\\FlushableInterface  Zend\\Cache\\Storage\\TotalSpaceCapableInterface",
            "title": "The ZendServerDisk Adapter"
        },
        {
            "location": "/storage/adapter/#capabilities_10",
            "text": "Capability  Value      supportedDatatypes  null ,  boolean ,  integer ,  double ,  string ,  array  (serialized),  object  (serialized)    supportedMetadata  none    minTtl  1    maxTtl  0    maxKeyLength  0    staticTtl  true    ttlPrecision  1    useRequestTime  false    lockOnExpire  if 'zend_datacache.lock_on_expire' is enabled 120 else 0    namespaceIsPrefix  true    namespaceSeparator  ::",
            "title": "Capabilities"
        },
        {
            "location": "/storage/adapter/#the-zendservershm-adapter",
            "text": "Zend\\Cache\\Storage\\Adapter\\ZendServerShm  stores cache items in shared memory\nthrough the  Zend Server Data Caching API .  This adapter implements the following interfaces:   Zend\\Cache\\Storage\\StorageInterface  Zend\\Cache\\Storage\\ClearByNamespaceInterface  Zend\\Cache\\Storage\\FlushableInterface  Zend\\Cache\\Storage\\TotalSpaceCapableInterface",
            "title": "The ZendServerShm Adapter"
        },
        {
            "location": "/storage/adapter/#capabilities_11",
            "text": "Capability  Value      supportedDatatypes  null ,  boolean ,  integer ,  double ,  string ,  array  (serialized),  object  (serialized)    supportedMetadata  none    minTtl  1    maxTtl  0    maxKeyLength  0    staticTtl  true    ttlPrecision  1    useRequestTime  false    lockOnExpire  if 'zend_datacache.lock_on_expire' is enabled 120 else 0    namespaceIsPrefix  true    namespaceSeparator  ::",
            "title": "Capabilities"
        },
        {
            "location": "/storage/adapter/#examples",
            "text": "",
            "title": "Examples"
        },
        {
            "location": "/storage/adapter/#basic-usage",
            "text": "use Zend\\Cache\\StorageFactory;\n\n$cache = StorageFactory::factory([\n    'adapter' => [\n        'name' => 'filesystem'\n    ],\n    'plugins' => [\n        // Don't throw exceptions on cache errors\n        'exception_handler' => [\n            'throw_exceptions' => false\n        ],\n    ],\n]);\n\n$key    = 'unique-cache-key';\n$result = $cache->getItem($key, $success);\nif (! $success) {\n    $result = doExpensiveStuff();\n    $cache->setItem($key, $result);\n}",
            "title": "Basic usage"
        },
        {
            "location": "/storage/adapter/#get-multiple-rows-from-a-database",
            "text": "use Zend\\Cache\\StorageFactory;\n\n// Instantiate the cache instance using a namespace for the same type of items\n$cache = StorageFactory::factory([\n    'adapter' => [\n        'name' => 'filesystem',\n        // With a namespace, we can indicate the same type of items,\n        // so we can simply use the database id as the cache key\n        'options' => [\n            'namespace' => 'dbtable',\n        ],\n    ],\n    'plugins' => [\n        // Don't throw exceptions on cache errors\n        'exception_handler' => [\n            'throw_exceptions' => false,\n        ],\n        // We store database rows on filesystem so we need to serialize them\n        'Serializer',\n    ],\n]);\n\n// Load two rows from cache if possible\n$ids     = [1, 2];\n$results = $cache->getItems($ids);\nif (count($results) < count($ids)) {\n    // Load rows from db if loading from cache failed\n    $missingIds     = array_diff($ids, array_keys($results));\n    $missingResults = [];\n    $query          = 'SELECT * FROM dbtable WHERE id IN (' . implode(',', $missingIds) . ')';\n    foreach ($pdo->query($query, PDO::FETCH_ASSOC) as $row) {\n        $missingResults[ $row['id'] ] = $row;\n    }\n\n    // Update cache items of the loaded rows from db\n    $cache->setItems($missingResults);\n\n    // merge results from cache and db\n    $results = array_merge($results, $missingResults);\n}",
            "title": "Get multiple rows from a database"
        },
        {
            "location": "/storage/capabilities/",
            "text": "Storage Capabilities\n\n\nStorage capabilities describe how a storage adapter works, and which features it\nsupports.\n\n\nTo get capabilities of a storage adapter, you can use the method\n\ngetCapabilities()\n, but only the storage adapter and its plugins have\npermissions to change them.\n\n\nBecause capabilities are mutable, you can subscribe to the \"change\" event to get\nnotifications; see the examples for details.\n\n\nIf you are writing your own plugin or adapter, you can also change capabilities\nbecause you have access to the marker object and can create your own marker to\ninstantiate a new instance of \nZend\\Cache\\Storage\\Capabilities\n.\n\n\nAvailable Methods\n\n\nnamespace Zend\\Cache\\Storage;\n\nuse ArrayObject;\nuse stdClass;\nuse Zend\\Cache\\Exception;\nuse Zend\\EventManager\\EventsCapableInterface;\n\nclass Capabilities\n{\n    /**\n     * Constructor\n     *\n     * @param StorageInterface  $storage\n     * @param stdClass          $marker\n     * @param array             $capabilities\n     * @param null|Capabilities $baseCapabilities\n     */\n    public function __construct(\n        StorageInterface $storage,\n        stdClass $marker,\n        array $capabilities = [],\n        Capabilities $baseCapabilities = null\n    );\n\n    /**\n     * Get the storage adapter\n     *\n     * @return StorageInterface\n     */\n    public function getAdapter();\n\n    /**\n     * Get supported datatypes\n     *\n     * @return array\n     */\n    public function getSupportedDatatypes();\n\n    /**\n     * Set supported datatypes\n     *\n     * @param  stdClass $marker\n     * @param  array $datatypes\n     * @throws Exception\\InvalidArgumentException\n     * @return Capabilities Fluent interface\n     */\n    public function setSupportedDatatypes(stdClass $marker, array $datatypes);\n\n    /**\n     * Get supported metadata\n     *\n     * @return array\n     */\n    public function getSupportedMetadata();\n\n    /**\n     * Set supported metadata\n     *\n     * @param  stdClass $marker\n     * @param  string[] $metadata\n     * @throws Exception\\InvalidArgumentException\n     * @return Capabilities Fluent interface\n     */\n    public function setSupportedMetadata(stdClass $marker, array $metadata);\n\n    /**\n     * Get minimum supported time-to-live\n     *\n     * @return int 0 means items never expire\n     */\n    public function getMinTtl();\n\n    /**\n     * Set minimum supported time-to-live\n     *\n     * @param  stdClass $marker\n     * @param  int $minTtl\n     * @throws Exception\\InvalidArgumentException\n     * @return Capabilities Fluent interface\n     */\n    public function setMinTtl(stdClass $marker, $minTtl);\n\n    /**\n     * Get maximum supported time-to-live\n     *\n     * @return int 0 means infinite\n     */\n    public function getMaxTtl();\n\n    /**\n     * Set maximum supported time-to-live\n     *\n     * @param  stdClass $marker\n     * @param  int $maxTtl\n     * @throws Exception\\InvalidArgumentException\n     * @return Capabilities Fluent interface\n     */\n    public function setMaxTtl(stdClass $marker, $maxTtl);\n\n    /**\n     * Is the time-to-live handled static (on write)\n     * or dynamic (on read)\n     *\n     * @return bool\n     */\n    public function getStaticTtl();\n\n    /**\n     * Set if the time-to-live handled static (on write) or dynamic (on read)\n     *\n     * @param  stdClass $marker\n     * @param  bool $flag\n     * @return Capabilities Fluent interface\n     */\n    public function setStaticTtl(stdClass $marker, $flag);\n\n    /**\n     * Get time-to-live precision\n     *\n     * @return float\n     */\n    public function getTtlPrecision();\n\n    /**\n     * Set time-to-live precision\n     *\n     * @param  stdClass $marker\n     * @param  float $ttlPrecision\n     * @throws Exception\\InvalidArgumentException\n     * @return Capabilities Fluent interface\n     */\n    public function setTtlPrecision(stdClass $marker, $ttlPrecision);\n\n    /**\n     * Get use request time\n     *\n     * @return bool\n     */\n    public function getUseRequestTime();\n\n    /**\n     * Set use request time\n     *\n     * @param  stdClass $marker\n     * @param  bool $flag\n     * @return Capabilities Fluent interface\n     */\n    public function setUseRequestTime(stdClass $marker, $flag);\n\n    /**\n     * Get if expired items are readable\n     *\n     * @return bool\n     * @deprecated This capability has been deprecated and will be removed in the future.\n     *             Please use getStaticTtl() instead\n     */\n    public function getExpiredRead();\n\n    /**\n     * Set if expired items are readable\n     *\n     * @param  stdClass $marker\n     * @param  bool $flag\n     * @return Capabilities Fluent interface\n     * @deprecated This capability has been deprecated and will be removed in the future.\n     *             Please use setStaticTtl() instead\n     */\n    public function setExpiredRead(stdClass $marker, $flag);\n\n    /**\n     * Get \"lock-on-expire\" support in seconds.\n     *\n     * @return int  0 = Expired items will never be retrieved\n     *             >0 = Time in seconds an expired item could be retrieved\n     *             -1 = Expired items could be retrieved forever\n     */\n    public function getLockOnExpire()\n    {\n        return $this->getCapability('lockOnExpire', 0);\n    }\n\n    /**\n     * Set \"lock-on-expire\" support in seconds.\n     *\n     * @param  stdClass $marker\n     * @param  int      $timeout\n     * @return Capabilities Fluent interface\n     */\n    public function setLockOnExpire(stdClass $marker, $timeout)\n    {\n        return $this->setCapability($marker, 'lockOnExpire', (int) $timeout);\n    }\n\n    /**\n     * Get maximum key length\n     *\n     * @return int -1 means unknown, 0 means infinite\n     */\n    public function getMaxKeyLength();\n\n    /**\n     * Set maximum key length\n     *\n     * @param  stdClass $marker\n     * @param  int $maxKeyLength\n     * @throws Exception\\InvalidArgumentException\n     * @return Capabilities Fluent interface\n     */\n    public function setMaxKeyLength(stdClass $marker, $maxKeyLength);\n\n    /**\n     * Get if namespace support is implemented as prefix\n     *\n     * @return bool\n     */\n    public function getNamespaceIsPrefix();\n\n    /**\n     * Set if namespace support is implemented as prefix\n     *\n     * @param  stdClass $marker\n     * @param  bool $flag\n     * @return Capabilities Fluent interface\n     */\n    public function setNamespaceIsPrefix(stdClass $marker, $flag);\n\n    /**\n     * Get namespace separator if namespace is implemented as prefix\n     *\n     * @return string\n     */\n    public function getNamespaceSeparator();\n\n    /**\n     * Set the namespace separator if namespace is implemented as prefix\n     *\n     * @param  stdClass $marker\n     * @param  string $separator\n     * @return Capabilities Fluent interface\n     */\n    public function setNamespaceSeparator(stdClass $marker, $separator);\n}\n\n\n\nExamples\n\n\nGet storage capabilities and do specific stuff based on them\n\n\nuse Zend\\Cache\\StorageFactory;\n\n$cache = StorageFactory::adapterFactory('filesystem');\n$supportedDatatypes = $cache->getCapabilities()->getSupportedDatatypes();\n\n// now you can run specific stuff in base of supported feature\nif ($supportedDatatypes['object']) {\n    $cache->set($key, $object);\n} else {\n    $cache->set($key, serialize($object));\n}\n\n\n\nListen to the change event\n\n\nuse Zend\\Cache\\StorageFactory;\n\n$cache = StorageFactory::adapterFactory('filesystem', [\n    'no_atime' => false,\n]);\n\n// Catching capability changes\n$cache->getEventManager()->attach('capability', function($event) {\n    echo count($event->getParams()) . ' capabilities changed';\n});\n\n// change option which changes capabilities\n$cache->getOptions()->setNoATime(true);",
            "title": "Capabilities"
        },
        {
            "location": "/storage/capabilities/#storage-capabilities",
            "text": "Storage capabilities describe how a storage adapter works, and which features it\nsupports.  To get capabilities of a storage adapter, you can use the method getCapabilities() , but only the storage adapter and its plugins have\npermissions to change them.  Because capabilities are mutable, you can subscribe to the \"change\" event to get\nnotifications; see the examples for details.  If you are writing your own plugin or adapter, you can also change capabilities\nbecause you have access to the marker object and can create your own marker to\ninstantiate a new instance of  Zend\\Cache\\Storage\\Capabilities .",
            "title": "Storage Capabilities"
        },
        {
            "location": "/storage/capabilities/#available-methods",
            "text": "namespace Zend\\Cache\\Storage;\n\nuse ArrayObject;\nuse stdClass;\nuse Zend\\Cache\\Exception;\nuse Zend\\EventManager\\EventsCapableInterface;\n\nclass Capabilities\n{\n    /**\n     * Constructor\n     *\n     * @param StorageInterface  $storage\n     * @param stdClass          $marker\n     * @param array             $capabilities\n     * @param null|Capabilities $baseCapabilities\n     */\n    public function __construct(\n        StorageInterface $storage,\n        stdClass $marker,\n        array $capabilities = [],\n        Capabilities $baseCapabilities = null\n    );\n\n    /**\n     * Get the storage adapter\n     *\n     * @return StorageInterface\n     */\n    public function getAdapter();\n\n    /**\n     * Get supported datatypes\n     *\n     * @return array\n     */\n    public function getSupportedDatatypes();\n\n    /**\n     * Set supported datatypes\n     *\n     * @param  stdClass $marker\n     * @param  array $datatypes\n     * @throws Exception\\InvalidArgumentException\n     * @return Capabilities Fluent interface\n     */\n    public function setSupportedDatatypes(stdClass $marker, array $datatypes);\n\n    /**\n     * Get supported metadata\n     *\n     * @return array\n     */\n    public function getSupportedMetadata();\n\n    /**\n     * Set supported metadata\n     *\n     * @param  stdClass $marker\n     * @param  string[] $metadata\n     * @throws Exception\\InvalidArgumentException\n     * @return Capabilities Fluent interface\n     */\n    public function setSupportedMetadata(stdClass $marker, array $metadata);\n\n    /**\n     * Get minimum supported time-to-live\n     *\n     * @return int 0 means items never expire\n     */\n    public function getMinTtl();\n\n    /**\n     * Set minimum supported time-to-live\n     *\n     * @param  stdClass $marker\n     * @param  int $minTtl\n     * @throws Exception\\InvalidArgumentException\n     * @return Capabilities Fluent interface\n     */\n    public function setMinTtl(stdClass $marker, $minTtl);\n\n    /**\n     * Get maximum supported time-to-live\n     *\n     * @return int 0 means infinite\n     */\n    public function getMaxTtl();\n\n    /**\n     * Set maximum supported time-to-live\n     *\n     * @param  stdClass $marker\n     * @param  int $maxTtl\n     * @throws Exception\\InvalidArgumentException\n     * @return Capabilities Fluent interface\n     */\n    public function setMaxTtl(stdClass $marker, $maxTtl);\n\n    /**\n     * Is the time-to-live handled static (on write)\n     * or dynamic (on read)\n     *\n     * @return bool\n     */\n    public function getStaticTtl();\n\n    /**\n     * Set if the time-to-live handled static (on write) or dynamic (on read)\n     *\n     * @param  stdClass $marker\n     * @param  bool $flag\n     * @return Capabilities Fluent interface\n     */\n    public function setStaticTtl(stdClass $marker, $flag);\n\n    /**\n     * Get time-to-live precision\n     *\n     * @return float\n     */\n    public function getTtlPrecision();\n\n    /**\n     * Set time-to-live precision\n     *\n     * @param  stdClass $marker\n     * @param  float $ttlPrecision\n     * @throws Exception\\InvalidArgumentException\n     * @return Capabilities Fluent interface\n     */\n    public function setTtlPrecision(stdClass $marker, $ttlPrecision);\n\n    /**\n     * Get use request time\n     *\n     * @return bool\n     */\n    public function getUseRequestTime();\n\n    /**\n     * Set use request time\n     *\n     * @param  stdClass $marker\n     * @param  bool $flag\n     * @return Capabilities Fluent interface\n     */\n    public function setUseRequestTime(stdClass $marker, $flag);\n\n    /**\n     * Get if expired items are readable\n     *\n     * @return bool\n     * @deprecated This capability has been deprecated and will be removed in the future.\n     *             Please use getStaticTtl() instead\n     */\n    public function getExpiredRead();\n\n    /**\n     * Set if expired items are readable\n     *\n     * @param  stdClass $marker\n     * @param  bool $flag\n     * @return Capabilities Fluent interface\n     * @deprecated This capability has been deprecated and will be removed in the future.\n     *             Please use setStaticTtl() instead\n     */\n    public function setExpiredRead(stdClass $marker, $flag);\n\n    /**\n     * Get \"lock-on-expire\" support in seconds.\n     *\n     * @return int  0 = Expired items will never be retrieved\n     *             >0 = Time in seconds an expired item could be retrieved\n     *             -1 = Expired items could be retrieved forever\n     */\n    public function getLockOnExpire()\n    {\n        return $this->getCapability('lockOnExpire', 0);\n    }\n\n    /**\n     * Set \"lock-on-expire\" support in seconds.\n     *\n     * @param  stdClass $marker\n     * @param  int      $timeout\n     * @return Capabilities Fluent interface\n     */\n    public function setLockOnExpire(stdClass $marker, $timeout)\n    {\n        return $this->setCapability($marker, 'lockOnExpire', (int) $timeout);\n    }\n\n    /**\n     * Get maximum key length\n     *\n     * @return int -1 means unknown, 0 means infinite\n     */\n    public function getMaxKeyLength();\n\n    /**\n     * Set maximum key length\n     *\n     * @param  stdClass $marker\n     * @param  int $maxKeyLength\n     * @throws Exception\\InvalidArgumentException\n     * @return Capabilities Fluent interface\n     */\n    public function setMaxKeyLength(stdClass $marker, $maxKeyLength);\n\n    /**\n     * Get if namespace support is implemented as prefix\n     *\n     * @return bool\n     */\n    public function getNamespaceIsPrefix();\n\n    /**\n     * Set if namespace support is implemented as prefix\n     *\n     * @param  stdClass $marker\n     * @param  bool $flag\n     * @return Capabilities Fluent interface\n     */\n    public function setNamespaceIsPrefix(stdClass $marker, $flag);\n\n    /**\n     * Get namespace separator if namespace is implemented as prefix\n     *\n     * @return string\n     */\n    public function getNamespaceSeparator();\n\n    /**\n     * Set the namespace separator if namespace is implemented as prefix\n     *\n     * @param  stdClass $marker\n     * @param  string $separator\n     * @return Capabilities Fluent interface\n     */\n    public function setNamespaceSeparator(stdClass $marker, $separator);\n}",
            "title": "Available Methods"
        },
        {
            "location": "/storage/capabilities/#examples",
            "text": "",
            "title": "Examples"
        },
        {
            "location": "/storage/capabilities/#get-storage-capabilities-and-do-specific-stuff-based-on-them",
            "text": "use Zend\\Cache\\StorageFactory;\n\n$cache = StorageFactory::adapterFactory('filesystem');\n$supportedDatatypes = $cache->getCapabilities()->getSupportedDatatypes();\n\n// now you can run specific stuff in base of supported feature\nif ($supportedDatatypes['object']) {\n    $cache->set($key, $object);\n} else {\n    $cache->set($key, serialize($object));\n}",
            "title": "Get storage capabilities and do specific stuff based on them"
        },
        {
            "location": "/storage/capabilities/#listen-to-the-change-event",
            "text": "use Zend\\Cache\\StorageFactory;\n\n$cache = StorageFactory::adapterFactory('filesystem', [\n    'no_atime' => false,\n]);\n\n// Catching capability changes\n$cache->getEventManager()->attach('capability', function($event) {\n    echo count($event->getParams()) . ' capabilities changed';\n});\n\n// change option which changes capabilities\n$cache->getOptions()->setNoATime(true);",
            "title": "Listen to the change event"
        },
        {
            "location": "/storage/plugin/",
            "text": "Storage Plugins\n\n\nCache storage plugins are objects that provide additional functionality to or\ninfluence behavior of a storage adapter.\n\n\nThe plugins listen to events the adapter triggers, and can:\n\n\n\n\nchange the arguments provided to the method triggering the event (via \n*.post\n events)\n\n\nskip and directly return a result (by calling \nstopPropagation\n)\n\n\nchange the result (by calling \nsetResult\n on the provided \nZend\\Cache\\Storage\\PostEvent\n)\n\n\ncatch exceptions (by reacting to \nZend\\Cache\\Storage\\ExceptionEvent\n)\n\n\n\n\nQuick Start\n\n\nStorage plugins can either be created from\n\nZend\\Cache\\StorageFactory::pluginFactory()\n, or by instantiating one of the\n\nZend\\Cache\\Storage\\Plugin\\*\n classes.\n\n\nTo make life easier, \nZend\\Cache\\StorageFactory::factory()\n can create both the\nrequested adapter and all specified plugins at once.\n\n\nuse Zend\\Cache\\StorageFactory;\n\n// All at once:\n$cache = StorageFactory::factory([\n    'adapter' => 'filesystem',\n    'plugins' => ['serializer'],\n]);\n\n// Alternately, via discrete factory methods:\n$cache  = StorageFactory::adapterFactory('filesystem');\n$plugin = StorageFactory::pluginFactory('serializer');\n$cache->addPlugin($plugin);\n\n// Or manually:\n$cache  = new Zend\\Cache\\Storage\\Adapter\\Filesystem();\n$plugin = new Zend\\Cache\\Storage\\Plugin\\Serializer();\n$cache->addPlugin($plugin);\n\n\n\nThe ClearExpiredByFactor Plugin\n\n\nZend\\Cache\\Storage\\Plugin\\ClearExpiredByFactor\n calls the storage method\n\nclearExpired()\n randomly (by factor) after every call of \nsetItem()\n,\n\nsetItems()\n, \naddItem()\n, and \naddItems()\n.\n\n\nPlugin specific options\n\n\n\n\n\n\n\n\nName\n\n\nData Type\n\n\nDefault Value\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nclearing_factor\n\n\ninteger\n\n\n0\n\n\nThe automatic clearing factor.\n\n\n\n\n\n\n\n\n\n\nAdapter must implement ClearExpiredInterface\n\n\nThe storage adapter must implement \nZend\\Cache\\Storage\\ClearExpiredInterface\n\nto work with this plugin.\n\n\n\n\nThe ExceptionHandler Plugin\n\n\nZend\\Cache\\Storage\\Plugin\\ExceptionHandler\n catches all exceptions thrown on\nreading from or writing to the cache, and sends the exception to a defined callback function.\nYou may also configure the plugin to re-throw exceptions.\n\n\nPlugin specific options\n\n\n\n\n\n\n\n\nName\n\n\nData Type\n\n\nDefault Value\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nexception_callback\n\n\ncallable|null\n\n\nnull\n\n\nCallback to invoke on exception; receives the exception as the sole argument.\n\n\n\n\n\n\nthrow_exceptions\n\n\nboolean\n\n\ntrue\n\n\nRe-throw caught exceptions.\n\n\n\n\n\n\n\n\nThe IgnoreUserAbort Plugin\n\n\nZend\\Cache\\Storage\\Plugin\\IgnoreUserAbort\n ignores user-invoked script\ntermination when, allowing cache write operations to complete first.\n\n\nPlugin specific options\n\n\n\n\n\n\n\n\nName\n\n\nData Type\n\n\nDefault Value\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nexit_on_abort\n\n\nboolean\n\n\ntrue\n\n\nTerminate script execution on user abort.\n\n\n\n\n\n\n\n\nThe OptimizeByFactor Plugin\n\n\nZend\\Cache\\Storage\\Plugin\\OptimizeByFactor\n calls the storage method \noptimize()\n\nrandomly (by factor) after removing items from the cache.\n\n\nPlugin specific options\n\n\n\n\n\n\n\n\nName\n\n\nData Type\n\n\nDefault Value\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\noptimizing_factor\n\n\ninteger\n\n\n0\n\n\nThe automatic optimization factor.\n\n\n\n\n\n\n\n\n\n\nAdapter must implement OptimizableInterface\n\n\nThe storage adapter must implement \nZend\\Cache\\Storage\\OptimizableInterface\n\nto work with this plugin.\n\n\n\n\nThe Serializer Plugin\n\n\nZend\\Cache\\Storage\\Plugin\\Serializer\n will serialize data when writing to\ncache, and deserialize when reading. This allows storing datatypes not supported\nby the underlying storage adapter.\n\n\nPlugin specific options\n\n\n\n\n\n\n\n\nName\n\n\nData Type\n\n\nDefault Value\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nserializer\n\n\nnull|string|Zend\\Serializer\\Adapter\\AdapterInterface\n\n\nnull\n\n\nThe serializer to use; see below.\n\n\n\n\n\n\nserializer_options\n\n\narray\n\n\n[]\n\n\nArray of options to use when instantiating the specified serializer.\n\n\n\n\n\n\n\n\nThe \nserializer\n value has two special cases:\n\n\n\n\nWhen \nnull\n, the default serializer is used (JSON).\n\n\nWhen a \nstring\n, the value will be pulled via\n  \nZend\\Serializer\\AdapterPluginManager\n, with the provided\n  \nserializer_options\n.\n\n\n\n\nAvailable Methods\n\n\nThe following methods are available to all \nZend\\Cache\\Storage\\Plugin\\PluginInterface\n implementations:\n\n\nnamespace Zend\\Cache\\Storage\\Plugin;\n\nuse Zend\\EventManager\\EventManagerInterface;\nuse Zend\\EventManager\\ListenerAggregateInterface;\n\ninterface PluginInterface extends ListenerAggregateInterface\n{\n    /**\n     * Set options\n     *\n     * @param  PluginOptions $options\n     * @return PluginInterface\n     */\n    public function setOptions(PluginOptions $options);\n\n    /**\n     * Get options\n     *\n     * @return PluginOptions\n     */\n    public function getOptions();\n\n    /**\n     * Attach listeners; inherited from ListenerAggregateInterface.\n     *\n     * @param EventManagerInterface $events\n     * @return void\n     */\n    public function attach(EventManagerInterface $events);\n\n    /**\n     * Detach listeners; inherited from ListenerAggregateInterface.\n     *\n     * @param EventManagerInterface $events\n     * @return void\n     */\n    public function attach(EventManagerInterface $events);\n}\n\n\n\nExamples\n\n\nBasic plugin implementation\n\n\nuse Zend\\Cache\\Storage\\Event;\nuse Zend\\Cache\\Storage\\Plugin\\AbstractPlugin;\nuse Zend\\EventManager\\EventManagerInterface;\n\nclass MyPlugin extends AbstractPlugin\n{\n    protected $handles = [];\n\n    /**\n     * Attach to all events this plugin is interested in.\n     */\n    public function attach(EventManagerInterface $events)\n    {\n        $this->handles[] = $events->attach('getItem.pre', array($this, 'onGetItemPre'));\n        $this->handles[] = $events->attach('getItem.post', array($this, 'onGetItemPost'));\n    }\n\n    /**\n     * Detach all handlers this plugin previously attached.\n     */\n    public function detach(EventManagerInterface $events)\n    {\n        foreach ($this->handles as $handle) {\n           $events->detach($handle);\n        }\n        $this->handles = [];\n    }\n\n    public function onGetItemPre(Event $event)\n    {\n        $params = $event->getParams();\n        echo sprintf(\"Method 'getItem' with key '%s' started\\n\", $params['key']);\n    }\n\n    public function onGetItemPost(Event $event)\n    {\n        $params = $event->getParams();\n        echo sprintf(\"Method 'getItem' with key '%s' finished\\n\", $params['key']);\n    }\n}\n\n// After defining this plugin, we can instantiate and add it to an adapter\n// instance:\n$plugin = new MyPlugin();\n$cache->addPlugin($plugin);\n\n// Now when calling getItem(), our plugin should print the expected output:\n$cache->getItem('cache-key');\n// Method 'getItem' with key 'cache-key' started\n// Method 'getItem' with key 'cache-key' finished",
            "title": "Plugins"
        },
        {
            "location": "/storage/plugin/#storage-plugins",
            "text": "Cache storage plugins are objects that provide additional functionality to or\ninfluence behavior of a storage adapter.  The plugins listen to events the adapter triggers, and can:   change the arguments provided to the method triggering the event (via  *.post  events)  skip and directly return a result (by calling  stopPropagation )  change the result (by calling  setResult  on the provided  Zend\\Cache\\Storage\\PostEvent )  catch exceptions (by reacting to  Zend\\Cache\\Storage\\ExceptionEvent )",
            "title": "Storage Plugins"
        },
        {
            "location": "/storage/plugin/#quick-start",
            "text": "Storage plugins can either be created from Zend\\Cache\\StorageFactory::pluginFactory() , or by instantiating one of the Zend\\Cache\\Storage\\Plugin\\*  classes.  To make life easier,  Zend\\Cache\\StorageFactory::factory()  can create both the\nrequested adapter and all specified plugins at once.  use Zend\\Cache\\StorageFactory;\n\n// All at once:\n$cache = StorageFactory::factory([\n    'adapter' => 'filesystem',\n    'plugins' => ['serializer'],\n]);\n\n// Alternately, via discrete factory methods:\n$cache  = StorageFactory::adapterFactory('filesystem');\n$plugin = StorageFactory::pluginFactory('serializer');\n$cache->addPlugin($plugin);\n\n// Or manually:\n$cache  = new Zend\\Cache\\Storage\\Adapter\\Filesystem();\n$plugin = new Zend\\Cache\\Storage\\Plugin\\Serializer();\n$cache->addPlugin($plugin);",
            "title": "Quick Start"
        },
        {
            "location": "/storage/plugin/#the-clearexpiredbyfactor-plugin",
            "text": "Zend\\Cache\\Storage\\Plugin\\ClearExpiredByFactor  calls the storage method clearExpired()  randomly (by factor) after every call of  setItem() , setItems() ,  addItem() , and  addItems() .",
            "title": "The ClearExpiredByFactor Plugin"
        },
        {
            "location": "/storage/plugin/#plugin-specific-options",
            "text": "Name  Data Type  Default Value  Description      clearing_factor  integer  0  The automatic clearing factor.",
            "title": "Plugin specific options"
        },
        {
            "location": "/storage/plugin/#adapter-must-implement-clearexpiredinterface",
            "text": "The storage adapter must implement  Zend\\Cache\\Storage\\ClearExpiredInterface \nto work with this plugin.",
            "title": "Adapter must implement ClearExpiredInterface"
        },
        {
            "location": "/storage/plugin/#the-exceptionhandler-plugin",
            "text": "Zend\\Cache\\Storage\\Plugin\\ExceptionHandler  catches all exceptions thrown on\nreading from or writing to the cache, and sends the exception to a defined callback function.\nYou may also configure the plugin to re-throw exceptions.",
            "title": "The ExceptionHandler Plugin"
        },
        {
            "location": "/storage/plugin/#plugin-specific-options_1",
            "text": "Name  Data Type  Default Value  Description      exception_callback  callable|null  null  Callback to invoke on exception; receives the exception as the sole argument.    throw_exceptions  boolean  true  Re-throw caught exceptions.",
            "title": "Plugin specific options"
        },
        {
            "location": "/storage/plugin/#the-ignoreuserabort-plugin",
            "text": "Zend\\Cache\\Storage\\Plugin\\IgnoreUserAbort  ignores user-invoked script\ntermination when, allowing cache write operations to complete first.",
            "title": "The IgnoreUserAbort Plugin"
        },
        {
            "location": "/storage/plugin/#plugin-specific-options_2",
            "text": "Name  Data Type  Default Value  Description      exit_on_abort  boolean  true  Terminate script execution on user abort.",
            "title": "Plugin specific options"
        },
        {
            "location": "/storage/plugin/#the-optimizebyfactor-plugin",
            "text": "Zend\\Cache\\Storage\\Plugin\\OptimizeByFactor  calls the storage method  optimize() \nrandomly (by factor) after removing items from the cache.",
            "title": "The OptimizeByFactor Plugin"
        },
        {
            "location": "/storage/plugin/#plugin-specific-options_3",
            "text": "Name  Data Type  Default Value  Description      optimizing_factor  integer  0  The automatic optimization factor.",
            "title": "Plugin specific options"
        },
        {
            "location": "/storage/plugin/#adapter-must-implement-optimizableinterface",
            "text": "The storage adapter must implement  Zend\\Cache\\Storage\\OptimizableInterface \nto work with this plugin.",
            "title": "Adapter must implement OptimizableInterface"
        },
        {
            "location": "/storage/plugin/#the-serializer-plugin",
            "text": "Zend\\Cache\\Storage\\Plugin\\Serializer  will serialize data when writing to\ncache, and deserialize when reading. This allows storing datatypes not supported\nby the underlying storage adapter.",
            "title": "The Serializer Plugin"
        },
        {
            "location": "/storage/plugin/#plugin-specific-options_4",
            "text": "Name  Data Type  Default Value  Description      serializer  null|string|Zend\\Serializer\\Adapter\\AdapterInterface  null  The serializer to use; see below.    serializer_options  array  []  Array of options to use when instantiating the specified serializer.     The  serializer  value has two special cases:   When  null , the default serializer is used (JSON).  When a  string , the value will be pulled via\n   Zend\\Serializer\\AdapterPluginManager , with the provided\n   serializer_options .",
            "title": "Plugin specific options"
        },
        {
            "location": "/storage/plugin/#available-methods",
            "text": "The following methods are available to all  Zend\\Cache\\Storage\\Plugin\\PluginInterface  implementations:  namespace Zend\\Cache\\Storage\\Plugin;\n\nuse Zend\\EventManager\\EventManagerInterface;\nuse Zend\\EventManager\\ListenerAggregateInterface;\n\ninterface PluginInterface extends ListenerAggregateInterface\n{\n    /**\n     * Set options\n     *\n     * @param  PluginOptions $options\n     * @return PluginInterface\n     */\n    public function setOptions(PluginOptions $options);\n\n    /**\n     * Get options\n     *\n     * @return PluginOptions\n     */\n    public function getOptions();\n\n    /**\n     * Attach listeners; inherited from ListenerAggregateInterface.\n     *\n     * @param EventManagerInterface $events\n     * @return void\n     */\n    public function attach(EventManagerInterface $events);\n\n    /**\n     * Detach listeners; inherited from ListenerAggregateInterface.\n     *\n     * @param EventManagerInterface $events\n     * @return void\n     */\n    public function attach(EventManagerInterface $events);\n}",
            "title": "Available Methods"
        },
        {
            "location": "/storage/plugin/#examples",
            "text": "",
            "title": "Examples"
        },
        {
            "location": "/storage/plugin/#basic-plugin-implementation",
            "text": "use Zend\\Cache\\Storage\\Event;\nuse Zend\\Cache\\Storage\\Plugin\\AbstractPlugin;\nuse Zend\\EventManager\\EventManagerInterface;\n\nclass MyPlugin extends AbstractPlugin\n{\n    protected $handles = [];\n\n    /**\n     * Attach to all events this plugin is interested in.\n     */\n    public function attach(EventManagerInterface $events)\n    {\n        $this->handles[] = $events->attach('getItem.pre', array($this, 'onGetItemPre'));\n        $this->handles[] = $events->attach('getItem.post', array($this, 'onGetItemPost'));\n    }\n\n    /**\n     * Detach all handlers this plugin previously attached.\n     */\n    public function detach(EventManagerInterface $events)\n    {\n        foreach ($this->handles as $handle) {\n           $events->detach($handle);\n        }\n        $this->handles = [];\n    }\n\n    public function onGetItemPre(Event $event)\n    {\n        $params = $event->getParams();\n        echo sprintf(\"Method 'getItem' with key '%s' started\\n\", $params['key']);\n    }\n\n    public function onGetItemPost(Event $event)\n    {\n        $params = $event->getParams();\n        echo sprintf(\"Method 'getItem' with key '%s' finished\\n\", $params['key']);\n    }\n}\n\n// After defining this plugin, we can instantiate and add it to an adapter\n// instance:\n$plugin = new MyPlugin();\n$cache->addPlugin($plugin);\n\n// Now when calling getItem(), our plugin should print the expected output:\n$cache->getItem('cache-key');\n// Method 'getItem' with key 'cache-key' started\n// Method 'getItem' with key 'cache-key' finished",
            "title": "Basic plugin implementation"
        },
        {
            "location": "/pattern/intro/",
            "text": "Zend\\Cache\\Pattern\n\n\nCache patterns are configurable objects that solve known performance\nbottlenecks. Each should be used only in the specific situations they are\ndesigned to address. For example, you can use the \nCallbackCache\n,\n\nObjectCache\n, or \nClassCache\n patterns to cache method and function calls; to\ncache output generation, the \nOutputCache\n pattern could assist.\n\n\nAll cache patterns implement \nZend\\Cache\\Pattern\\PatternInterface\n, and most\nextend the abstract class \nZend\\Cache\\Pattern\\AbstractPattern\n, which provides\ncommon logic.\n\n\nConfiguration is provided via the \nZend\\Cache\\Pattern\\PatternOptions\n class,\nwhich can be instantiated with an associative array of options passed to the\nconstructor. To configure a pattern object, you can provide a\n\nZend\\Cache\\Pattern\\PatternOptions\n instance to the \nsetOptions()\n method, or\nprovide your options (either as an associative array or \nPatternOptions\n\ninstance) to the second argument of the factory.\n\n\nIt's also possible to use a single instance of\n\nZend\\Cache\\Pattern\\PatternOptions\n and pass it to multiple pattern objects.\n\n\nQuick Start\n\n\nPattern objects can either be created from the provided \nZend\\Cache\\PatternFactory\n, or\nby instantiating one of the \nZend\\Cache\\Pattern\\*Cache\n classes.\n\n\n// Via the factory:\n$callbackCache = Zend\\Cache\\PatternFactory::factory('callback', [\n    'storage' => 'apc',\n]);\n\n// Or the equivalent manual instantiation:\n$callbackCache = new Zend\\Cache\\Pattern\\CallbackCache();\n$callbackCache->setOptions(new Zend\\Cache\\Pattern\\PatternOptions([\n    'storage' => 'apc',\n]));\n\n\n\nAvailable Methods\n\n\nThe following methods are implemented by \nZend\\Cache\\Pattern\\AbstractPattern\n.\nPlease read documentation of specific patterns to get more information.\n\n\nnamespace Zend\\Cache\\Pattern;\n\ninterface PatternInterface\n{\n    /**\n     * Set pattern options\n     *\n     * @param  PatternOptions $options\n     * @return PatternInterface\n     */\n    public function setOptions(PatternOptions $options);\n\n    /**\n     * Get all pattern options\n     *\n     * @return PatternOptions\n     */\n    public function getOptions();\n}",
            "title": "Introduction"
        },
        {
            "location": "/pattern/intro/#zend92cache92pattern",
            "text": "Cache patterns are configurable objects that solve known performance\nbottlenecks. Each should be used only in the specific situations they are\ndesigned to address. For example, you can use the  CallbackCache , ObjectCache , or  ClassCache  patterns to cache method and function calls; to\ncache output generation, the  OutputCache  pattern could assist.  All cache patterns implement  Zend\\Cache\\Pattern\\PatternInterface , and most\nextend the abstract class  Zend\\Cache\\Pattern\\AbstractPattern , which provides\ncommon logic.  Configuration is provided via the  Zend\\Cache\\Pattern\\PatternOptions  class,\nwhich can be instantiated with an associative array of options passed to the\nconstructor. To configure a pattern object, you can provide a Zend\\Cache\\Pattern\\PatternOptions  instance to the  setOptions()  method, or\nprovide your options (either as an associative array or  PatternOptions \ninstance) to the second argument of the factory.  It's also possible to use a single instance of Zend\\Cache\\Pattern\\PatternOptions  and pass it to multiple pattern objects.",
            "title": "Zend\\Cache\\Pattern"
        },
        {
            "location": "/pattern/intro/#quick-start",
            "text": "Pattern objects can either be created from the provided  Zend\\Cache\\PatternFactory , or\nby instantiating one of the  Zend\\Cache\\Pattern\\*Cache  classes.  // Via the factory:\n$callbackCache = Zend\\Cache\\PatternFactory::factory('callback', [\n    'storage' => 'apc',\n]);\n\n// Or the equivalent manual instantiation:\n$callbackCache = new Zend\\Cache\\Pattern\\CallbackCache();\n$callbackCache->setOptions(new Zend\\Cache\\Pattern\\PatternOptions([\n    'storage' => 'apc',\n]));",
            "title": "Quick Start"
        },
        {
            "location": "/pattern/intro/#available-methods",
            "text": "The following methods are implemented by  Zend\\Cache\\Pattern\\AbstractPattern .\nPlease read documentation of specific patterns to get more information.  namespace Zend\\Cache\\Pattern;\n\ninterface PatternInterface\n{\n    /**\n     * Set pattern options\n     *\n     * @param  PatternOptions $options\n     * @return PatternInterface\n     */\n    public function setOptions(PatternOptions $options);\n\n    /**\n     * Get all pattern options\n     *\n     * @return PatternOptions\n     */\n    public function getOptions();\n}",
            "title": "Available Methods"
        },
        {
            "location": "/pattern/callback-cache/",
            "text": "CallbackCache\n\n\nThe callback cache pattern caches the results of arbitrary PHP callables.\n\n\nQuick Start\n\n\nuse Zend\\Cache\\PatternFactory;\nuse Zend\\Cache\\Pattern\\PatternOptions;\n\n// Via the factory:\n$callbackCache = PatternFactory::factory('callback', [\n    'storage'      => 'apc',\n    'cache_output' => true,\n]);\n\n// Or the equivalent manual instantiation:\n$callbackCache = new \\Zend\\Cache\\Pattern\\CallbackCache();\n$callbackCache->setOptions(new PatternOptions([\n    'storage'      => 'apc',\n    'cache_output' => true,\n]));\n\n\n\nConfiguration Options\n\n\n\n\n\n\n\n\nOption\n\n\nData Type\n\n\nDefault Value\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nstorage\n\n\nstring | array | Zend\\Cache\\Storage\\StorageInterface\n\n\nnone\n\n\nAdapter used for reading and writing cached data.\n\n\n\n\n\n\ncache_output\n\n\nboolean\n\n\ntrue\n\n\nWhether or not to cache callback output.\n\n\n\n\n\n\n\n\nAvailable Methods\n\n\nIn addition to the methods defined in the \nPatternInterface\n, this\nimplementation provides the following methods.\n\n\nnamespace Zend\\Cache\\Pattern;\n\nuse Zend\\Cache\\Exception;\nuse Zend\\Stdlib\\ErrorHandler;\n\nclass CallbackCache extends AbstractPattern\n{\n    /**\n     * Call the specified callback or get the result from cache\n     *\n     * @param  callable   $callback  A valid callback\n     * @param  array      $args      Callback arguments\n     * @return mixed Result\n     * @throws Exception\\RuntimeException if invalid cached data\n     * @throws \\Exception\n     */\n    public function call($callback, array $args = []);\n\n    /**\n     * Intercept method overloading; proxies to call()\n     *\n     * @param  string $function  Function name to call\n     * @param  array  $args      Function arguments\n     * @return mixed\n     * @throws Exception\\RuntimeException\n     * @throws \\Exception\n     */\n    public function __call($function, array $args);\n\n    /**\n     * Generate a unique key in base of a key representing the callback part\n     * and a key representing the arguments part.\n     *\n     * @param  callable   $callback  A valid callback\n     * @param  array      $args      Callback arguments\n     * @return string\n     * @throws Exception\\RuntimeException\n     * @throws Exception\\InvalidArgumentException\n     */\n    public function generateKey($callback, array $args = []);\n}\n\n\n\nExamples\n\n\nInstantiating the callback cache pattern\n\n\nuse Zend\\Cache\\PatternFactory;\n\n$callbackCache = PatternFactory::factory('callback', [\n    'storage' => 'apc'\n]);",
            "title": "CallbackCache"
        },
        {
            "location": "/pattern/callback-cache/#callbackcache",
            "text": "The callback cache pattern caches the results of arbitrary PHP callables.",
            "title": "CallbackCache"
        },
        {
            "location": "/pattern/callback-cache/#quick-start",
            "text": "use Zend\\Cache\\PatternFactory;\nuse Zend\\Cache\\Pattern\\PatternOptions;\n\n// Via the factory:\n$callbackCache = PatternFactory::factory('callback', [\n    'storage'      => 'apc',\n    'cache_output' => true,\n]);\n\n// Or the equivalent manual instantiation:\n$callbackCache = new \\Zend\\Cache\\Pattern\\CallbackCache();\n$callbackCache->setOptions(new PatternOptions([\n    'storage'      => 'apc',\n    'cache_output' => true,\n]));",
            "title": "Quick Start"
        },
        {
            "location": "/pattern/callback-cache/#configuration-options",
            "text": "Option  Data Type  Default Value  Description      storage  string | array | Zend\\Cache\\Storage\\StorageInterface  none  Adapter used for reading and writing cached data.    cache_output  boolean  true  Whether or not to cache callback output.",
            "title": "Configuration Options"
        },
        {
            "location": "/pattern/callback-cache/#available-methods",
            "text": "In addition to the methods defined in the  PatternInterface , this\nimplementation provides the following methods.  namespace Zend\\Cache\\Pattern;\n\nuse Zend\\Cache\\Exception;\nuse Zend\\Stdlib\\ErrorHandler;\n\nclass CallbackCache extends AbstractPattern\n{\n    /**\n     * Call the specified callback or get the result from cache\n     *\n     * @param  callable   $callback  A valid callback\n     * @param  array      $args      Callback arguments\n     * @return mixed Result\n     * @throws Exception\\RuntimeException if invalid cached data\n     * @throws \\Exception\n     */\n    public function call($callback, array $args = []);\n\n    /**\n     * Intercept method overloading; proxies to call()\n     *\n     * @param  string $function  Function name to call\n     * @param  array  $args      Function arguments\n     * @return mixed\n     * @throws Exception\\RuntimeException\n     * @throws \\Exception\n     */\n    public function __call($function, array $args);\n\n    /**\n     * Generate a unique key in base of a key representing the callback part\n     * and a key representing the arguments part.\n     *\n     * @param  callable   $callback  A valid callback\n     * @param  array      $args      Callback arguments\n     * @return string\n     * @throws Exception\\RuntimeException\n     * @throws Exception\\InvalidArgumentException\n     */\n    public function generateKey($callback, array $args = []);\n}",
            "title": "Available Methods"
        },
        {
            "location": "/pattern/callback-cache/#examples",
            "text": "",
            "title": "Examples"
        },
        {
            "location": "/pattern/callback-cache/#instantiating-the-callback-cache-pattern",
            "text": "use Zend\\Cache\\PatternFactory;\n\n$callbackCache = PatternFactory::factory('callback', [\n    'storage' => 'apc'\n]);",
            "title": "Instantiating the callback cache pattern"
        },
        {
            "location": "/pattern/class-cache/",
            "text": "ClassCache\n\n\nThe \nClassCache\n pattern is an extension to the\n\nCallbackCache\n pattern. It has the same methods, but\ninstead generates the callbacks for any public static method invoked on the\nclass being cached, and caches static properties.\n\n\nQuick Start\n\n\nuse Zend\\Cache\\PatternFactory;\n\n$classCache = PatternFactory::factory('class', [\n    'class'   => 'MyClass',\n    'storage' => 'apc',\n]);\n\n\n\nConfiguration Options\n\n\n\n\n\n\n\n\nOption\n\n\nData Type\n\n\nDefault Value\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nstorage\n\n\nstring | array | Zend\\Cache\\Storage\\StorageInterface\n\n\nnone\n\n\nAdapter used for reading and writing cached data.\n\n\n\n\n\n\nclass\n\n\nstring\n\n\nnone\n\n\nName of the class for which to cache method output.\n\n\n\n\n\n\ncache_output\n\n\nboolean\n\n\ntrue\n\n\nWhether or not to cache method output.\n\n\n\n\n\n\ncache_by_default\n\n\nboolean\n\n\ntrue\n\n\nCache all method calls by default.\n\n\n\n\n\n\nclass_cache_methods\n\n\narray\n\n\n[]\n\n\nList of methods to cache (if \ncache_by_default\n is disabled).\n\n\n\n\n\n\nclass_non_cache_methods\n\n\narray\n\n\n[]\n\n\nList of methods to omit from caching (if \ncache_by_default\n is enabled).\n\n\n\n\n\n\n\n\nAvailable Methods\n\n\nIn addition to the methods defined in \nPatternInterface\n, this implementation\nexposes the following methods.\n\n\nnamespace Zend\\Cache\\Pattern;\n\nuse Zend\\Cache;\nuse Zend\\Cache\\Exception;\n\nclass ClassCache extends CallbackCache\n{\n    /**\n     * Call and cache a class method\n     *\n     * @param  string $method  Method name to call\n     * @param  array  $args    Method arguments\n     * @return mixed\n     * @throws Exception\\RuntimeException\n     * @throws \\Exception\n     */\n    public function call($method, array $args = []);\n\n    /**\n     * Intercept method overloading; proxies to call().\n     *\n     * @param  string $method  Method name to call\n     * @param  array  $args    Method arguments\n     * @return mixed\n     * @throws Exception\\RuntimeException\n     * @throws \\Exception\n     */\n    public function __call($method, array $args)\n    {\n        return $this->call($method, $args);\n    }\n\n    /**\n     * Generate a unique key in base of a key representing the callback part\n     * and a key representing the arguments part.\n     *\n     * @param  string     $method  The method\n     * @param  array      $args    Callback arguments\n     * @return string\n     * @throws Exception\\RuntimeException\n     */\n    public function generateKey($method, array $args = []);\n\n    /**\n     * Property overloading: set a static property.\n     *\n     * @param  string $name\n     * @param  mixed  $value\n     * @return void\n     * @see   http://php.net/manual/language.oop5.overloading.php#language.oop5.overloading.members\n     */\n    public function __set($name, $value)\n    {\n        $class = $this->getOptions()->getClass();\n        $class::$name = $value;\n    }\n\n    /**\n     * Property overloading: get a static property.\n     *\n     * @param  string $name\n     * @return mixed\n     * @see    http://php.net/manual/language.oop5.overloading.php#language.oop5.overloading.members\n     */\n    public function __get($name)\n    {\n        $class = $this->getOptions()->getClass();\n        return $class::$name;\n    }\n\n    /**\n     * Property overloading: does the named static property exist?\n     *\n     * @param  string $name\n     * @return bool\n     */\n    public function __isset($name)\n    {\n        $class = $this->getOptions()->getClass();\n        return isset($class::$name);\n    }\n\n    /**\n     * Property overloading: unset a static property.\n     *\n     * @param  string $name\n     * @return void\n     */\n    public function __unset($name)\n    {\n        $class = $this->getOptions()->getClass();\n        unset($class::$name);\n    }\n}\n\n\n\nExamples\n\n\nCaching of import feeds\n\n\n$cachedFeedReader = Zend\\Cache\\PatternFactory::factory('class', [\n    'class'   => 'Zend\\Feed\\Reader\\Reader',\n    'storage' => 'apc',\n\n    // The feed reader doesn't output anything,\n    // so the output doesn't need to be caught and cached:\n    'cache_output' => false,\n]);\n\n$feed = $cachedFeedReader->call(\"import\", array('http://www.planet-php.net/rdf/'));\n\n// OR\n$feed = $cachedFeedReader->import('http://www.planet-php.net/rdf/');",
            "title": "ClassCache"
        },
        {
            "location": "/pattern/class-cache/#classcache",
            "text": "The  ClassCache  pattern is an extension to the CallbackCache  pattern. It has the same methods, but\ninstead generates the callbacks for any public static method invoked on the\nclass being cached, and caches static properties.",
            "title": "ClassCache"
        },
        {
            "location": "/pattern/class-cache/#quick-start",
            "text": "use Zend\\Cache\\PatternFactory;\n\n$classCache = PatternFactory::factory('class', [\n    'class'   => 'MyClass',\n    'storage' => 'apc',\n]);",
            "title": "Quick Start"
        },
        {
            "location": "/pattern/class-cache/#configuration-options",
            "text": "Option  Data Type  Default Value  Description      storage  string | array | Zend\\Cache\\Storage\\StorageInterface  none  Adapter used for reading and writing cached data.    class  string  none  Name of the class for which to cache method output.    cache_output  boolean  true  Whether or not to cache method output.    cache_by_default  boolean  true  Cache all method calls by default.    class_cache_methods  array  []  List of methods to cache (if  cache_by_default  is disabled).    class_non_cache_methods  array  []  List of methods to omit from caching (if  cache_by_default  is enabled).",
            "title": "Configuration Options"
        },
        {
            "location": "/pattern/class-cache/#available-methods",
            "text": "In addition to the methods defined in  PatternInterface , this implementation\nexposes the following methods.  namespace Zend\\Cache\\Pattern;\n\nuse Zend\\Cache;\nuse Zend\\Cache\\Exception;\n\nclass ClassCache extends CallbackCache\n{\n    /**\n     * Call and cache a class method\n     *\n     * @param  string $method  Method name to call\n     * @param  array  $args    Method arguments\n     * @return mixed\n     * @throws Exception\\RuntimeException\n     * @throws \\Exception\n     */\n    public function call($method, array $args = []);\n\n    /**\n     * Intercept method overloading; proxies to call().\n     *\n     * @param  string $method  Method name to call\n     * @param  array  $args    Method arguments\n     * @return mixed\n     * @throws Exception\\RuntimeException\n     * @throws \\Exception\n     */\n    public function __call($method, array $args)\n    {\n        return $this->call($method, $args);\n    }\n\n    /**\n     * Generate a unique key in base of a key representing the callback part\n     * and a key representing the arguments part.\n     *\n     * @param  string     $method  The method\n     * @param  array      $args    Callback arguments\n     * @return string\n     * @throws Exception\\RuntimeException\n     */\n    public function generateKey($method, array $args = []);\n\n    /**\n     * Property overloading: set a static property.\n     *\n     * @param  string $name\n     * @param  mixed  $value\n     * @return void\n     * @see   http://php.net/manual/language.oop5.overloading.php#language.oop5.overloading.members\n     */\n    public function __set($name, $value)\n    {\n        $class = $this->getOptions()->getClass();\n        $class::$name = $value;\n    }\n\n    /**\n     * Property overloading: get a static property.\n     *\n     * @param  string $name\n     * @return mixed\n     * @see    http://php.net/manual/language.oop5.overloading.php#language.oop5.overloading.members\n     */\n    public function __get($name)\n    {\n        $class = $this->getOptions()->getClass();\n        return $class::$name;\n    }\n\n    /**\n     * Property overloading: does the named static property exist?\n     *\n     * @param  string $name\n     * @return bool\n     */\n    public function __isset($name)\n    {\n        $class = $this->getOptions()->getClass();\n        return isset($class::$name);\n    }\n\n    /**\n     * Property overloading: unset a static property.\n     *\n     * @param  string $name\n     * @return void\n     */\n    public function __unset($name)\n    {\n        $class = $this->getOptions()->getClass();\n        unset($class::$name);\n    }\n}",
            "title": "Available Methods"
        },
        {
            "location": "/pattern/class-cache/#examples",
            "text": "Caching of import feeds  $cachedFeedReader = Zend\\Cache\\PatternFactory::factory('class', [\n    'class'   => 'Zend\\Feed\\Reader\\Reader',\n    'storage' => 'apc',\n\n    // The feed reader doesn't output anything,\n    // so the output doesn't need to be caught and cached:\n    'cache_output' => false,\n]);\n\n$feed = $cachedFeedReader->call(\"import\", array('http://www.planet-php.net/rdf/'));\n\n// OR\n$feed = $cachedFeedReader->import('http://www.planet-php.net/rdf/');",
            "title": "Examples"
        },
        {
            "location": "/pattern/object-cache/",
            "text": "ObjectCache\n\n\nThe \nObjectCache\n pattern is an extension to the \nCallbackCache\n pattern. It has\nthe same methods, but instead caches output from any instance method calls or\npublic properties.\n\n\nQuick Start\n\n\nuse stdClass;\nuse Zend\\Cache\\PatternFactory;\n\n$object      = new stdClass();\n$objectCache = PatternFactory::factory('object', [\n    'object'  => $object,\n    'storage' => 'apc'\n]);\n\n\n\nConfiguration Options\n\n\n\n\n\n\n\n\nOption\n\n\nData Type\n\n\nDefault Value\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nstorage\n\n\nstring | array | Zend\\Cache\\Storage\\StorageInterface\n\n\nnone\n\n\nAdapter used for reading and writing cached data.\n\n\n\n\n\n\nobject\n\n\nobject\n\n\nnone\n\n\nThe object for which to cache method calls.\n\n\n\n\n\n\nobject_key\n\n\nnull | string\n\n\nClass name of object\n\n\nHopefully unique!\n\n\n\n\n\n\ncache_output\n\n\nboolean\n\n\ntrue\n\n\nWhether or not to cache method output.\n\n\n\n\n\n\ncache_by_default\n\n\nboolean\n\n\ntrue\n\n\nCache all method calls by default.\n\n\n\n\n\n\nobject_cache_methods\n\n\narray\n\n\n[]\n\n\nList of methods to cache (if \ncache_by_default\n is disabled).\n\n\n\n\n\n\nobject_non_cache_methods\n\n\narray\n\n\n[]\n\n\nList of methods to blacklist (if \ncache_by_default\n is enabled).\n\n\n\n\n\n\nobject_cache_magic_properties\n\n\nboolean\n\n\nfalse\n\n\nWhether or not to cache properties exposed by method overloading.\n\n\n\n\n\n\n\n\nAvailable Methods\n\n\nIn addition to the methods defined in \nPatternInterface\n, this implementation\ndefines the following methods.\n\n\nnamespace Zend\\Cache\\Pattern;\n\nuse Zend\\Cache\\Exception;\n\nclass ObjectCache extends CallbackCache\n{\n    /**\n     * Call and cache a class method\n     *\n     * @param  string $method  Method name to call\n     * @param  array  $args    Method arguments\n     * @return mixed\n     * @throws Exception\\RuntimeException\n     * @throws \\Exception\n     */\n    public function call($method, array $args = []);\n\n    /**\n     * Method overloading: proxies to call().\n     *\n     * @param  string $method  Method name to call\n     * @param  array  $args    Method arguments\n     * @return mixed\n     * @throws Exception\\RuntimeException\n     * @throws \\Exception\n     */\n    public function __call($method, array $args);\n\n    /**\n     * Generate a unique key in base of a key representing the callback part\n     * and a key representing the arguments part.\n     *\n     * @param  string     $method  The method\n     * @param  array      $args    Callback arguments\n     * @return string\n     * @throws Exception\\RuntimeException\n     */\n    public function generateKey($method, array $args = []);\n\n    /**\n     * Property overloading: write data to a named property.\n     *\n     * NOTE:\n     * Magic properties will be cached too if the option cacheMagicProperties\n     * is enabled and the property doesn't exist in real. If so it calls __set\n     * and removes cached data of previous __get and __isset calls.\n     *\n     * @param  string $name\n     * @param  mixed  $value\n     * @return void\n     * @see    http://php.net/manual/language.oop5.overloading.php#language.oop5.overloading.members\n     */\n    public function __set($name, $value);\n\n    /**\n     * Property overloading: read data from a named property.\n     *\n     * NOTE:\n     * Magic properties will be cached too if the option cacheMagicProperties\n     * is enabled and the property doesn't exist in real. If so it calls __get.\n     *\n     * @param  string $name\n     * @return mixed\n     * @see http://php.net/manual/language.oop5.overloading.php#language.oop5.overloading.members\n     */\n    public function __get($name);\n\n    /**\n     * Property overloading: check if a named property exists.\n     *\n     * NOTE:\n     * Magic properties will be cached too if the option cacheMagicProperties\n     * is enabled and the property doesn't exist in real. If so it calls __get.\n     *\n     * @param  string $name\n     * @return bool\n     * @see    http://php.net/manual/language.oop5.overloading.php#language.oop5.overloading.members\n     */\n    public function __isset($name);\n\n    /**\n     * Property overloading: unset a named property.\n     *\n     * NOTE:\n     * Magic properties will be cached too if the option cacheMagicProperties\n     * is enabled and the property doesn't exist in real. If so it removes\n     * previous cached __isset and __get calls.\n     *\n     * @param  string $name\n     * @return void\n     * @see    http://php.net/manual/language.oop5.overloading.php#language.oop5.overloading.members\n     */\n    public function __unset($name);\n\n    /**\n     * Handle casting to string\n     *\n     * @return string\n     * @see    http://php.net/manual/language.oop5.magic.php#language.oop5.magic.tostring\n     */\n    public function __toString();\n\n    /**\n     * Intercept and cache invokable usage.\n     *\n     * @return mixed\n     * @see    http://php.net/manual/language.oop5.magic.php#language.oop5.magic.invoke\n     */\n    public function __invoke();\n}\n\n\n\nExamples\n\n\nCaching a filter\n\n\n$filter       = new Zend\\Filter\\RealPath();\n$cachedFilter = Zend\\Cache\\PatternFactory::factory('object', [\n    'object'     => $filter,\n    'object_key' => 'RealpathFilter',\n    'storage'    => 'apc',\n\n    // The realpath filter doesn't output anything\n    // so the output don't need to be caught and cached\n    'cache_output' => false,\n]);\n\n$path = $cachedFilter->call(\"filter\", ['/www/var/path/../../mypath']);\n\n// OR\n$path = $cachedFilter->filter('/www/var/path/../../mypath');",
            "title": "ObjectCache"
        },
        {
            "location": "/pattern/object-cache/#objectcache",
            "text": "The  ObjectCache  pattern is an extension to the  CallbackCache  pattern. It has\nthe same methods, but instead caches output from any instance method calls or\npublic properties.",
            "title": "ObjectCache"
        },
        {
            "location": "/pattern/object-cache/#quick-start",
            "text": "use stdClass;\nuse Zend\\Cache\\PatternFactory;\n\n$object      = new stdClass();\n$objectCache = PatternFactory::factory('object', [\n    'object'  => $object,\n    'storage' => 'apc'\n]);",
            "title": "Quick Start"
        },
        {
            "location": "/pattern/object-cache/#configuration-options",
            "text": "Option  Data Type  Default Value  Description      storage  string | array | Zend\\Cache\\Storage\\StorageInterface  none  Adapter used for reading and writing cached data.    object  object  none  The object for which to cache method calls.    object_key  null | string  Class name of object  Hopefully unique!    cache_output  boolean  true  Whether or not to cache method output.    cache_by_default  boolean  true  Cache all method calls by default.    object_cache_methods  array  []  List of methods to cache (if  cache_by_default  is disabled).    object_non_cache_methods  array  []  List of methods to blacklist (if  cache_by_default  is enabled).    object_cache_magic_properties  boolean  false  Whether or not to cache properties exposed by method overloading.",
            "title": "Configuration Options"
        },
        {
            "location": "/pattern/object-cache/#available-methods",
            "text": "In addition to the methods defined in  PatternInterface , this implementation\ndefines the following methods.  namespace Zend\\Cache\\Pattern;\n\nuse Zend\\Cache\\Exception;\n\nclass ObjectCache extends CallbackCache\n{\n    /**\n     * Call and cache a class method\n     *\n     * @param  string $method  Method name to call\n     * @param  array  $args    Method arguments\n     * @return mixed\n     * @throws Exception\\RuntimeException\n     * @throws \\Exception\n     */\n    public function call($method, array $args = []);\n\n    /**\n     * Method overloading: proxies to call().\n     *\n     * @param  string $method  Method name to call\n     * @param  array  $args    Method arguments\n     * @return mixed\n     * @throws Exception\\RuntimeException\n     * @throws \\Exception\n     */\n    public function __call($method, array $args);\n\n    /**\n     * Generate a unique key in base of a key representing the callback part\n     * and a key representing the arguments part.\n     *\n     * @param  string     $method  The method\n     * @param  array      $args    Callback arguments\n     * @return string\n     * @throws Exception\\RuntimeException\n     */\n    public function generateKey($method, array $args = []);\n\n    /**\n     * Property overloading: write data to a named property.\n     *\n     * NOTE:\n     * Magic properties will be cached too if the option cacheMagicProperties\n     * is enabled and the property doesn't exist in real. If so it calls __set\n     * and removes cached data of previous __get and __isset calls.\n     *\n     * @param  string $name\n     * @param  mixed  $value\n     * @return void\n     * @see    http://php.net/manual/language.oop5.overloading.php#language.oop5.overloading.members\n     */\n    public function __set($name, $value);\n\n    /**\n     * Property overloading: read data from a named property.\n     *\n     * NOTE:\n     * Magic properties will be cached too if the option cacheMagicProperties\n     * is enabled and the property doesn't exist in real. If so it calls __get.\n     *\n     * @param  string $name\n     * @return mixed\n     * @see http://php.net/manual/language.oop5.overloading.php#language.oop5.overloading.members\n     */\n    public function __get($name);\n\n    /**\n     * Property overloading: check if a named property exists.\n     *\n     * NOTE:\n     * Magic properties will be cached too if the option cacheMagicProperties\n     * is enabled and the property doesn't exist in real. If so it calls __get.\n     *\n     * @param  string $name\n     * @return bool\n     * @see    http://php.net/manual/language.oop5.overloading.php#language.oop5.overloading.members\n     */\n    public function __isset($name);\n\n    /**\n     * Property overloading: unset a named property.\n     *\n     * NOTE:\n     * Magic properties will be cached too if the option cacheMagicProperties\n     * is enabled and the property doesn't exist in real. If so it removes\n     * previous cached __isset and __get calls.\n     *\n     * @param  string $name\n     * @return void\n     * @see    http://php.net/manual/language.oop5.overloading.php#language.oop5.overloading.members\n     */\n    public function __unset($name);\n\n    /**\n     * Handle casting to string\n     *\n     * @return string\n     * @see    http://php.net/manual/language.oop5.magic.php#language.oop5.magic.tostring\n     */\n    public function __toString();\n\n    /**\n     * Intercept and cache invokable usage.\n     *\n     * @return mixed\n     * @see    http://php.net/manual/language.oop5.magic.php#language.oop5.magic.invoke\n     */\n    public function __invoke();\n}",
            "title": "Available Methods"
        },
        {
            "location": "/pattern/object-cache/#examples",
            "text": "",
            "title": "Examples"
        },
        {
            "location": "/pattern/object-cache/#caching-a-filter",
            "text": "$filter       = new Zend\\Filter\\RealPath();\n$cachedFilter = Zend\\Cache\\PatternFactory::factory('object', [\n    'object'     => $filter,\n    'object_key' => 'RealpathFilter',\n    'storage'    => 'apc',\n\n    // The realpath filter doesn't output anything\n    // so the output don't need to be caught and cached\n    'cache_output' => false,\n]);\n\n$path = $cachedFilter->call(\"filter\", ['/www/var/path/../../mypath']);\n\n// OR\n$path = $cachedFilter->filter('/www/var/path/../../mypath');",
            "title": "Caching a filter"
        },
        {
            "location": "/pattern/output-cache/",
            "text": "OutputCache\n\n\nThe \nOutputCache\n pattern caches output between calls to \nstart()\n and \nend()\n.\n\n\nQuick Start\n\n\nuse Zend\\Cache\\PatternFactory;\n\n$outputCache = PatternFactory::factory('output', [\n    'storage' => 'apc'\n]);\n\n\n\nConfiguration Options\n\n\n\n\n\n\n\n\nOption\n\n\nData Type\n\n\nDefault Value\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nstorage\n\n\nstring | array | Zend\\Cache\\Storage\\StorageInterface\n\n\nnone\n\n\nAdapter used for reading and writing cached data.\n\n\n\n\n\n\n\n\nAvailable Methods\n\n\nIn addition to the methods defined in \nPatternInterface\n, this implementation\ndefines the following methods.\n\n\nnamespace Zend\\Cache\\Pattern;\n\nuse Zend\\Cache\\Exception;\n\nclass OutputCache extends AbstractPattern\n{\n    /**\n     * If there is a cached item with the given key, display its data, and\n     * return true. Otherwise, start buffering output until end() is called, or\n     * the script ends.\n     *\n     * @param  string  $key Key\n     * @throws Exception\\MissingKeyException if key is missing\n     * @return bool\n     */\n    public function start($key);\n\n    /**\n     * Stop buffering output, write buffered data to the cache using the key\n     * provided to start(), and display the buffer.\n     *\n     * @throws Exception\\RuntimeException if output cache not started or buffering not active\n     * @return bool TRUE on success, FALSE on failure writing to cache\n     */\n    public function end();\n}\n\n\n\nExamples\n\n\nCaching simple view scripts\n\n\n$outputCache = Zend\\Cache\\PatternFactory::factory('output', [\n    'storage' => 'apc',\n]);\n\n$outputCache->start('mySimpleViewScript');\ninclude '/path/to/view/script.phtml';\n$outputCache->end();",
            "title": "OutputCache"
        },
        {
            "location": "/pattern/output-cache/#outputcache",
            "text": "The  OutputCache  pattern caches output between calls to  start()  and  end() .",
            "title": "OutputCache"
        },
        {
            "location": "/pattern/output-cache/#quick-start",
            "text": "use Zend\\Cache\\PatternFactory;\n\n$outputCache = PatternFactory::factory('output', [\n    'storage' => 'apc'\n]);",
            "title": "Quick Start"
        },
        {
            "location": "/pattern/output-cache/#configuration-options",
            "text": "Option  Data Type  Default Value  Description      storage  string | array | Zend\\Cache\\Storage\\StorageInterface  none  Adapter used for reading and writing cached data.",
            "title": "Configuration Options"
        },
        {
            "location": "/pattern/output-cache/#available-methods",
            "text": "In addition to the methods defined in  PatternInterface , this implementation\ndefines the following methods.  namespace Zend\\Cache\\Pattern;\n\nuse Zend\\Cache\\Exception;\n\nclass OutputCache extends AbstractPattern\n{\n    /**\n     * If there is a cached item with the given key, display its data, and\n     * return true. Otherwise, start buffering output until end() is called, or\n     * the script ends.\n     *\n     * @param  string  $key Key\n     * @throws Exception\\MissingKeyException if key is missing\n     * @return bool\n     */\n    public function start($key);\n\n    /**\n     * Stop buffering output, write buffered data to the cache using the key\n     * provided to start(), and display the buffer.\n     *\n     * @throws Exception\\RuntimeException if output cache not started or buffering not active\n     * @return bool TRUE on success, FALSE on failure writing to cache\n     */\n    public function end();\n}",
            "title": "Available Methods"
        },
        {
            "location": "/pattern/output-cache/#examples",
            "text": "",
            "title": "Examples"
        },
        {
            "location": "/pattern/output-cache/#caching-simple-view-scripts",
            "text": "$outputCache = Zend\\Cache\\PatternFactory::factory('output', [\n    'storage' => 'apc',\n]);\n\n$outputCache->start('mySimpleViewScript');\ninclude '/path/to/view/script.phtml';\n$outputCache->end();",
            "title": "Caching simple view scripts"
        },
        {
            "location": "/pattern/capture-cache/",
            "text": "CaptureCache\n\n\nThe \nCaptureCache\n pattern is useful for generating static resources to return\nvia HTTP request. When used in such a fashion, the web server needs to be\nconfigured to run a PHP script generating the requested resource so that\nsubsequent requests for the same resource can be shipped without calling PHP\nagain.\n\n\nThis pattern comes with basic logic for managing generated resources.\n\n\nQuick Start\n\n\nFor use with an Apache 404 handler:\n\n\n# .htdocs\nErrorDocument 404 /index.php\n\n\n\n// index.php\nuse Zend\\Cache\\PatternFactory;\n$capture = Zend\\Cache\\PatternFactory::factory('capture', [\n    'public_dir' => __DIR__,\n]);\n\n// Start capturing all output, excluding headers, and write to the public\n// directory:\n$capture->start();\n\n// Don't forget to change the HTTP response code\nheader('Status: 200', true, 200);\n\n// do stuff to dynamically generate output\n\n\n\nConfiguration Options\n\n\n\n\n\n\n\n\nOption\n\n\nData Type\n\n\nDefault Value\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\npublic_dir\n\n\nstring\n\n\nnone\n\n\nLocation of the public web root directory in which to write output.\n\n\n\n\n\n\nindex_filename\n\n\nstring\n\n\n\"index.html\"\n\n\nThe name of the index file if only a directory was requested.\n\n\n\n\n\n\nfile_locking\n\n\nbool\n\n\ntrue\n\n\nWhether or not to lock output files when writing.\n\n\n\n\n\n\nfile_permission\n\n\nint | bool\n\n\n0600\n (\nfalse\n on Windows)\n\n\nDefault permissions for generated output files.\n\n\n\n\n\n\ndir_permission\n\n\nint | bool\n\n\n0700\n (\nfalse\n on Windows)\n\n\nDefault permissions for generated output directories.\n\n\n\n\n\n\numask\n\n\nint\n\n\nbool\n\n\nfalse\n\n\n\n\n\n\n\n\nAvailable Methods\n\n\nIn addition to the methods exposed in \nPatternInterface\n, this implementation\nexposes the following methods.\n\n\nnamespace Zend\\Cache\\Pattern;\n\nuse Zend\\Cache\\Exception;\nuse Zend\\Stdlib\\ErrorHandler;\n\nclass CaptureCache extends AbstractPattern\n{\n    /**\n     * Start the cache.\n     *\n     * @param  string $pageId  Page identifier\n     * @return void\n     */\n    public function start($pageId = null);\n\n    /**\n     * Write a page to the requested path.\n     *\n     * @param string      $content\n     * @param null|string $pageId\n     * @throws Exception\\LogicException\n     */\n    public function set($content, $pageId = null);\n\n    /**\n     * Retrieve a generated page from the cache.\n     *\n     * @param  null|string $pageId\n     * @return string|null\n     * @throws Exception\\LogicException\n     * @throws Exception\\RuntimeException\n     */\n    public function get($pageId = null);\n\n    /**\n     * Check if a cache exists for the given page.\n     *\n     * @param  null|string $pageId\n     * @throws Exception\\LogicException\n     * @return bool\n     */\n    public function has($pageId = null);\n\n    /**\n     * Remove a page from the cache.\n     *\n     * @param  null|string $pageId\n     * @throws Exception\\LogicException\n     * @throws Exception\\RuntimeException\n     * @return bool\n     */\n    public function remove($pageId = null);\n\n    /**\n     * Clear cached pages that match the specified glob pattern.\n     *\n     * @param string $pattern\n     * @throws Exception\\LogicException\n     */\n    public function clearByGlob($pattern = '**');\n\n    /**\n     * Returns the generated file name.\n     *\n     * @param null|string $pageId\n     * @return string\n     */\n    public function getFilename($pageId = null);\n}\n\n\n\nExamples\n\n\nScaling images in the web root\n\n\nUsing the following Apache 404 configuration:\n\n\n# .htdocs\nErrorDocument 404 /index.php\n\n\n\nUse the following script:\n\n\n// index.php\n$captureCache = Zend\\Cache\\PatternFactory::factory('capture', [\n    'public_dir' => __DIR__,\n]);\n\n// TODO",
            "title": "CaptureCache"
        },
        {
            "location": "/pattern/capture-cache/#capturecache",
            "text": "The  CaptureCache  pattern is useful for generating static resources to return\nvia HTTP request. When used in such a fashion, the web server needs to be\nconfigured to run a PHP script generating the requested resource so that\nsubsequent requests for the same resource can be shipped without calling PHP\nagain.  This pattern comes with basic logic for managing generated resources.",
            "title": "CaptureCache"
        },
        {
            "location": "/pattern/capture-cache/#quick-start",
            "text": "For use with an Apache 404 handler:  # .htdocs\nErrorDocument 404 /index.php  // index.php\nuse Zend\\Cache\\PatternFactory;\n$capture = Zend\\Cache\\PatternFactory::factory('capture', [\n    'public_dir' => __DIR__,\n]);\n\n// Start capturing all output, excluding headers, and write to the public\n// directory:\n$capture->start();\n\n// Don't forget to change the HTTP response code\nheader('Status: 200', true, 200);\n\n// do stuff to dynamically generate output",
            "title": "Quick Start"
        },
        {
            "location": "/pattern/capture-cache/#configuration-options",
            "text": "Option  Data Type  Default Value  Description      public_dir  string  none  Location of the public web root directory in which to write output.    index_filename  string  \"index.html\"  The name of the index file if only a directory was requested.    file_locking  bool  true  Whether or not to lock output files when writing.    file_permission  int | bool  0600  ( false  on Windows)  Default permissions for generated output files.    dir_permission  int | bool  0700  ( false  on Windows)  Default permissions for generated output directories.    umask  int  bool  false",
            "title": "Configuration Options"
        },
        {
            "location": "/pattern/capture-cache/#available-methods",
            "text": "In addition to the methods exposed in  PatternInterface , this implementation\nexposes the following methods.  namespace Zend\\Cache\\Pattern;\n\nuse Zend\\Cache\\Exception;\nuse Zend\\Stdlib\\ErrorHandler;\n\nclass CaptureCache extends AbstractPattern\n{\n    /**\n     * Start the cache.\n     *\n     * @param  string $pageId  Page identifier\n     * @return void\n     */\n    public function start($pageId = null);\n\n    /**\n     * Write a page to the requested path.\n     *\n     * @param string      $content\n     * @param null|string $pageId\n     * @throws Exception\\LogicException\n     */\n    public function set($content, $pageId = null);\n\n    /**\n     * Retrieve a generated page from the cache.\n     *\n     * @param  null|string $pageId\n     * @return string|null\n     * @throws Exception\\LogicException\n     * @throws Exception\\RuntimeException\n     */\n    public function get($pageId = null);\n\n    /**\n     * Check if a cache exists for the given page.\n     *\n     * @param  null|string $pageId\n     * @throws Exception\\LogicException\n     * @return bool\n     */\n    public function has($pageId = null);\n\n    /**\n     * Remove a page from the cache.\n     *\n     * @param  null|string $pageId\n     * @throws Exception\\LogicException\n     * @throws Exception\\RuntimeException\n     * @return bool\n     */\n    public function remove($pageId = null);\n\n    /**\n     * Clear cached pages that match the specified glob pattern.\n     *\n     * @param string $pattern\n     * @throws Exception\\LogicException\n     */\n    public function clearByGlob($pattern = '**');\n\n    /**\n     * Returns the generated file name.\n     *\n     * @param null|string $pageId\n     * @return string\n     */\n    public function getFilename($pageId = null);\n}",
            "title": "Available Methods"
        },
        {
            "location": "/pattern/capture-cache/#examples",
            "text": "",
            "title": "Examples"
        },
        {
            "location": "/pattern/capture-cache/#scaling-images-in-the-web-root",
            "text": "Using the following Apache 404 configuration:  # .htdocs\nErrorDocument 404 /index.php  Use the following script:  // index.php\n$captureCache = Zend\\Cache\\PatternFactory::factory('capture', [\n    'public_dir' => __DIR__,\n]);\n\n// TODO",
            "title": "Scaling images in the web root"
        },
        {
            "location": "/psr6/",
            "text": "PSR-6 Support\n\n\n\n\nSince 2.8.0\n\n\n\n\nOverview\n\n\nThe \nZend\\Cache\\Psr\\CacheItemPool\\CacheItemPoolDecorator\n provides a \nPSR-6\n\ncompliant wrapper for supported storage adapters.\n\n\nPSR-6 specifies a common interface to cache storage, enabling developers to switch between implementations without\nhaving to worry about any behind-the-scenes differences between them.\n\n\nQuick Start\n\n\nTo use the pool, instantiate your storage as normal, then pass it to the\n\nCacheItemPoolDecorator\n.\n\n\nuse Zend\\Cache\\StorageFactory;\nuse Zend\\Cache\\Psr\\CacheItemPool\\CacheItemPoolDecorator;\n\n$storage = StorageFactory::factory([\n    'adapter' => [\n        'name'    => 'apc',\n        'options' => [],\n    ],\n]);\n\n$pool = new CacheItemPoolDecorator($storage);\n\n// attempt to get an item from cache\n$item = $pool->getItem('foo');\n\n// check whether item was found\nif (! $item->isHit()) {\n    // ...\n    // perform expensive operation to calculate $value for 'foo'\n    // ...\n\n    $item->set($value);\n    $pool->save($item);\n}\n\n// use the value of the item\necho $item->get();\n\n\n\nNote that you will always get back a \nCacheItem\n object, whether it was found in cache or not: this is so \nfalse\n-y\nvalues like an empty string, \nnull\n, or \nfalse\n can be stored. Always check \nisHit()\n to determine if the item was\nfound.\n\n\nSupported adapters\n\n\nThe PSR-6 specification requires that the underlying storage support time-to-live (TTL), which is set when the\nitem is saved. For this reason the following adapters cannot be used: \nDba\n, \nFilesystem\n, \nMemory\n and \nSession\n. The\n\nXCache\n adapter calculates TTLs based on the request time, not the time the item is actually persisted, which means\nthat it also cannot be used.\n\n\nIn addition adapters must support the \nZend\\Cache\\FlushableInterface\n. All the current \nZend\\Cache\\Storage\\Adapter\ns\nfulfil this requirement.\n\n\nAttempting to use an unsupported adapter will throw an exception implementing \nPsr\\Cache\\CacheException\n.\n\n\nThe \nZend\\Cache\\Psr\\CacheItemPool\\CacheItemPoolDecorator\n adapter doesn't support driver deferred saves, so cache items are saved\non destruct or on explicit \ncommit()\n call.\n\n\nQuirks\n\n\nAPC\n\n\nYou cannot set the \napc.use_request_time\n\nini setting with the APC adapter: the specification requires that all TTL values are calculated from when the item is\nactually saved to storage. If this is set when you instantiate the pool it will throw an exception implementing\n\nPsr\\Cache\\CacheException\n. Changing the setting after you have instantiated the pool will result in non-standard\nbehaviour.\n\n\nLogging errors\n\n\nThe specification \nstates\n:\n\n\n\n\nWhile caching is often an important part of application performance, it should never be a critical part of application\nfunctionality. Thus, an error in a cache system SHOULD NOT result in application failure.\n\n\n\n\nOnce you've got your pool instance, almost all exceptions thrown by the storage will be caught and ignored. The only\nstorage exceptions that bubble up implement \nPsr\\Cache\\InvalidArgumentException\n and are typically caused by invalid\nkey errors. To be PSR-6 compliant, cache keys must not contain the following characters: \n{}()/\\@:\n. However different\nstorage adapters may have further restrictions. Check the documentation for your particular adapter to be sure.\n\n\nWe strongly recommend tracking exceptions caught from storage, either by logging them or recording them in some other\nway. Doing so is as simple as adding an \nExceptionHandler\n plugin\n. Say you have a\n\nPSR-3\n compliant logger\ncalled \n$logger\n:\n\n\n$cacheLogger = function (\\Exception $e) use ($logger) {\n    $message = sprintf(\n        '[CACHE] %s:%s %s \"%s\"',\n        $exception->getFile(),\n        $exception->getLine(),\n        $exception->getCode(),\n        $exception->getMessage()\n    );\n    $logger->error($message);\n};\n                                }\n$storage = StorageFactory::factory([\n    'adapter' => [\n        'name'    => 'apc',\n    ],\n    'plugins' => [\n        'exceptionhandler' => [\n            'exception_callback' => $cacheLogger,\n            'throw_exceptions' => true,\n        ],\n    ],\n]);\n\n$pool = new CacheItemPoolDecorator($storage);\n\n\n\nNote that \nthrow_exceptions\n should always be \ntrue\n (the default) or you will not get the correct return values from\ncalls on the pool such as \nsave()\n.\n\n\nSupported data types\n\n\nAs per \nthe specification\n, the\nfollowing data types can be stored in cache: \nstring\n, \ninteger\n, \nfloat\n, \nboolean\n, \nnull\n, \narray\n, \nobject\n and be\nreturned as a value with exactly the same type.\n\n\nNot all adapters can natively store all these types. For instance, Redis stores booleans and integers as a string. Where\nthis is the case \nall\n values will be automatically run through \nserialize()\n on save and \nunserialize()\n on get: you\ndo not need to use a \nZend\\Cache\\Storage\\Plugin\\Serializer\n plugin.",
            "title": "PSR-6"
        },
        {
            "location": "/psr6/#psr-6-support",
            "text": "Since 2.8.0",
            "title": "PSR-6 Support"
        },
        {
            "location": "/psr6/#overview",
            "text": "The  Zend\\Cache\\Psr\\CacheItemPool\\CacheItemPoolDecorator  provides a  PSR-6 \ncompliant wrapper for supported storage adapters.  PSR-6 specifies a common interface to cache storage, enabling developers to switch between implementations without\nhaving to worry about any behind-the-scenes differences between them.",
            "title": "Overview"
        },
        {
            "location": "/psr6/#quick-start",
            "text": "To use the pool, instantiate your storage as normal, then pass it to the CacheItemPoolDecorator .  use Zend\\Cache\\StorageFactory;\nuse Zend\\Cache\\Psr\\CacheItemPool\\CacheItemPoolDecorator;\n\n$storage = StorageFactory::factory([\n    'adapter' => [\n        'name'    => 'apc',\n        'options' => [],\n    ],\n]);\n\n$pool = new CacheItemPoolDecorator($storage);\n\n// attempt to get an item from cache\n$item = $pool->getItem('foo');\n\n// check whether item was found\nif (! $item->isHit()) {\n    // ...\n    // perform expensive operation to calculate $value for 'foo'\n    // ...\n\n    $item->set($value);\n    $pool->save($item);\n}\n\n// use the value of the item\necho $item->get();  Note that you will always get back a  CacheItem  object, whether it was found in cache or not: this is so  false -y\nvalues like an empty string,  null , or  false  can be stored. Always check  isHit()  to determine if the item was\nfound.",
            "title": "Quick Start"
        },
        {
            "location": "/psr6/#supported-adapters",
            "text": "The PSR-6 specification requires that the underlying storage support time-to-live (TTL), which is set when the\nitem is saved. For this reason the following adapters cannot be used:  Dba ,  Filesystem ,  Memory  and  Session . The XCache  adapter calculates TTLs based on the request time, not the time the item is actually persisted, which means\nthat it also cannot be used.  In addition adapters must support the  Zend\\Cache\\FlushableInterface . All the current  Zend\\Cache\\Storage\\Adapter s\nfulfil this requirement.  Attempting to use an unsupported adapter will throw an exception implementing  Psr\\Cache\\CacheException .  The  Zend\\Cache\\Psr\\CacheItemPool\\CacheItemPoolDecorator  adapter doesn't support driver deferred saves, so cache items are saved\non destruct or on explicit  commit()  call.",
            "title": "Supported adapters"
        },
        {
            "location": "/psr6/#quirks",
            "text": "",
            "title": "Quirks"
        },
        {
            "location": "/psr6/#apc",
            "text": "You cannot set the  apc.use_request_time \nini setting with the APC adapter: the specification requires that all TTL values are calculated from when the item is\nactually saved to storage. If this is set when you instantiate the pool it will throw an exception implementing Psr\\Cache\\CacheException . Changing the setting after you have instantiated the pool will result in non-standard\nbehaviour.",
            "title": "APC"
        },
        {
            "location": "/psr6/#logging-errors",
            "text": "The specification  states :   While caching is often an important part of application performance, it should never be a critical part of application\nfunctionality. Thus, an error in a cache system SHOULD NOT result in application failure.   Once you've got your pool instance, almost all exceptions thrown by the storage will be caught and ignored. The only\nstorage exceptions that bubble up implement  Psr\\Cache\\InvalidArgumentException  and are typically caused by invalid\nkey errors. To be PSR-6 compliant, cache keys must not contain the following characters:  {}()/\\@: . However different\nstorage adapters may have further restrictions. Check the documentation for your particular adapter to be sure.  We strongly recommend tracking exceptions caught from storage, either by logging them or recording them in some other\nway. Doing so is as simple as adding an  ExceptionHandler  plugin . Say you have a PSR-3  compliant logger\ncalled  $logger :  $cacheLogger = function (\\Exception $e) use ($logger) {\n    $message = sprintf(\n        '[CACHE] %s:%s %s \"%s\"',\n        $exception->getFile(),\n        $exception->getLine(),\n        $exception->getCode(),\n        $exception->getMessage()\n    );\n    $logger->error($message);\n};\n                                }\n$storage = StorageFactory::factory([\n    'adapter' => [\n        'name'    => 'apc',\n    ],\n    'plugins' => [\n        'exceptionhandler' => [\n            'exception_callback' => $cacheLogger,\n            'throw_exceptions' => true,\n        ],\n    ],\n]);\n\n$pool = new CacheItemPoolDecorator($storage);  Note that  throw_exceptions  should always be  true  (the default) or you will not get the correct return values from\ncalls on the pool such as  save() .",
            "title": "Logging errors"
        },
        {
            "location": "/psr6/#supported-data-types",
            "text": "As per  the specification , the\nfollowing data types can be stored in cache:  string ,  integer ,  float ,  boolean ,  null ,  array ,  object  and be\nreturned as a value with exactly the same type.  Not all adapters can natively store all these types. For instance, Redis stores booleans and integers as a string. Where\nthis is the case  all  values will be automatically run through  serialize()  on save and  unserialize()  on get: you\ndo not need to use a  Zend\\Cache\\Storage\\Plugin\\Serializer  plugin.",
            "title": "Supported data types"
        },
        {
            "location": "/psr16/",
            "text": "PSR-16 Support\n\n\n\n\nSince 2.8.0\n\n\n\n\nPSR-16\n provides a simplified approach to\ncache access that does not involve cache pools, tags, deferment, etc.; it\ncan be thought of as a key/value storage approach to caching.\n\n\nzend-cache provides PSR-16 support via the class\n\nZend\\Cache\\Psr\\SimpleCache\\SimpleCacheDecorator\n. This class implements PSR-16's\n\nPsr\\SimpleCache\\CacheInterface\n, and composes a\n\nZend\\Cache\\Storage\\StorageInterface\n instance to which it proxies all\noperations.\n\n\nInstantiation is as follows:\n\n\nuse Zend\\Cache\\StorageFactory;\nuse Zend\\Cache\\Psr\\SimpleCache\\SimpleCacheDecorator;\n\n$storage = StorageFactory::factory([\n    'adapter' => [\n        'name'    => 'apc',\n        'options' => [],\n    ],\n]);\n\n$cache = new SimpleCacheDecorator($storage);\n\n\n\nOnce you have a \nSimpleCacheDecorator\n instance, you can perform operations per\nthat specification:\n\n\n// Use has() to determine whether to fetch the value or calculate it:\n$value = $cache->has('someKey') ? $cache->get('someKey') : calculateValue();\nif (! $cache->has('someKey')) {\n    $cache->set('someKey', $value);\n}\n\n// Or use a default value:\n$value = $cache->get('someKey', $defaultValue);\n\n\n\nWhen setting values, whether single values or multiple, you can also optionally\nprovide a Time To Live (TTL) value. This proxies to the underlying storage\ninstance's options, temporarily resetting its TTL value for the duration of the\noperation. TTL values may be expressed as integers (in which case they represent\nseconds) or \nDateInterval\n instances. As examples:\n\n\n$cache->set('someKey', $value, 30); // set TTL to 30s\n$cache->set('someKey', $value, new DateInterval('P1D'); // set TTL to 1 day\n\n$cache->setMultiple([\n    'key1' => $value1,\n    'key2' => $value2,\n], 3600); // set TTL to 1 hour\n$cache->setMultiple([\n    'key1' => $value1,\n    'key2' => $value2,\n], new DateInterval('P6H'); // set TTL to 6 hours\n\n\n\nFor more details on what methods are exposed, consult the \nCacheInterface\nspecification\n.\n\n\nSerialization\n\n\nPSR-16 has strict requirements around serialization of values. This is done to\nensure that if you swap one PSR-16 adapter for another, the new one will be able\nto return the same values that the original adapter saved to the cache.\n\n\nNot all cache backends support the same data types, however. zend-cache provides\na plugin, \nZend\\Cache\\Storage\\Plugin\\Serializer\n, that you can attach to\nadapters in order to ensure data is serialized to a string when saving to the\ncache, and deserialized to native PHP types on retrieval. The following adapters\nrequire this plugin in order to work with the \nSimpleCacheDecorator\n:\n\n\n\n\nDba\n\n\nFilesystem\n\n\nMemcache\n\n\nMongoDB\n\n\nRedis\n\n\nXCache\n\n\n\n\nWe provide a number of examples of \nattaching plugins to storage adapters in the\nplugins chapter\n. Generally, it will be one of:\n\n\n// Manual attachment after you have an instance:\n$cache->addPlugin(new Serializer());\n\n// Via configuration:\n$cache = StorageFactory::factory([\n    'adapter' => 'filesystem',\n    'plugins' => [\n        'serializer',\n    ],\n]);\n\n\n\nDeleting items and exceptions\n\n\nPSR-16 states that the \ndelete()\n and \ndeleteMultiple()\n methods should return\n\nfalse\n if an \nerror\n occured when deleting the key(s) provided, but \ntrue\n\notherwise.\n\n\nGenerally, zend-cache storage adapters comply with this. However, it is possible\nto configure your adapter such that you may get a false positive result from\nthese methods.\n\n\nWhen an exception is raised and caught during key removal by an adapter, the\nadapter triggers an event with a \nZend\\Cache\\Storage\\ExceptionEvent\n. Plugins \ncan react to these, and even manipulate the event instance. One such plugin,\n\nZend\\Cache\\Storage\\Plugin\\ExceptionHandler\n, has a configuration option,\n\nthrow_exceptions\n that, when boolean \nfalse\n, will prevent raising the\nexception. In such cases, adapters will typically return a boolean \nfalse\n\nanyways, but custom, third-party adapters may not.\n\n\nAdditionally, if you add a custom plugin that listens to removal event\nexceptions and modifies the return value and/or disables throwing the exception,\na false positive return value could occur.\n\n\nAs such, we recommend that if you wish to use zend-cache to provide a PSR-16\nadapter, you audit the plugins you use with your adapter to ensure that you will\nget consistent, correct behavior for \ndelete()\n and \ndeleteMultiple()\n\noperations.",
            "title": "PSR-16"
        },
        {
            "location": "/psr16/#psr-16-support",
            "text": "Since 2.8.0   PSR-16  provides a simplified approach to\ncache access that does not involve cache pools, tags, deferment, etc.; it\ncan be thought of as a key/value storage approach to caching.  zend-cache provides PSR-16 support via the class Zend\\Cache\\Psr\\SimpleCache\\SimpleCacheDecorator . This class implements PSR-16's Psr\\SimpleCache\\CacheInterface , and composes a Zend\\Cache\\Storage\\StorageInterface  instance to which it proxies all\noperations.  Instantiation is as follows:  use Zend\\Cache\\StorageFactory;\nuse Zend\\Cache\\Psr\\SimpleCache\\SimpleCacheDecorator;\n\n$storage = StorageFactory::factory([\n    'adapter' => [\n        'name'    => 'apc',\n        'options' => [],\n    ],\n]);\n\n$cache = new SimpleCacheDecorator($storage);  Once you have a  SimpleCacheDecorator  instance, you can perform operations per\nthat specification:  // Use has() to determine whether to fetch the value or calculate it:\n$value = $cache->has('someKey') ? $cache->get('someKey') : calculateValue();\nif (! $cache->has('someKey')) {\n    $cache->set('someKey', $value);\n}\n\n// Or use a default value:\n$value = $cache->get('someKey', $defaultValue);  When setting values, whether single values or multiple, you can also optionally\nprovide a Time To Live (TTL) value. This proxies to the underlying storage\ninstance's options, temporarily resetting its TTL value for the duration of the\noperation. TTL values may be expressed as integers (in which case they represent\nseconds) or  DateInterval  instances. As examples:  $cache->set('someKey', $value, 30); // set TTL to 30s\n$cache->set('someKey', $value, new DateInterval('P1D'); // set TTL to 1 day\n\n$cache->setMultiple([\n    'key1' => $value1,\n    'key2' => $value2,\n], 3600); // set TTL to 1 hour\n$cache->setMultiple([\n    'key1' => $value1,\n    'key2' => $value2,\n], new DateInterval('P6H'); // set TTL to 6 hours  For more details on what methods are exposed, consult the  CacheInterface\nspecification .",
            "title": "PSR-16 Support"
        },
        {
            "location": "/psr16/#serialization",
            "text": "PSR-16 has strict requirements around serialization of values. This is done to\nensure that if you swap one PSR-16 adapter for another, the new one will be able\nto return the same values that the original adapter saved to the cache.  Not all cache backends support the same data types, however. zend-cache provides\na plugin,  Zend\\Cache\\Storage\\Plugin\\Serializer , that you can attach to\nadapters in order to ensure data is serialized to a string when saving to the\ncache, and deserialized to native PHP types on retrieval. The following adapters\nrequire this plugin in order to work with the  SimpleCacheDecorator :   Dba  Filesystem  Memcache  MongoDB  Redis  XCache   We provide a number of examples of  attaching plugins to storage adapters in the\nplugins chapter . Generally, it will be one of:  // Manual attachment after you have an instance:\n$cache->addPlugin(new Serializer());\n\n// Via configuration:\n$cache = StorageFactory::factory([\n    'adapter' => 'filesystem',\n    'plugins' => [\n        'serializer',\n    ],\n]);",
            "title": "Serialization"
        },
        {
            "location": "/psr16/#deleting-items-and-exceptions",
            "text": "PSR-16 states that the  delete()  and  deleteMultiple()  methods should return false  if an  error  occured when deleting the key(s) provided, but  true \notherwise.  Generally, zend-cache storage adapters comply with this. However, it is possible\nto configure your adapter such that you may get a false positive result from\nthese methods.  When an exception is raised and caught during key removal by an adapter, the\nadapter triggers an event with a  Zend\\Cache\\Storage\\ExceptionEvent . Plugins \ncan react to these, and even manipulate the event instance. One such plugin, Zend\\Cache\\Storage\\Plugin\\ExceptionHandler , has a configuration option, throw_exceptions  that, when boolean  false , will prevent raising the\nexception. In such cases, adapters will typically return a boolean  false \nanyways, but custom, third-party adapters may not.  Additionally, if you add a custom plugin that listens to removal event\nexceptions and modifies the return value and/or disables throwing the exception,\na false positive return value could occur.  As such, we recommend that if you wish to use zend-cache to provide a PSR-16\nadapter, you audit the plugins you use with your adapter to ensure that you will\nget consistent, correct behavior for  delete()  and  deleteMultiple() \noperations.",
            "title": "Deleting items and exceptions"
        }
    ]
}