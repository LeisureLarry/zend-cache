{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"zend-cache Zend\\Cache provides a general cache system for PHP. The Zend\\Cache component is able to cache different patterns (class, object, output, etc) using different storage adapters (DB, File, Memcache, etc). File issues at https://github.com/zendframework/zend-cache/issues Documentation is at https://docs.zendframework.com/zend-cache/ Benchmarks We provide scripts for benchmarking zend-cache using the PHPBench framework; these can be found in the benchmark/ directory. To execute the benchmarks you can run the following command: $ vendor/bin/phpbench run --report=aggregate","title":"zend-cache"},{"location":"#zend-cache","text":"Zend\\Cache provides a general cache system for PHP. The Zend\\Cache component is able to cache different patterns (class, object, output, etc) using different storage adapters (DB, File, Memcache, etc). File issues at https://github.com/zendframework/zend-cache/issues Documentation is at https://docs.zendframework.com/zend-cache/","title":"zend-cache"},{"location":"#benchmarks","text":"We provide scripts for benchmarking zend-cache using the PHPBench framework; these can be found in the benchmark/ directory. To execute the benchmarks you can run the following command: $ vendor/bin/phpbench run --report=aggregate","title":"Benchmarks"},{"location":"psr16/","text":"PSR-16 Support Since 2.8.0 PSR-16 provides a simplified approach to cache access that does not involve cache pools, tags, deferment, etc.; it can be thought of as a key/value storage approach to caching. zend-cache provides PSR-16 support via the class Zend\\Cache\\Psr\\SimpleCache\\SimpleCacheDecorator . This class implements PSR-16's Psr\\SimpleCache\\CacheInterface , and composes a Zend\\Cache\\Storage\\StorageInterface instance to which it proxies all operations. Instantiation is as follows: use Zend\\Cache\\StorageFactory; use Zend\\Cache\\Psr\\SimpleCache\\SimpleCacheDecorator; $storage = StorageFactory::factory([ 'adapter' => [ 'name' => 'apc', 'options' => [], ], ]); $cache = new SimpleCacheDecorator($storage); Once you have a SimpleCacheDecorator instance, you can perform operations per that specification: // Use has() to determine whether to fetch the value or calculate it: $value = $cache->has('someKey') ? $cache->get('someKey') : calculateValue(); if (! $cache->has('someKey')) { $cache->set('someKey', $value); } // Or use a default value: $value = $cache->get('someKey', $defaultValue); When setting values, whether single values or multiple, you can also optionally provide a Time To Live (TTL) value. This proxies to the underlying storage instance's options, temporarily resetting its TTL value for the duration of the operation. TTL values may be expressed as integers (in which case they represent seconds) or DateInterval instances. As examples: $cache->set('someKey', $value, 30); // set TTL to 30s $cache->set('someKey', $value, new DateInterval('P1D'); // set TTL to 1 day $cache->setMultiple([ 'key1' => $value1, 'key2' => $value2, ], 3600); // set TTL to 1 hour $cache->setMultiple([ 'key1' => $value1, 'key2' => $value2, ], new DateInterval('P6H'); // set TTL to 6 hours For more details on what methods are exposed, consult the CacheInterface specification . Serialization PSR-16 has strict requirements around serialization of values. This is done to ensure that if you swap one PSR-16 adapter for another, the new one will be able to return the same values that the original adapter saved to the cache. Not all cache backends support the same data types, however. zend-cache provides a plugin, Zend\\Cache\\Storage\\Plugin\\Serializer , that you can attach to adapters in order to ensure data is serialized to a string when saving to the cache, and deserialized to native PHP types on retrieval. The following adapters require this plugin in order to work with the SimpleCacheDecorator : Dba Filesystem Memcache MongoDB Redis XCache We provide a number of examples of attaching plugins to storage adapters in the plugins chapter . Generally, it will be one of: // Manual attachment after you have an instance: $cache->addPlugin(new Serializer()); // Via configuration: $cache = StorageFactory::factory([ 'adapter' => 'filesystem', 'plugins' => [ 'serializer', ], ]); Deleting items and exceptions PSR-16 states that the delete() and deleteMultiple() methods should return false if an error occured when deleting the key(s) provided, but true otherwise. Generally, zend-cache storage adapters comply with this. However, it is possible to configure your adapter such that you may get a false positive result from these methods. When an exception is raised and caught during key removal by an adapter, the adapter triggers an event with a Zend\\Cache\\Storage\\ExceptionEvent . Plugins can react to these, and even manipulate the event instance. One such plugin, Zend\\Cache\\Storage\\Plugin\\ExceptionHandler , has a configuration option, throw_exceptions that, when boolean false , will prevent raising the exception. In such cases, adapters will typically return a boolean false anyways, but custom, third-party adapters may not. Additionally, if you add a custom plugin that listens to removal event exceptions and modifies the return value and/or disables throwing the exception, a false positive return value could occur. As such, we recommend that if you wish to use zend-cache to provide a PSR-16 adapter, you audit the plugins you use with your adapter to ensure that you will get consistent, correct behavior for delete() and deleteMultiple() operations.","title":"PSR-16"},{"location":"psr16/#psr-16-support","text":"Since 2.8.0 PSR-16 provides a simplified approach to cache access that does not involve cache pools, tags, deferment, etc.; it can be thought of as a key/value storage approach to caching. zend-cache provides PSR-16 support via the class Zend\\Cache\\Psr\\SimpleCache\\SimpleCacheDecorator . This class implements PSR-16's Psr\\SimpleCache\\CacheInterface , and composes a Zend\\Cache\\Storage\\StorageInterface instance to which it proxies all operations. Instantiation is as follows: use Zend\\Cache\\StorageFactory; use Zend\\Cache\\Psr\\SimpleCache\\SimpleCacheDecorator; $storage = StorageFactory::factory([ 'adapter' => [ 'name' => 'apc', 'options' => [], ], ]); $cache = new SimpleCacheDecorator($storage); Once you have a SimpleCacheDecorator instance, you can perform operations per that specification: // Use has() to determine whether to fetch the value or calculate it: $value = $cache->has('someKey') ? $cache->get('someKey') : calculateValue(); if (! $cache->has('someKey')) { $cache->set('someKey', $value); } // Or use a default value: $value = $cache->get('someKey', $defaultValue); When setting values, whether single values or multiple, you can also optionally provide a Time To Live (TTL) value. This proxies to the underlying storage instance's options, temporarily resetting its TTL value for the duration of the operation. TTL values may be expressed as integers (in which case they represent seconds) or DateInterval instances. As examples: $cache->set('someKey', $value, 30); // set TTL to 30s $cache->set('someKey', $value, new DateInterval('P1D'); // set TTL to 1 day $cache->setMultiple([ 'key1' => $value1, 'key2' => $value2, ], 3600); // set TTL to 1 hour $cache->setMultiple([ 'key1' => $value1, 'key2' => $value2, ], new DateInterval('P6H'); // set TTL to 6 hours For more details on what methods are exposed, consult the CacheInterface specification .","title":"PSR-16 Support"},{"location":"psr16/#serialization","text":"PSR-16 has strict requirements around serialization of values. This is done to ensure that if you swap one PSR-16 adapter for another, the new one will be able to return the same values that the original adapter saved to the cache. Not all cache backends support the same data types, however. zend-cache provides a plugin, Zend\\Cache\\Storage\\Plugin\\Serializer , that you can attach to adapters in order to ensure data is serialized to a string when saving to the cache, and deserialized to native PHP types on retrieval. The following adapters require this plugin in order to work with the SimpleCacheDecorator : Dba Filesystem Memcache MongoDB Redis XCache We provide a number of examples of attaching plugins to storage adapters in the plugins chapter . Generally, it will be one of: // Manual attachment after you have an instance: $cache->addPlugin(new Serializer()); // Via configuration: $cache = StorageFactory::factory([ 'adapter' => 'filesystem', 'plugins' => [ 'serializer', ], ]);","title":"Serialization"},{"location":"psr16/#deleting-items-and-exceptions","text":"PSR-16 states that the delete() and deleteMultiple() methods should return false if an error occured when deleting the key(s) provided, but true otherwise. Generally, zend-cache storage adapters comply with this. However, it is possible to configure your adapter such that you may get a false positive result from these methods. When an exception is raised and caught during key removal by an adapter, the adapter triggers an event with a Zend\\Cache\\Storage\\ExceptionEvent . Plugins can react to these, and even manipulate the event instance. One such plugin, Zend\\Cache\\Storage\\Plugin\\ExceptionHandler , has a configuration option, throw_exceptions that, when boolean false , will prevent raising the exception. In such cases, adapters will typically return a boolean false anyways, but custom, third-party adapters may not. Additionally, if you add a custom plugin that listens to removal event exceptions and modifies the return value and/or disables throwing the exception, a false positive return value could occur. As such, we recommend that if you wish to use zend-cache to provide a PSR-16 adapter, you audit the plugins you use with your adapter to ensure that you will get consistent, correct behavior for delete() and deleteMultiple() operations.","title":"Deleting items and exceptions"},{"location":"psr6/","text":"PSR-6 Support Since 2.8.0 Overview The Zend\\Cache\\Psr\\CacheItemPool\\CacheItemPoolDecorator provides a PSR-6 compliant wrapper for supported storage adapters. PSR-6 specifies a common interface to cache storage, enabling developers to switch between implementations without having to worry about any behind-the-scenes differences between them. Quick Start To use the pool, instantiate your storage as normal, then pass it to the CacheItemPoolDecorator . use Zend\\Cache\\StorageFactory; use Zend\\Cache\\Psr\\CacheItemPool\\CacheItemPoolDecorator; $storage = StorageFactory::factory([ 'adapter' => [ 'name' => 'apc', 'options' => [], ], ]); $pool = new CacheItemPoolDecorator($storage); // attempt to get an item from cache $item = $pool->getItem('foo'); // check whether item was found if (! $item->isHit()) { // ... // perform expensive operation to calculate $value for 'foo' // ... $item->set($value); $pool->save($item); } // use the value of the item echo $item->get(); Note that you will always get back a CacheItem object, whether it was found in cache or not: this is so false -y values like an empty string, null , or false can be stored. Always check isHit() to determine if the item was found. Supported adapters The PSR-6 specification requires that the underlying storage support time-to-live (TTL), which is set when the item is saved. For this reason the following adapters cannot be used: Dba , Filesystem , Memory and Session . The XCache adapter calculates TTLs based on the request time, not the time the item is actually persisted, which means that it also cannot be used. In addition adapters must support the Zend\\Cache\\FlushableInterface . All the current Zend\\Cache\\Storage\\Adapter s fulfil this requirement. Attempting to use an unsupported adapter will throw an exception implementing Psr\\Cache\\CacheException . The Zend\\Cache\\Psr\\CacheItemPool\\CacheItemPoolDecorator adapter doesn't support driver deferred saves, so cache items are saved on destruct or on explicit commit() call. Quirks APC You cannot set the apc.use_request_time ini setting with the APC adapter: the specification requires that all TTL values are calculated from when the item is actually saved to storage. If this is set when you instantiate the pool it will throw an exception implementing Psr\\Cache\\CacheException . Changing the setting after you have instantiated the pool will result in non-standard behaviour. Logging errors The specification states : While caching is often an important part of application performance, it should never be a critical part of application functionality. Thus, an error in a cache system SHOULD NOT result in application failure. Once you've got your pool instance, almost all exceptions thrown by the storage will be caught and ignored. The only storage exceptions that bubble up implement Psr\\Cache\\InvalidArgumentException and are typically caused by invalid key errors. To be PSR-6 compliant, cache keys must not contain the following characters: {}()/\\@: . However different storage adapters may have further restrictions. Check the documentation for your particular adapter to be sure. We strongly recommend tracking exceptions caught from storage, either by logging them or recording them in some other way. Doing so is as simple as adding an ExceptionHandler plugin . Say you have a PSR-3 compliant logger called $logger : $cacheLogger = function (\\Exception $e) use ($logger) { $message = sprintf( '[CACHE] %s:%s %s \"%s\"', $exception->getFile(), $exception->getLine(), $exception->getCode(), $exception->getMessage() ); $logger->error($message); }; } $storage = StorageFactory::factory([ 'adapter' => [ 'name' => 'apc', ], 'plugins' => [ 'exceptionhandler' => [ 'exception_callback' => $cacheLogger, 'throw_exceptions' => true, ], ], ]); $pool = new CacheItemPoolDecorator($storage); Note that throw_exceptions should always be true (the default) or you will not get the correct return values from calls on the pool such as save() . Supported data types As per the specification , the following data types can be stored in cache: string , integer , float , boolean , null , array , object and be returned as a value with exactly the same type. Not all adapters can natively store all these types. For instance, Redis stores booleans and integers as a string. Where this is the case all values will be automatically run through serialize() on save and unserialize() on get: you do not need to use a Zend\\Cache\\Storage\\Plugin\\Serializer plugin.","title":"PSR-6"},{"location":"psr6/#psr-6-support","text":"Since 2.8.0","title":"PSR-6 Support"},{"location":"psr6/#overview","text":"The Zend\\Cache\\Psr\\CacheItemPool\\CacheItemPoolDecorator provides a PSR-6 compliant wrapper for supported storage adapters. PSR-6 specifies a common interface to cache storage, enabling developers to switch between implementations without having to worry about any behind-the-scenes differences between them.","title":"Overview"},{"location":"psr6/#quick-start","text":"To use the pool, instantiate your storage as normal, then pass it to the CacheItemPoolDecorator . use Zend\\Cache\\StorageFactory; use Zend\\Cache\\Psr\\CacheItemPool\\CacheItemPoolDecorator; $storage = StorageFactory::factory([ 'adapter' => [ 'name' => 'apc', 'options' => [], ], ]); $pool = new CacheItemPoolDecorator($storage); // attempt to get an item from cache $item = $pool->getItem('foo'); // check whether item was found if (! $item->isHit()) { // ... // perform expensive operation to calculate $value for 'foo' // ... $item->set($value); $pool->save($item); } // use the value of the item echo $item->get(); Note that you will always get back a CacheItem object, whether it was found in cache or not: this is so false -y values like an empty string, null , or false can be stored. Always check isHit() to determine if the item was found.","title":"Quick Start"},{"location":"psr6/#supported-adapters","text":"The PSR-6 specification requires that the underlying storage support time-to-live (TTL), which is set when the item is saved. For this reason the following adapters cannot be used: Dba , Filesystem , Memory and Session . The XCache adapter calculates TTLs based on the request time, not the time the item is actually persisted, which means that it also cannot be used. In addition adapters must support the Zend\\Cache\\FlushableInterface . All the current Zend\\Cache\\Storage\\Adapter s fulfil this requirement. Attempting to use an unsupported adapter will throw an exception implementing Psr\\Cache\\CacheException . The Zend\\Cache\\Psr\\CacheItemPool\\CacheItemPoolDecorator adapter doesn't support driver deferred saves, so cache items are saved on destruct or on explicit commit() call.","title":"Supported adapters"},{"location":"psr6/#quirks","text":"","title":"Quirks"},{"location":"psr6/#apc","text":"You cannot set the apc.use_request_time ini setting with the APC adapter: the specification requires that all TTL values are calculated from when the item is actually saved to storage. If this is set when you instantiate the pool it will throw an exception implementing Psr\\Cache\\CacheException . Changing the setting after you have instantiated the pool will result in non-standard behaviour.","title":"APC"},{"location":"psr6/#logging-errors","text":"The specification states : While caching is often an important part of application performance, it should never be a critical part of application functionality. Thus, an error in a cache system SHOULD NOT result in application failure. Once you've got your pool instance, almost all exceptions thrown by the storage will be caught and ignored. The only storage exceptions that bubble up implement Psr\\Cache\\InvalidArgumentException and are typically caused by invalid key errors. To be PSR-6 compliant, cache keys must not contain the following characters: {}()/\\@: . However different storage adapters may have further restrictions. Check the documentation for your particular adapter to be sure. We strongly recommend tracking exceptions caught from storage, either by logging them or recording them in some other way. Doing so is as simple as adding an ExceptionHandler plugin . Say you have a PSR-3 compliant logger called $logger : $cacheLogger = function (\\Exception $e) use ($logger) { $message = sprintf( '[CACHE] %s:%s %s \"%s\"', $exception->getFile(), $exception->getLine(), $exception->getCode(), $exception->getMessage() ); $logger->error($message); }; } $storage = StorageFactory::factory([ 'adapter' => [ 'name' => 'apc', ], 'plugins' => [ 'exceptionhandler' => [ 'exception_callback' => $cacheLogger, 'throw_exceptions' => true, ], ], ]); $pool = new CacheItemPoolDecorator($storage); Note that throw_exceptions should always be true (the default) or you will not get the correct return values from calls on the pool such as save() .","title":"Logging errors"},{"location":"psr6/#supported-data-types","text":"As per the specification , the following data types can be stored in cache: string , integer , float , boolean , null , array , object and be returned as a value with exactly the same type. Not all adapters can natively store all these types. For instance, Redis stores booleans and integers as a string. Where this is the case all values will be automatically run through serialize() on save and unserialize() on get: you do not need to use a Zend\\Cache\\Storage\\Plugin\\Serializer plugin.","title":"Supported data types"},{"location":"pattern/callback-cache/","text":"CallbackCache The callback cache pattern caches the results of arbitrary PHP callables. Quick Start use Zend\\Cache\\PatternFactory; use Zend\\Cache\\Pattern\\PatternOptions; // Via the factory: $callbackCache = PatternFactory::factory('callback', [ 'storage' => 'apc', 'cache_output' => true, ]); // Or the equivalent manual instantiation: $callbackCache = new \\Zend\\Cache\\Pattern\\CallbackCache(); $callbackCache->setOptions(new PatternOptions([ 'storage' => 'apc', 'cache_output' => true, ])); Configuration Options Option Data Type Default Value Description storage string | array | Zend\\Cache\\Storage\\StorageInterface none Adapter used for reading and writing cached data. cache_output boolean true Whether or not to cache callback output. Available Methods In addition to the methods defined in the PatternInterface , this implementation provides the following methods. namespace Zend\\Cache\\Pattern; use Zend\\Cache\\Exception; use Zend\\Stdlib\\ErrorHandler; class CallbackCache extends AbstractPattern { /** * Call the specified callback or get the result from cache * * @param callable $callback A valid callback * @param array $args Callback arguments * @return mixed Result * @throws Exception\\RuntimeException if invalid cached data * @throws \\Exception */ public function call($callback, array $args = []); /** * Intercept method overloading; proxies to call() * * @param string $function Function name to call * @param array $args Function arguments * @return mixed * @throws Exception\\RuntimeException * @throws \\Exception */ public function __call($function, array $args); /** * Generate a unique key in base of a key representing the callback part * and a key representing the arguments part. * * @param callable $callback A valid callback * @param array $args Callback arguments * @return string * @throws Exception\\RuntimeException * @throws Exception\\InvalidArgumentException */ public function generateKey($callback, array $args = []); } Examples Instantiating the callback cache pattern use Zend\\Cache\\PatternFactory; $callbackCache = PatternFactory::factory('callback', [ 'storage' => 'apc' ]);","title":"CallbackCache"},{"location":"pattern/callback-cache/#callbackcache","text":"The callback cache pattern caches the results of arbitrary PHP callables.","title":"CallbackCache"},{"location":"pattern/callback-cache/#quick-start","text":"use Zend\\Cache\\PatternFactory; use Zend\\Cache\\Pattern\\PatternOptions; // Via the factory: $callbackCache = PatternFactory::factory('callback', [ 'storage' => 'apc', 'cache_output' => true, ]); // Or the equivalent manual instantiation: $callbackCache = new \\Zend\\Cache\\Pattern\\CallbackCache(); $callbackCache->setOptions(new PatternOptions([ 'storage' => 'apc', 'cache_output' => true, ]));","title":"Quick Start"},{"location":"pattern/callback-cache/#configuration-options","text":"Option Data Type Default Value Description storage string | array | Zend\\Cache\\Storage\\StorageInterface none Adapter used for reading and writing cached data. cache_output boolean true Whether or not to cache callback output.","title":"Configuration Options"},{"location":"pattern/callback-cache/#available-methods","text":"In addition to the methods defined in the PatternInterface , this implementation provides the following methods. namespace Zend\\Cache\\Pattern; use Zend\\Cache\\Exception; use Zend\\Stdlib\\ErrorHandler; class CallbackCache extends AbstractPattern { /** * Call the specified callback or get the result from cache * * @param callable $callback A valid callback * @param array $args Callback arguments * @return mixed Result * @throws Exception\\RuntimeException if invalid cached data * @throws \\Exception */ public function call($callback, array $args = []); /** * Intercept method overloading; proxies to call() * * @param string $function Function name to call * @param array $args Function arguments * @return mixed * @throws Exception\\RuntimeException * @throws \\Exception */ public function __call($function, array $args); /** * Generate a unique key in base of a key representing the callback part * and a key representing the arguments part. * * @param callable $callback A valid callback * @param array $args Callback arguments * @return string * @throws Exception\\RuntimeException * @throws Exception\\InvalidArgumentException */ public function generateKey($callback, array $args = []); }","title":"Available Methods"},{"location":"pattern/callback-cache/#examples","text":"","title":"Examples"},{"location":"pattern/callback-cache/#instantiating-the-callback-cache-pattern","text":"use Zend\\Cache\\PatternFactory; $callbackCache = PatternFactory::factory('callback', [ 'storage' => 'apc' ]);","title":"Instantiating the callback cache pattern"},{"location":"pattern/capture-cache/","text":"CaptureCache The CaptureCache pattern is useful for generating static resources to return via HTTP request. When used in such a fashion, the web server needs to be configured to run a PHP script generating the requested resource so that subsequent requests for the same resource can be shipped without calling PHP again. This pattern comes with basic logic for managing generated resources. Quick Start For use with an Apache 404 handler: # .htdocs ErrorDocument 404 /index.php // index.php use Zend\\Cache\\PatternFactory; $capture = Zend\\Cache\\PatternFactory::factory('capture', [ 'public_dir' => __DIR__, ]); // Start capturing all output, excluding headers, and write to the public // directory: $capture->start(); // Don't forget to change the HTTP response code header('Status: 200', true, 200); // do stuff to dynamically generate output Configuration Options Option Data Type Default Value Description public_dir string none Location of the public web root directory in which to write output. index_filename string \"index.html\" The name of the index file if only a directory was requested. file_locking bool true Whether or not to lock output files when writing. file_permission int | bool 0600 ( false on Windows) Default permissions for generated output files. dir_permission int | bool 0700 ( false on Windows) Default permissions for generated output directories. umask int bool false Available Methods In addition to the methods exposed in PatternInterface , this implementation exposes the following methods. namespace Zend\\Cache\\Pattern; use Zend\\Cache\\Exception; use Zend\\Stdlib\\ErrorHandler; class CaptureCache extends AbstractPattern { /** * Start the cache. * * @param string $pageId Page identifier * @return void */ public function start($pageId = null); /** * Write a page to the requested path. * * @param string $content * @param null|string $pageId * @throws Exception\\LogicException */ public function set($content, $pageId = null); /** * Retrieve a generated page from the cache. * * @param null|string $pageId * @return string|null * @throws Exception\\LogicException * @throws Exception\\RuntimeException */ public function get($pageId = null); /** * Check if a cache exists for the given page. * * @param null|string $pageId * @throws Exception\\LogicException * @return bool */ public function has($pageId = null); /** * Remove a page from the cache. * * @param null|string $pageId * @throws Exception\\LogicException * @throws Exception\\RuntimeException * @return bool */ public function remove($pageId = null); /** * Clear cached pages that match the specified glob pattern. * * @param string $pattern * @throws Exception\\LogicException */ public function clearByGlob($pattern = '**'); /** * Returns the generated file name. * * @param null|string $pageId * @return string */ public function getFilename($pageId = null); } Examples Scaling images in the web root Using the following Apache 404 configuration: # .htdocs ErrorDocument 404 /index.php Use the following script: // index.php $captureCache = Zend\\Cache\\PatternFactory::factory('capture', [ 'public_dir' => __DIR__, ]); // TODO","title":"CaptureCache"},{"location":"pattern/capture-cache/#capturecache","text":"The CaptureCache pattern is useful for generating static resources to return via HTTP request. When used in such a fashion, the web server needs to be configured to run a PHP script generating the requested resource so that subsequent requests for the same resource can be shipped without calling PHP again. This pattern comes with basic logic for managing generated resources.","title":"CaptureCache"},{"location":"pattern/capture-cache/#quick-start","text":"For use with an Apache 404 handler: # .htdocs ErrorDocument 404 /index.php // index.php use Zend\\Cache\\PatternFactory; $capture = Zend\\Cache\\PatternFactory::factory('capture', [ 'public_dir' => __DIR__, ]); // Start capturing all output, excluding headers, and write to the public // directory: $capture->start(); // Don't forget to change the HTTP response code header('Status: 200', true, 200); // do stuff to dynamically generate output","title":"Quick Start"},{"location":"pattern/capture-cache/#configuration-options","text":"Option Data Type Default Value Description public_dir string none Location of the public web root directory in which to write output. index_filename string \"index.html\" The name of the index file if only a directory was requested. file_locking bool true Whether or not to lock output files when writing. file_permission int | bool 0600 ( false on Windows) Default permissions for generated output files. dir_permission int | bool 0700 ( false on Windows) Default permissions for generated output directories. umask int bool false","title":"Configuration Options"},{"location":"pattern/capture-cache/#available-methods","text":"In addition to the methods exposed in PatternInterface , this implementation exposes the following methods. namespace Zend\\Cache\\Pattern; use Zend\\Cache\\Exception; use Zend\\Stdlib\\ErrorHandler; class CaptureCache extends AbstractPattern { /** * Start the cache. * * @param string $pageId Page identifier * @return void */ public function start($pageId = null); /** * Write a page to the requested path. * * @param string $content * @param null|string $pageId * @throws Exception\\LogicException */ public function set($content, $pageId = null); /** * Retrieve a generated page from the cache. * * @param null|string $pageId * @return string|null * @throws Exception\\LogicException * @throws Exception\\RuntimeException */ public function get($pageId = null); /** * Check if a cache exists for the given page. * * @param null|string $pageId * @throws Exception\\LogicException * @return bool */ public function has($pageId = null); /** * Remove a page from the cache. * * @param null|string $pageId * @throws Exception\\LogicException * @throws Exception\\RuntimeException * @return bool */ public function remove($pageId = null); /** * Clear cached pages that match the specified glob pattern. * * @param string $pattern * @throws Exception\\LogicException */ public function clearByGlob($pattern = '**'); /** * Returns the generated file name. * * @param null|string $pageId * @return string */ public function getFilename($pageId = null); }","title":"Available Methods"},{"location":"pattern/capture-cache/#examples","text":"","title":"Examples"},{"location":"pattern/capture-cache/#scaling-images-in-the-web-root","text":"Using the following Apache 404 configuration: # .htdocs ErrorDocument 404 /index.php Use the following script: // index.php $captureCache = Zend\\Cache\\PatternFactory::factory('capture', [ 'public_dir' => __DIR__, ]); // TODO","title":"Scaling images in the web root"},{"location":"pattern/class-cache/","text":"ClassCache The ClassCache pattern is an extension to the CallbackCache pattern. It has the same methods, but instead generates the callbacks for any public static method invoked on the class being cached, and caches static properties. Quick Start use Zend\\Cache\\PatternFactory; $classCache = PatternFactory::factory('class', [ 'class' => 'MyClass', 'storage' => 'apc', ]); Configuration Options Option Data Type Default Value Description storage string | array | Zend\\Cache\\Storage\\StorageInterface none Adapter used for reading and writing cached data. class string none Name of the class for which to cache method output. cache_output boolean true Whether or not to cache method output. cache_by_default boolean true Cache all method calls by default. class_cache_methods array [] List of methods to cache (if cache_by_default is disabled). class_non_cache_methods array [] List of methods to omit from caching (if cache_by_default is enabled). Available Methods In addition to the methods defined in PatternInterface , this implementation exposes the following methods. namespace Zend\\Cache\\Pattern; use Zend\\Cache; use Zend\\Cache\\Exception; class ClassCache extends CallbackCache { /** * Call and cache a class method * * @param string $method Method name to call * @param array $args Method arguments * @return mixed * @throws Exception\\RuntimeException * @throws \\Exception */ public function call($method, array $args = []); /** * Intercept method overloading; proxies to call(). * * @param string $method Method name to call * @param array $args Method arguments * @return mixed * @throws Exception\\RuntimeException * @throws \\Exception */ public function __call($method, array $args) { return $this->call($method, $args); } /** * Generate a unique key in base of a key representing the callback part * and a key representing the arguments part. * * @param string $method The method * @param array $args Callback arguments * @return string * @throws Exception\\RuntimeException */ public function generateKey($method, array $args = []); /** * Property overloading: set a static property. * * @param string $name * @param mixed $value * @return void * @see http://php.net/manual/language.oop5.overloading.php#language.oop5.overloading.members */ public function __set($name, $value) { $class = $this->getOptions()->getClass(); $class::$name = $value; } /** * Property overloading: get a static property. * * @param string $name * @return mixed * @see http://php.net/manual/language.oop5.overloading.php#language.oop5.overloading.members */ public function __get($name) { $class = $this->getOptions()->getClass(); return $class::$name; } /** * Property overloading: does the named static property exist? * * @param string $name * @return bool */ public function __isset($name) { $class = $this->getOptions()->getClass(); return isset($class::$name); } /** * Property overloading: unset a static property. * * @param string $name * @return void */ public function __unset($name) { $class = $this->getOptions()->getClass(); unset($class::$name); } } Examples Caching of import feeds $cachedFeedReader = Zend\\Cache\\PatternFactory::factory('class', [ 'class' => 'Zend\\Feed\\Reader\\Reader', 'storage' => 'apc', // The feed reader doesn't output anything, // so the output doesn't need to be caught and cached: 'cache_output' => false, ]); $feed = $cachedFeedReader->call(\"import\", array('http://www.planet-php.net/rdf/')); // OR $feed = $cachedFeedReader->import('http://www.planet-php.net/rdf/');","title":"ClassCache"},{"location":"pattern/class-cache/#classcache","text":"The ClassCache pattern is an extension to the CallbackCache pattern. It has the same methods, but instead generates the callbacks for any public static method invoked on the class being cached, and caches static properties.","title":"ClassCache"},{"location":"pattern/class-cache/#quick-start","text":"use Zend\\Cache\\PatternFactory; $classCache = PatternFactory::factory('class', [ 'class' => 'MyClass', 'storage' => 'apc', ]);","title":"Quick Start"},{"location":"pattern/class-cache/#configuration-options","text":"Option Data Type Default Value Description storage string | array | Zend\\Cache\\Storage\\StorageInterface none Adapter used for reading and writing cached data. class string none Name of the class for which to cache method output. cache_output boolean true Whether or not to cache method output. cache_by_default boolean true Cache all method calls by default. class_cache_methods array [] List of methods to cache (if cache_by_default is disabled). class_non_cache_methods array [] List of methods to omit from caching (if cache_by_default is enabled).","title":"Configuration Options"},{"location":"pattern/class-cache/#available-methods","text":"In addition to the methods defined in PatternInterface , this implementation exposes the following methods. namespace Zend\\Cache\\Pattern; use Zend\\Cache; use Zend\\Cache\\Exception; class ClassCache extends CallbackCache { /** * Call and cache a class method * * @param string $method Method name to call * @param array $args Method arguments * @return mixed * @throws Exception\\RuntimeException * @throws \\Exception */ public function call($method, array $args = []); /** * Intercept method overloading; proxies to call(). * * @param string $method Method name to call * @param array $args Method arguments * @return mixed * @throws Exception\\RuntimeException * @throws \\Exception */ public function __call($method, array $args) { return $this->call($method, $args); } /** * Generate a unique key in base of a key representing the callback part * and a key representing the arguments part. * * @param string $method The method * @param array $args Callback arguments * @return string * @throws Exception\\RuntimeException */ public function generateKey($method, array $args = []); /** * Property overloading: set a static property. * * @param string $name * @param mixed $value * @return void * @see http://php.net/manual/language.oop5.overloading.php#language.oop5.overloading.members */ public function __set($name, $value) { $class = $this->getOptions()->getClass(); $class::$name = $value; } /** * Property overloading: get a static property. * * @param string $name * @return mixed * @see http://php.net/manual/language.oop5.overloading.php#language.oop5.overloading.members */ public function __get($name) { $class = $this->getOptions()->getClass(); return $class::$name; } /** * Property overloading: does the named static property exist? * * @param string $name * @return bool */ public function __isset($name) { $class = $this->getOptions()->getClass(); return isset($class::$name); } /** * Property overloading: unset a static property. * * @param string $name * @return void */ public function __unset($name) { $class = $this->getOptions()->getClass(); unset($class::$name); } }","title":"Available Methods"},{"location":"pattern/class-cache/#examples","text":"Caching of import feeds $cachedFeedReader = Zend\\Cache\\PatternFactory::factory('class', [ 'class' => 'Zend\\Feed\\Reader\\Reader', 'storage' => 'apc', // The feed reader doesn't output anything, // so the output doesn't need to be caught and cached: 'cache_output' => false, ]); $feed = $cachedFeedReader->call(\"import\", array('http://www.planet-php.net/rdf/')); // OR $feed = $cachedFeedReader->import('http://www.planet-php.net/rdf/');","title":"Examples"},{"location":"pattern/intro/","text":"Zend\\Cache\\Pattern Cache patterns are configurable objects that solve known performance bottlenecks. Each should be used only in the specific situations they are designed to address. For example, you can use the CallbackCache , ObjectCache , or ClassCache patterns to cache method and function calls; to cache output generation, the OutputCache pattern could assist. All cache patterns implement Zend\\Cache\\Pattern\\PatternInterface , and most extend the abstract class Zend\\Cache\\Pattern\\AbstractPattern , which provides common logic. Configuration is provided via the Zend\\Cache\\Pattern\\PatternOptions class, which can be instantiated with an associative array of options passed to the constructor. To configure a pattern object, you can provide a Zend\\Cache\\Pattern\\PatternOptions instance to the setOptions() method, or provide your options (either as an associative array or PatternOptions instance) to the second argument of the factory. It's also possible to use a single instance of Zend\\Cache\\Pattern\\PatternOptions and pass it to multiple pattern objects. Quick Start Pattern objects can either be created from the provided Zend\\Cache\\PatternFactory , or by instantiating one of the Zend\\Cache\\Pattern\\*Cache classes. // Via the factory: $callbackCache = Zend\\Cache\\PatternFactory::factory('callback', [ 'storage' => 'apc', ]); // Or the equivalent manual instantiation: $callbackCache = new Zend\\Cache\\Pattern\\CallbackCache(); $callbackCache->setOptions(new Zend\\Cache\\Pattern\\PatternOptions([ 'storage' => 'apc', ])); Available Methods The following methods are implemented by Zend\\Cache\\Pattern\\AbstractPattern . Please read documentation of specific patterns to get more information. namespace Zend\\Cache\\Pattern; interface PatternInterface { /** * Set pattern options * * @param PatternOptions $options * @return PatternInterface */ public function setOptions(PatternOptions $options); /** * Get all pattern options * * @return PatternOptions */ public function getOptions(); }","title":"Introduction"},{"location":"pattern/intro/#zend92cache92pattern","text":"Cache patterns are configurable objects that solve known performance bottlenecks. Each should be used only in the specific situations they are designed to address. For example, you can use the CallbackCache , ObjectCache , or ClassCache patterns to cache method and function calls; to cache output generation, the OutputCache pattern could assist. All cache patterns implement Zend\\Cache\\Pattern\\PatternInterface , and most extend the abstract class Zend\\Cache\\Pattern\\AbstractPattern , which provides common logic. Configuration is provided via the Zend\\Cache\\Pattern\\PatternOptions class, which can be instantiated with an associative array of options passed to the constructor. To configure a pattern object, you can provide a Zend\\Cache\\Pattern\\PatternOptions instance to the setOptions() method, or provide your options (either as an associative array or PatternOptions instance) to the second argument of the factory. It's also possible to use a single instance of Zend\\Cache\\Pattern\\PatternOptions and pass it to multiple pattern objects.","title":"Zend\\Cache\\Pattern"},{"location":"pattern/intro/#quick-start","text":"Pattern objects can either be created from the provided Zend\\Cache\\PatternFactory , or by instantiating one of the Zend\\Cache\\Pattern\\*Cache classes. // Via the factory: $callbackCache = Zend\\Cache\\PatternFactory::factory('callback', [ 'storage' => 'apc', ]); // Or the equivalent manual instantiation: $callbackCache = new Zend\\Cache\\Pattern\\CallbackCache(); $callbackCache->setOptions(new Zend\\Cache\\Pattern\\PatternOptions([ 'storage' => 'apc', ]));","title":"Quick Start"},{"location":"pattern/intro/#available-methods","text":"The following methods are implemented by Zend\\Cache\\Pattern\\AbstractPattern . Please read documentation of specific patterns to get more information. namespace Zend\\Cache\\Pattern; interface PatternInterface { /** * Set pattern options * * @param PatternOptions $options * @return PatternInterface */ public function setOptions(PatternOptions $options); /** * Get all pattern options * * @return PatternOptions */ public function getOptions(); }","title":"Available Methods"},{"location":"pattern/object-cache/","text":"ObjectCache The ObjectCache pattern is an extension to the CallbackCache pattern. It has the same methods, but instead caches output from any instance method calls or public properties. Quick Start use stdClass; use Zend\\Cache\\PatternFactory; $object = new stdClass(); $objectCache = PatternFactory::factory('object', [ 'object' => $object, 'storage' => 'apc' ]); Configuration Options Option Data Type Default Value Description storage string | array | Zend\\Cache\\Storage\\StorageInterface none Adapter used for reading and writing cached data. object object none The object for which to cache method calls. object_key null | string Class name of object Hopefully unique! cache_output boolean true Whether or not to cache method output. cache_by_default boolean true Cache all method calls by default. object_cache_methods array [] List of methods to cache (if cache_by_default is disabled). object_non_cache_methods array [] List of methods to blacklist (if cache_by_default is enabled). object_cache_magic_properties boolean false Whether or not to cache properties exposed by method overloading. Available Methods In addition to the methods defined in PatternInterface , this implementation defines the following methods. namespace Zend\\Cache\\Pattern; use Zend\\Cache\\Exception; class ObjectCache extends CallbackCache { /** * Call and cache a class method * * @param string $method Method name to call * @param array $args Method arguments * @return mixed * @throws Exception\\RuntimeException * @throws \\Exception */ public function call($method, array $args = []); /** * Method overloading: proxies to call(). * * @param string $method Method name to call * @param array $args Method arguments * @return mixed * @throws Exception\\RuntimeException * @throws \\Exception */ public function __call($method, array $args); /** * Generate a unique key in base of a key representing the callback part * and a key representing the arguments part. * * @param string $method The method * @param array $args Callback arguments * @return string * @throws Exception\\RuntimeException */ public function generateKey($method, array $args = []); /** * Property overloading: write data to a named property. * * NOTE: * Magic properties will be cached too if the option cacheMagicProperties * is enabled and the property doesn't exist in real. If so it calls __set * and removes cached data of previous __get and __isset calls. * * @param string $name * @param mixed $value * @return void * @see http://php.net/manual/language.oop5.overloading.php#language.oop5.overloading.members */ public function __set($name, $value); /** * Property overloading: read data from a named property. * * NOTE: * Magic properties will be cached too if the option cacheMagicProperties * is enabled and the property doesn't exist in real. If so it calls __get. * * @param string $name * @return mixed * @see http://php.net/manual/language.oop5.overloading.php#language.oop5.overloading.members */ public function __get($name); /** * Property overloading: check if a named property exists. * * NOTE: * Magic properties will be cached too if the option cacheMagicProperties * is enabled and the property doesn't exist in real. If so it calls __get. * * @param string $name * @return bool * @see http://php.net/manual/language.oop5.overloading.php#language.oop5.overloading.members */ public function __isset($name); /** * Property overloading: unset a named property. * * NOTE: * Magic properties will be cached too if the option cacheMagicProperties * is enabled and the property doesn't exist in real. If so it removes * previous cached __isset and __get calls. * * @param string $name * @return void * @see http://php.net/manual/language.oop5.overloading.php#language.oop5.overloading.members */ public function __unset($name); /** * Handle casting to string * * @return string * @see http://php.net/manual/language.oop5.magic.php#language.oop5.magic.tostring */ public function __toString(); /** * Intercept and cache invokable usage. * * @return mixed * @see http://php.net/manual/language.oop5.magic.php#language.oop5.magic.invoke */ public function __invoke(); } Examples Caching a filter $filter = new Zend\\Filter\\RealPath(); $cachedFilter = Zend\\Cache\\PatternFactory::factory('object', [ 'object' => $filter, 'object_key' => 'RealpathFilter', 'storage' => 'apc', // The realpath filter doesn't output anything // so the output don't need to be caught and cached 'cache_output' => false, ]); $path = $cachedFilter->call(\"filter\", ['/www/var/path/../../mypath']); // OR $path = $cachedFilter->filter('/www/var/path/../../mypath');","title":"ObjectCache"},{"location":"pattern/object-cache/#objectcache","text":"The ObjectCache pattern is an extension to the CallbackCache pattern. It has the same methods, but instead caches output from any instance method calls or public properties.","title":"ObjectCache"},{"location":"pattern/object-cache/#quick-start","text":"use stdClass; use Zend\\Cache\\PatternFactory; $object = new stdClass(); $objectCache = PatternFactory::factory('object', [ 'object' => $object, 'storage' => 'apc' ]);","title":"Quick Start"},{"location":"pattern/object-cache/#configuration-options","text":"Option Data Type Default Value Description storage string | array | Zend\\Cache\\Storage\\StorageInterface none Adapter used for reading and writing cached data. object object none The object for which to cache method calls. object_key null | string Class name of object Hopefully unique! cache_output boolean true Whether or not to cache method output. cache_by_default boolean true Cache all method calls by default. object_cache_methods array [] List of methods to cache (if cache_by_default is disabled). object_non_cache_methods array [] List of methods to blacklist (if cache_by_default is enabled). object_cache_magic_properties boolean false Whether or not to cache properties exposed by method overloading.","title":"Configuration Options"},{"location":"pattern/object-cache/#available-methods","text":"In addition to the methods defined in PatternInterface , this implementation defines the following methods. namespace Zend\\Cache\\Pattern; use Zend\\Cache\\Exception; class ObjectCache extends CallbackCache { /** * Call and cache a class method * * @param string $method Method name to call * @param array $args Method arguments * @return mixed * @throws Exception\\RuntimeException * @throws \\Exception */ public function call($method, array $args = []); /** * Method overloading: proxies to call(). * * @param string $method Method name to call * @param array $args Method arguments * @return mixed * @throws Exception\\RuntimeException * @throws \\Exception */ public function __call($method, array $args); /** * Generate a unique key in base of a key representing the callback part * and a key representing the arguments part. * * @param string $method The method * @param array $args Callback arguments * @return string * @throws Exception\\RuntimeException */ public function generateKey($method, array $args = []); /** * Property overloading: write data to a named property. * * NOTE: * Magic properties will be cached too if the option cacheMagicProperties * is enabled and the property doesn't exist in real. If so it calls __set * and removes cached data of previous __get and __isset calls. * * @param string $name * @param mixed $value * @return void * @see http://php.net/manual/language.oop5.overloading.php#language.oop5.overloading.members */ public function __set($name, $value); /** * Property overloading: read data from a named property. * * NOTE: * Magic properties will be cached too if the option cacheMagicProperties * is enabled and the property doesn't exist in real. If so it calls __get. * * @param string $name * @return mixed * @see http://php.net/manual/language.oop5.overloading.php#language.oop5.overloading.members */ public function __get($name); /** * Property overloading: check if a named property exists. * * NOTE: * Magic properties will be cached too if the option cacheMagicProperties * is enabled and the property doesn't exist in real. If so it calls __get. * * @param string $name * @return bool * @see http://php.net/manual/language.oop5.overloading.php#language.oop5.overloading.members */ public function __isset($name); /** * Property overloading: unset a named property. * * NOTE: * Magic properties will be cached too if the option cacheMagicProperties * is enabled and the property doesn't exist in real. If so it removes * previous cached __isset and __get calls. * * @param string $name * @return void * @see http://php.net/manual/language.oop5.overloading.php#language.oop5.overloading.members */ public function __unset($name); /** * Handle casting to string * * @return string * @see http://php.net/manual/language.oop5.magic.php#language.oop5.magic.tostring */ public function __toString(); /** * Intercept and cache invokable usage. * * @return mixed * @see http://php.net/manual/language.oop5.magic.php#language.oop5.magic.invoke */ public function __invoke(); }","title":"Available Methods"},{"location":"pattern/object-cache/#examples","text":"","title":"Examples"},{"location":"pattern/object-cache/#caching-a-filter","text":"$filter = new Zend\\Filter\\RealPath(); $cachedFilter = Zend\\Cache\\PatternFactory::factory('object', [ 'object' => $filter, 'object_key' => 'RealpathFilter', 'storage' => 'apc', // The realpath filter doesn't output anything // so the output don't need to be caught and cached 'cache_output' => false, ]); $path = $cachedFilter->call(\"filter\", ['/www/var/path/../../mypath']); // OR $path = $cachedFilter->filter('/www/var/path/../../mypath');","title":"Caching a filter"},{"location":"pattern/output-cache/","text":"OutputCache The OutputCache pattern caches output between calls to start() and end() . Quick Start use Zend\\Cache\\PatternFactory; $outputCache = PatternFactory::factory('output', [ 'storage' => 'apc' ]); Configuration Options Option Data Type Default Value Description storage string | array | Zend\\Cache\\Storage\\StorageInterface none Adapter used for reading and writing cached data. Available Methods In addition to the methods defined in PatternInterface , this implementation defines the following methods. namespace Zend\\Cache\\Pattern; use Zend\\Cache\\Exception; class OutputCache extends AbstractPattern { /** * If there is a cached item with the given key, display its data, and * return true. Otherwise, start buffering output until end() is called, or * the script ends. * * @param string $key Key * @throws Exception\\MissingKeyException if key is missing * @return bool */ public function start($key); /** * Stop buffering output, write buffered data to the cache using the key * provided to start(), and display the buffer. * * @throws Exception\\RuntimeException if output cache not started or buffering not active * @return bool TRUE on success, FALSE on failure writing to cache */ public function end(); } Examples Caching simple view scripts $outputCache = Zend\\Cache\\PatternFactory::factory('output', [ 'storage' => 'apc', ]); $outputCache->start('mySimpleViewScript'); include '/path/to/view/script.phtml'; $outputCache->end();","title":"OutputCache"},{"location":"pattern/output-cache/#outputcache","text":"The OutputCache pattern caches output between calls to start() and end() .","title":"OutputCache"},{"location":"pattern/output-cache/#quick-start","text":"use Zend\\Cache\\PatternFactory; $outputCache = PatternFactory::factory('output', [ 'storage' => 'apc' ]);","title":"Quick Start"},{"location":"pattern/output-cache/#configuration-options","text":"Option Data Type Default Value Description storage string | array | Zend\\Cache\\Storage\\StorageInterface none Adapter used for reading and writing cached data.","title":"Configuration Options"},{"location":"pattern/output-cache/#available-methods","text":"In addition to the methods defined in PatternInterface , this implementation defines the following methods. namespace Zend\\Cache\\Pattern; use Zend\\Cache\\Exception; class OutputCache extends AbstractPattern { /** * If there is a cached item with the given key, display its data, and * return true. Otherwise, start buffering output until end() is called, or * the script ends. * * @param string $key Key * @throws Exception\\MissingKeyException if key is missing * @return bool */ public function start($key); /** * Stop buffering output, write buffered data to the cache using the key * provided to start(), and display the buffer. * * @throws Exception\\RuntimeException if output cache not started or buffering not active * @return bool TRUE on success, FALSE on failure writing to cache */ public function end(); }","title":"Available Methods"},{"location":"pattern/output-cache/#examples","text":"","title":"Examples"},{"location":"pattern/output-cache/#caching-simple-view-scripts","text":"$outputCache = Zend\\Cache\\PatternFactory::factory('output', [ 'storage' => 'apc', ]); $outputCache->start('mySimpleViewScript'); include '/path/to/view/script.phtml'; $outputCache->end();","title":"Caching simple view scripts"},{"location":"storage/adapter/","text":"Adapters Storage adapters are wrappers for real storage resources such as memory or the filesystem, using the well known adapter pattern. They come with tons of methods to read, write, and modify stored items, and to get information about stored items and the storage. All adapters implement Zend\\Cache\\Storage\\StorageInterface , and most extend Zend\\Cache\\Storage\\Adapter\\AbstractAdapter , which provides a foundation of common logic. Configuration is handled by either Zend\\Cache\\Storage\\Adapter\\AdapterOptions , or an adapter-specific options class if it exists. You may pass the options instance to the class at instantiation, via the setOptions() method, or, alternately, pass an associative array of options in either place (internally, these are then passed to an options class instance). Alternately, you can pass either the options instance or associative array to the Zend\\Cache\\StorageFactory::factory method. Many methods throw exceptions Because many caching operations throw an exception on error, you need to catch them. You can do so manually, or you can use the plugin Zend\\Cache\\Storage\\Plugin\\ExceptionHandler with throw_exceptions set to false to automatically catch them. You can also define an exception_callback to log exceptions. Quick Start Caching adapters can either be created from the provided Zend\\Cache\\StorageFactory , or by instantiating one of the Zend\\Cache\\Storage\\Adapter\\* classes. To make life easier, the Zend\\Cache\\StorageFactory comes with a factory() method to create an adapter and all requested plugins at once. use Zend\\Cache\\StorageFactory; // Via factory: $cache = StorageFactory::factory([ 'adapter' => [ 'name' => 'apc', 'options' => ['ttl' => 3600], ], 'plugins' => [ 'exception_handler' => ['throw_exceptions' => false], ], ]); // Alternately, create the adapter and plugin separately: $cache = StorageFactory::adapterFactory('apc', ['ttl' => 3600]); $plugin = StorageFactory::pluginFactory('exception_handler', [ 'throw_exceptions' => false, ]); $cache->addPlugin($plugin); // Or do it completely manually: $cache = new Zend\\Cache\\Storage\\Adapter\\Apc(); $cache->getOptions()->setTtl(3600); $plugin = new Zend\\Cache\\Storage\\Plugin\\ExceptionHandler(); $plugin->getOptions()->setThrowExceptions(false); $cache->addPlugin($plugin); Basic Configuration Options The following configuration options are defined by Zend\\Cache\\Storage\\Adapter\\AdapterOptions and are available for every supported adapter. Adapter-specific configuration options are described on adapter level below. Option Data Type Default Value Description ttl integer 0 Time to live namespace string \u201czfcache\u201d The \u201cnamespace\u201d in which cache items will live key_pattern null|string null Pattern against which to validate cache keys readable boolean true Enable/Disable reading data from cache writable boolean true Enable/Disable writing data to cache The StorageInterface Zend\\Cache\\Storage\\StorageInterface is the basic interface implemented by all storage adapters. namespace Zend\\Cache\\Storage; use Traversable; interface StorageInterface { /** * Set options. * * @param array|Traversable|Adapter\\AdapterOptions $options * @return StorageInterface Fluent interface */ public function setOptions($options); /** * Get options * * @return Adapter\\AdapterOptions */ public function getOptions(); /* reading */ /** * Get an item. * * @param string $key * @param bool $success * @param mixed $casToken * @return mixed Data on success, null on failure * @throws \\Zend\\Cache\\Exception\\ExceptionInterface */ public function getItem($key, & $success = null, & $casToken = null); /** * Get multiple items. * * @param array $keys * @return array Associative array of keys and values * @throws \\Zend\\Cache\\Exception\\ExceptionInterface */ public function getItems(array $keys); /** * Test if an item exists. * * @param string $key * @return bool * @throws \\Zend\\Cache\\Exception\\ExceptionInterface */ public function hasItem($key); /** * Test multiple items. * * @param array $keys * @return array Array of found keys * @throws \\Zend\\Cache\\Exception\\ExceptionInterface */ public function hasItems(array $keys); /** * Get metadata of an item. * * @param string $key * @return array|bool Metadata on success, false on failure * @throws \\Zend\\Cache\\Exception\\ExceptionInterface */ public function getMetadata($key); /** * Get multiple metadata * * @param array $keys * @return array Associative array of keys and metadata * @throws \\Zend\\Cache\\Exception\\ExceptionInterface */ public function getMetadatas(array $keys); /* writing */ /** * Store an item. * * @param string $key * @param mixed $value * @return bool * @throws \\Zend\\Cache\\Exception\\ExceptionInterface */ public function setItem($key, $value); /** * Store multiple items. * * @param array $keyValuePairs * @return array Array of not stored keys * @throws \\Zend\\Cache\\Exception\\ExceptionInterface */ public function setItems(array $keyValuePairs); /** * Add an item. * * @param string $key * @param mixed $value * @return bool * @throws \\Zend\\Cache\\Exception\\ExceptionInterface */ public function addItem($key, $value); /** * Add multiple items. * * @param array $keyValuePairs * @return array Array of not stored keys * @throws \\Zend\\Cache\\Exception\\ExceptionInterface */ public function addItems(array $keyValuePairs); /** * Replace an existing item. * * @param string $key * @param mixed $value * @return bool * @throws \\Zend\\Cache\\Exception\\ExceptionInterface */ public function replaceItem($key, $value); /** * Replace multiple existing items. * * @param array $keyValuePairs * @return array Array of not stored keys * @throws \\Zend\\Cache\\Exception\\ExceptionInterface */ public function replaceItems(array $keyValuePairs); /** * Set an item only if token matches * * It uses the token received from getItem() to check if the item has * changed before overwriting it. * * @param mixed $token * @param string $key * @param mixed $value * @return bool * @throws \\Zend\\Cache\\Exception\\ExceptionInterface * @see getItem() * @see setItem() */ public function checkAndSetItem($token, $key, $value); /** * Reset lifetime of an item * * @param string $key * @return bool * @throws \\Zend\\Cache\\Exception\\ExceptionInterface */ public function touchItem($key); /** * Reset lifetime of multiple items. * * @param array $keys * @return array Array of not updated keys * @throws \\Zend\\Cache\\Exception\\ExceptionInterface */ public function touchItems(array $keys); /** * Remove an item. * * @param string $key * @return bool * @throws \\Zend\\Cache\\Exception\\ExceptionInterface */ public function removeItem($key); /** * Remove multiple items. * * @param array $keys * @return array Array of not removed keys * @throws \\Zend\\Cache\\Exception\\ExceptionInterface */ public function removeItems(array $keys); /** * Increment an item. * * @param string $key * @param int $value * @return int|bool The new value on success, false on failure * @throws \\Zend\\Cache\\Exception\\ExceptionInterface */ public function incrementItem($key, $value); /** * Increment multiple items. * * @param array $keyValuePairs * @return array Associative array of keys and new values * @throws \\Zend\\Cache\\Exception\\ExceptionInterface */ public function incrementItems(array $keyValuePairs); /** * Decrement an item. * * @param string $key * @param int $value * @return int|bool The new value on success, false on failure * @throws \\Zend\\Cache\\Exception\\ExceptionInterface */ public function decrementItem($key, $value); /** * Decrement multiple items. * * @param array $keyValuePairs * @return array Associative array of keys and new values * @throws \\Zend\\Cache\\Exception\\ExceptionInterface */ public function decrementItems(array $keyValuePairs); /* status */ /** * Capabilities of this storage * * @return Capabilities */ public function getCapabilities(); } The AvailableSpaceCapableInterface Zend\\Cache\\Storage\\AvailableSpaceCapableInterface implements a method to allow retrieving the current available space remaining in storage. namespace Zend\\Cache\\Storage; interface AvailableSpaceCapableInterface { /** * Get available space in bytes * * @return int|float */ public function getAvailableSpace(); } The TotalSpaceCapableInterface Zend\\Cache\\Storage\\TotalSpaceCapableInterface implements a method to allow retrieving the total storage space. namespace Zend\\Cache\\Storage; interface TotalSpaceCapableInterface { /** * Get total space in bytes * * @return int|float */ public function getTotalSpace(); } The ClearByNamespaceInterface Zend\\Cache\\Storage\\ClearByNamespaceInterface implements a method to allow clearing all cached items within a given namespace. namespace Zend\\Cache\\Storage; interface ClearByNamespaceInterface { /** * Remove items of given namespace * * @param string $namespace * @return bool */ public function clearByNamespace($namespace); } The ClearByPrefixInterface Zend\\Cache\\Storage\\ClearByPrefixInterface implements a method to allow clearing all cached items that have a given prefix (within the currently configured namespace). namespace Zend\\Cache\\Storage; interface ClearByPrefixInterface { /** * Remove items matching given prefix * * @param string $prefix * @return bool */ public function clearByPrefix($prefix); } The ClearExpiredInterface Zend\\Cache\\Storage\\ClearExpiredInterface implements a method to allow clearing all expired items (within the current configured namespace). namespace Zend\\Cache\\Storage; interface ClearExpiredInterface { /** * Remove expired items * * @return bool */ public function clearExpired(); } The FlushableInterface Zend\\Cache\\Storage\\FlushableInterface implements a method for flushing the entire cache storage. namespace Zend\\Cache\\Storage; interface FlushableInterface { /** * Flush the whole storage * * @return bool */ public function flush(); } The IterableInterface Zend\\Cache\\Storage\\IterableInterface implements a method for retrieving an iterator of all items in storage. It extends IteratorAggregate , so it's possible to directly iterate over the storage implementations that implement this interface using foreach . namespace Zend\\Cache\\Storage; use IteratorAggregate; /** * * @method IteratorInterface getIterator() Get the storage iterator */ interface IterableInterface extends IteratorAggregate { /** * @return \\Traversable */ public function getIterator(); } The OptimizableInterface Zend\\Cache\\Storage\\OptimizableInterface implements a method for running optimization processes on the storage adapter. namespace Zend\\Cache\\Storage; interface OptimizableInterface { /** * Optimize the storage * * @return bool */ public function optimize(); } The TaggableInterface Zend\\Cache\\Storage\\TaggableInterface implements methods for tagging items, and cleaning (expiring) items matching tags. namespace Zend\\Cache\\Storage; interface TaggableInterface { /** * Set tags to an item by given key. * An empty array will remove all tags. * * @param string $key * @param string[] $tags * @return bool */ public function setTags($key, array $tags); /** * Get tags of an item by given key * * @param string $key * @return string[]|FALSE */ public function getTags($key); /** * Remove items matching given tags. * * If $disjunction only one of the given tags must match * else all given tags must match. * * @param string[] $tags * @param bool $disjunction * @return bool */ public function clearByTags(array $tags, $disjunction = false); } The Apc Adapter Zend\\Cache\\Storage\\Adapter\\Apc stores cache items in shared memory through the PHP extension APC (Alternative PHP Cache). This adapter implements the following interfaces: Zend\\Cache\\Storage\\StorageInterface Zend\\Cache\\Storage\\AvailableSpaceCapableInterface Zend\\Cache\\Storage\\ClearByNamespaceInterface Zend\\Cache\\Storage\\ClearByPrefixInterface Zend\\Cache\\Storage\\FlushableInterface Zend\\Cache\\Storage\\IterableInterface Zend\\Cache\\Storage\\TotalSpaceCapableInterface Capabilities Capability Value supportedDatatypes null , bool , int , float , string , array (serialized), object (serialized) supportedMetadata internal_key, atime, ctime, mtime, rtime, size, hits, ttl minTtl 1 maxTtl 0 staticTtl true ttlPrecision 1 useRequestTime value of apc.use_request_time from php.ini lockOnExpire 0 maxKeyLength 5182 namespaceIsPrefix true namespaceSeparator Option value of namespace_separator Adapter specific options Name Data Type Default Value Description namespace_separator string \":\" A separator for the namespace and prefix. The Dba Adapter Zend\\Cache\\Storage\\Adapter\\Dba stores cache items into dbm -like databases using the PHP extension dba . This adapter implements the following interfaces: Zend\\Cache\\Storage\\StorageInterface Zend\\Cache\\Storage\\AvailableSpaceCapableInterface Zend\\Cache\\Storage\\ClearByNamespaceInterface Zend\\Cache\\Storage\\ClearByPrefixInterface Zend\\Cache\\Storage\\FlushableInterface Zend\\Cache\\Storage\\IterableInterface Zend\\Cache\\Storage\\OptimizableInterface Zend\\Cache\\Storage\\TotalSpaceCapableInterface Capabilities Capability Value supportedDatatypes string , null => string , boolean => string , integer => string , double => string supportedMetadata none minTtl 0 maxKeyLength 0 namespaceIsPrefix true namespaceSeparator Option value of namespace_separator Adapter specific options Name Data Type Default Value Description namespace_separator string \":\" A separator for the namespace and prefix. pathname string \"\" Pathname to the database file. mode string \"c\" The mode with which to open the database; please read dba_open for more information. handler string \"flatfile\" The name of the handler which shall be used for accessing the database. This adapter doesn't support automatic expiry Because this adapter doesn't support automatic expiry, it's very important to clean outdated items periodically! The Filesystem Adapter Zend\\Cache\\Storage\\Adapter\\Filesystem stores cache items on the filesystem. This adapter implements the following interfaces: Zend\\Cache\\Storage\\StorageInterface Zend\\Cache\\Storage\\AvailableSpaceCapableInterface Zend\\Cache\\Storage\\ClearByNamespaceInterface Zend\\Cache\\Storage\\ClearByPrefixInterface Zend\\Cache\\Storage\\ClearExpiredInterface Zend\\Cache\\Storage\\FlushableInterface Zend\\Cache\\Storage\\IterableInterface Zend\\Cache\\Storage\\OptimizableInterface Zend\\Cache\\Storage\\TaggableInterface Zend\\Cache\\Storage\\TotalSpaceCapableInterface Capabilities Capability Value supportedDatatypes string , null => string , boolean => string , integer => string , double => string supportedMetadata mtime, filespec, atime, ctime minTtl 1 maxTtl 0 staticTtl false ttlPrecision 1 useRequestTime false lockOnExpire 0 maxKeyLength 251 namespaceIsPrefix true namespaceSeparator Option value of namespace_separator Adapter specific options Name Data Type Default Value Description namespace_separator string \":\" A separator for the namespace and prefix cache_dir string \"\" Directory to store cache files. clear_stat_cache boolean true Call clearstatcache() enabled? dir_level integer 1 Defines how much sub-directories should be created. dir_permission integer false 0700 Set explicit permission on creating new directories. file_locking boolean true Lock files on writing. file_permission integer false 0600 Set explicit permission on creating new files. key_pattern string /^[a-z0-9_\\+\\-]*$/Di Validate key against pattern. no_atime boolean true Don\u2019t get \u2018fileatime\u2019 as \u2018atime\u2019 on metadata. no_ctime boolean true Don\u2019t get \u2018filectime\u2019 as \u2018ctime\u2019 on metadata. umask integer|false false Use umask to set file and directory permissions. suffix string dat Suffix for cache files tag_suffix string tag Suffix for tag files Note: the suffix and tag_suffix options will be escaped in order to be safe for glob operations. The Memcached Adapter Zend\\Cache\\Storage\\Adapter\\Memcached stores cache items over the memcached protocol, using the PHP extension memcached , based on Libmemcached . This adapter implements the following interfaces: Zend\\Cache\\Storage\\StorageInterface Zend\\Cache\\Storage\\AvailableSpaceCapableInterface Zend\\Cache\\Storage\\FlushableInterface Zend\\Cache\\Storage\\TotalSpaceCapableInterface Capabilities Capability Value supportedDatatypes null , boolean , integer , double , string , array (serialized), object (serialized) supportedMetadata none minTtl 1 maxTtl 0 staticTtl true ttlPrecision 1 useRequestTime false lockOnExpire 0 maxKeyLength 255 namespaceIsPrefix true namespaceSeparator none Adapter specific options Name Data Type Default Value Description servers array [] List of servers in the format [] = [string host, integer port] lib_options array [] Associative array of Libmemcached options where the array key is the option name (without the prefix OPT_ ) or the constant value. The array value is the option value. Please read the memcached setOption() page for more information The Redis Adapter Zend\\Cache\\Storage\\Adapter\\Redis stores cache items over the redis protocol using the PHP extension redis . This adapter implements the following interfaces: Zend\\Cache\\Storage\\FlushableInterface Zend\\Cache\\Storage\\TotalSpaceCapableInterface Capabilities Capability Value supportedDatatypes string , array (serialized), object (serialized) supportedMetadata none minTtl 1 maxTtl 0 staticTtl true ttlPrecision 1 useRequestTime false lockOnExpire 0 maxKeyLength 255 namespaceIsPrefix true namespaceSeparator none Adapter specific options Name Data Type Default Value Description database integer 0 Set database identifier. lib_options array [] Associative array of redis options where the array key is the option name. namespace_separator string \":\" A separator for the namespace and prefix. password string \"\" Set password. persistent_id string Set persistent id (name of the connection, leave blank to not use a persistent connection). resource_manager string Set the redis resource manager to use server See below. server can be described as any of the following: URI: /path/to/sock.sock Associative array: ['host' => <host>[, 'port' => <port>[, 'timeout' => <timeout>]]] List: [<host>[, <port>, [, <timeout>]]] The Memory Adapter The Zend\\Cache\\Storage\\Adapter\\Memory stores items in-memory in the current process only. This adapter implements the following interfaces: Zend\\Cache\\Storage\\StorageInterface Zend\\Cache\\Storage\\AvailableSpaceCapableInterface Zend\\Cache\\Storage\\ClearByPrefixInterface Zend\\Cache\\Storage\\ClearExpiredInterface Zend\\Cache\\Storage\\FlushableInterface Zend\\Cache\\Storage\\IterableInterface Zend\\Cache\\Storage\\TaggableInterface Zend\\Cache\\Storage\\TotalSpaceCapableInterface Capabilities Capability Value supportedDatatypes string , null , boolean , integer , double , array , object , resource supportedMetadata mtime minTtl 1 maxTtl Value of PHP_INT_MAX staticTtl false ttlPrecision 0.05 useRequestTime false lockOnExpire 0 maxKeyLength 0 namespaceIsPrefix false Adapter specific options Name Data Type Default Value Description memory_limit string|integer 50% of memory_limit INI value Limit of how much memory can PHP allocate to allow store items. Memory limit The adapter has the following behavior with regards to the memory limit: If the consumed memory exceeds the limit provided, an OutOfSpaceException is thrown. A number less the or equal to zero disables the memory limit. When a value is provided for the memory limit, the value is measured in bytes. Shorthand notation may also be provided. Current process only! All stored items will be lost on termination of the script. For web-facing requests, this typically means the cache is volatile. The MongoDB Adapter Zend\\Cache\\Storage\\Adapter\\MongoDB stores cache items using MongoDB, via either the PHP extension mongo , or a MongoDB polyfill library, such as Mongofill . ext-mongodb If you are using the mongodb extension (vs the mongo extension), you will need to use the ExtMongoDb adapter instead. This adapter implements the following interfaces: Zend\\Cache\\Storage\\FlushableInterface Capabilities Capability Value supportedDatatypes string , null , boolean , integer , double , array supportedMetadata _id minTtl 0 maxTtl 0 staticTtl true ttlPrecision 1 useRequestTime false lockOnExpire 0 maxKeyLength 255 namespaceIsPrefix true namespaceSeparator Adapter specific options Name Data Type Default Value Description lib_option array Associative array of options where the array key is the option name. namespace_separator string \":\" A separator for the namespace and prefix. Available keys for lib_option include: Key Default Description server mongodb://localhost:27017 The MongoDB server connection string (see the MongoClient docs ). database zend Name of the database to use; MongoDB will create this database if it does not exist. collection cache Name of the collection to use; MongoDB will create this collection if it does not exist. connectionOptions ['fsync' => false, 'journal' => true] Associative array of options to pass to MongoClient (see the MongoClient docs ). driverOptions [] Associative array of driver options to pass to MongoClient (see the MongoClient docs ). The ExtMongoDB Adapter Since 2.8.0 Zend\\Cache\\Storage\\Adapter\\ExtMongoDB stores cache items using the mongodb extension, and requires that the MongoDB PHP Client library is also installed. You can install the client library using the following: $ composer require mongodb/mongodb ext-mongo If you are using the mongo extension (vs the mongodb extension), you will need to use the MongoDb adapter instead. This adapter implements the following interfaces: Zend\\Cache\\Storage\\FlushableInterface Capabilities Capability Value supportedDatatypes string , null , boolean , integer , double , array supportedMetadata _id minTtl 0 maxTtl 0 staticTtl true ttlPrecision 1 useRequestTime false lockOnExpire 0 maxKeyLength 255 namespaceIsPrefix true namespaceSeparator Adapter specific options Name Data Type Default Value Description lib_option array Associative array of options where the array key is the option name. namespace_separator string \":\" A separator for the namespace and prefix. Available keys for lib_option include: Key Default Description server mongodb://localhost:27017 The MongoDB server connection string (see the MongoDB\\Client docs ). database zend Name of the database to use; MongoDB will create this database if it does not exist. collection cache Name of the collection to use; MongoDB will create this collection if it does not exist. connectionOptions ['fsync' => false, 'journal' => true] Associative array of URI options (such as authentication credentials or query string parameters) to pass to MongoDB\\\\Client (see the MongoDB\\Client docs ). driverOptions [] Associative array of driver options to pass to MongoDB\\\\Client (see the MongoDB\\Client docs ). The WinCache Adapter Zend\\Cache\\Storage\\Adapter\\WinCache stores cache items into shared memory through the PHP extension WinCache . This adapter implements the following interfaces: Zend\\Cache\\Storage\\StorageInterface Zend\\Cache\\Storage\\AvailableSpaceCapableInterface Zend\\Cache\\Storage\\FlushableInterface Zend\\Cache\\Storage\\TotalSpaceCapableInterface Capabilities Capability Value supportedDatatypes null , boolean , integer , double , string , array (serialized), object (serialized) supportedMetadata internal_key, ttl, hits, size minTtl 1 maxTtl 0 staticTtl true ttlPrecision 1 useRequestTime apc.use_request_time php.ini value. lockOnExpire 0 namespaceIsPrefix true namespaceSeparator Option value of namespace_separator Adapter specific options Name Data Type Default Value Description namespace_separator string \":\" A separator for the namespace and prefix. The XCache Adapter Zend\\Cache\\Storage\\Adapter\\XCache stores cache items into shared memory through the PHP extension XCache . This adapter implements the following interfaces: Zend\\Cache\\Storage\\StorageInterface Zend\\Cache\\Storage\\AvailableSpaceCapableInterface Zend\\Cache\\Storage\\ClearByNamespaceInterface Zend\\Cache\\Storage\\ClearByPrefixInterface Zend\\Cache\\Storage\\FlushableInterface Zend\\Cache\\Storage\\IterableInterface Zend\\Cache\\Storage\\TotalSpaceCapableInterface Capabilities Capability Value supportedDatatypes boolean , integer , double , string , array (serialized), object (serialized) supportedMetadata internal_key, size, refcount, hits, ctime, atime, hvalue minTtl 1 maxTtl xcache.var_maxttl php.ini value staticTtl true ttlPrecision 1 useRequestTime true lockOnExpire 0 maxKeyLength 5182 namespaceIsPrefix true namespaceSeparator Option value of namespace_separator Adapter specific options Name Data Type Default Value Description namespace_separator string \":\" A separator for the namespace and prefix. admin_auth boolean false Enable admin authentication by configuration options admin_user and admin_pass . This makes XCache administration functions accessible without the need of HTTP-Authentication if xcache.admin.enable_auth is enabled. admin_user string \"\" The username of xcache.admin.user . admin_pass string \"\" The password of xcache.admin.pass in plain text. The ZendServerDisk Adapter Zend\\Cache\\Storage\\Adapter\\ZendServerDisk stores cache items on the filesystem using the Zend Server Data Caching API . This adapter implements the following interfaces: Zend\\Cache\\Storage\\StorageInterface Zend\\Cache\\Storage\\AvailableSpaceCapableInterface Zend\\Cache\\Storage\\ClearByNamespaceInterface Zend\\Cache\\Storage\\FlushableInterface Zend\\Cache\\Storage\\TotalSpaceCapableInterface Capabilities Capability Value supportedDatatypes null , boolean , integer , double , string , array (serialized), object (serialized) supportedMetadata none minTtl 1 maxTtl 0 maxKeyLength 0 staticTtl true ttlPrecision 1 useRequestTime false lockOnExpire if 'zend_datacache.lock_on_expire' is enabled 120 else 0 namespaceIsPrefix true namespaceSeparator :: The ZendServerShm Adapter Zend\\Cache\\Storage\\Adapter\\ZendServerShm stores cache items in shared memory through the Zend Server Data Caching API . This adapter implements the following interfaces: Zend\\Cache\\Storage\\StorageInterface Zend\\Cache\\Storage\\ClearByNamespaceInterface Zend\\Cache\\Storage\\FlushableInterface Zend\\Cache\\Storage\\TotalSpaceCapableInterface Capabilities Capability Value supportedDatatypes null , boolean , integer , double , string , array (serialized), object (serialized) supportedMetadata none minTtl 1 maxTtl 0 maxKeyLength 0 staticTtl true ttlPrecision 1 useRequestTime false lockOnExpire if 'zend_datacache.lock_on_expire' is enabled 120 else 0 namespaceIsPrefix true namespaceSeparator :: Examples Basic usage use Zend\\Cache\\StorageFactory; $cache = StorageFactory::factory([ 'adapter' => [ 'name' => 'filesystem' ], 'plugins' => [ // Don't throw exceptions on cache errors 'exception_handler' => [ 'throw_exceptions' => false ], ], ]); $key = 'unique-cache-key'; $result = $cache->getItem($key, $success); if (! $success) { $result = doExpensiveStuff(); $cache->setItem($key, $result); } Get multiple rows from a database use Zend\\Cache\\StorageFactory; // Instantiate the cache instance using a namespace for the same type of items $cache = StorageFactory::factory([ 'adapter' => [ 'name' => 'filesystem', // With a namespace, we can indicate the same type of items, // so we can simply use the database id as the cache key 'options' => [ 'namespace' => 'dbtable', ], ], 'plugins' => [ // Don't throw exceptions on cache errors 'exception_handler' => [ 'throw_exceptions' => false, ], // We store database rows on filesystem so we need to serialize them 'Serializer', ], ]); // Load two rows from cache if possible $ids = [1, 2]; $results = $cache->getItems($ids); if (count($results) < count($ids)) { // Load rows from db if loading from cache failed $missingIds = array_diff($ids, array_keys($results)); $missingResults = []; $query = 'SELECT * FROM dbtable WHERE id IN (' . implode(',', $missingIds) . ')'; foreach ($pdo->query($query, PDO::FETCH_ASSOC) as $row) { $missingResults[ $row['id'] ] = $row; } // Update cache items of the loaded rows from db $cache->setItems($missingResults); // merge results from cache and db $results = array_merge($results, $missingResults); }","title":"Adapters"},{"location":"storage/adapter/#adapters","text":"Storage adapters are wrappers for real storage resources such as memory or the filesystem, using the well known adapter pattern. They come with tons of methods to read, write, and modify stored items, and to get information about stored items and the storage. All adapters implement Zend\\Cache\\Storage\\StorageInterface , and most extend Zend\\Cache\\Storage\\Adapter\\AbstractAdapter , which provides a foundation of common logic. Configuration is handled by either Zend\\Cache\\Storage\\Adapter\\AdapterOptions , or an adapter-specific options class if it exists. You may pass the options instance to the class at instantiation, via the setOptions() method, or, alternately, pass an associative array of options in either place (internally, these are then passed to an options class instance). Alternately, you can pass either the options instance or associative array to the Zend\\Cache\\StorageFactory::factory method.","title":"Adapters"},{"location":"storage/adapter/#many-methods-throw-exceptions","text":"Because many caching operations throw an exception on error, you need to catch them. You can do so manually, or you can use the plugin Zend\\Cache\\Storage\\Plugin\\ExceptionHandler with throw_exceptions set to false to automatically catch them. You can also define an exception_callback to log exceptions.","title":"Many methods throw exceptions"},{"location":"storage/adapter/#quick-start","text":"Caching adapters can either be created from the provided Zend\\Cache\\StorageFactory , or by instantiating one of the Zend\\Cache\\Storage\\Adapter\\* classes. To make life easier, the Zend\\Cache\\StorageFactory comes with a factory() method to create an adapter and all requested plugins at once. use Zend\\Cache\\StorageFactory; // Via factory: $cache = StorageFactory::factory([ 'adapter' => [ 'name' => 'apc', 'options' => ['ttl' => 3600], ], 'plugins' => [ 'exception_handler' => ['throw_exceptions' => false], ], ]); // Alternately, create the adapter and plugin separately: $cache = StorageFactory::adapterFactory('apc', ['ttl' => 3600]); $plugin = StorageFactory::pluginFactory('exception_handler', [ 'throw_exceptions' => false, ]); $cache->addPlugin($plugin); // Or do it completely manually: $cache = new Zend\\Cache\\Storage\\Adapter\\Apc(); $cache->getOptions()->setTtl(3600); $plugin = new Zend\\Cache\\Storage\\Plugin\\ExceptionHandler(); $plugin->getOptions()->setThrowExceptions(false); $cache->addPlugin($plugin);","title":"Quick Start"},{"location":"storage/adapter/#basic-configuration-options","text":"The following configuration options are defined by Zend\\Cache\\Storage\\Adapter\\AdapterOptions and are available for every supported adapter. Adapter-specific configuration options are described on adapter level below. Option Data Type Default Value Description ttl integer 0 Time to live namespace string \u201czfcache\u201d The \u201cnamespace\u201d in which cache items will live key_pattern null|string null Pattern against which to validate cache keys readable boolean true Enable/Disable reading data from cache writable boolean true Enable/Disable writing data to cache","title":"Basic Configuration Options"},{"location":"storage/adapter/#the-storageinterface","text":"Zend\\Cache\\Storage\\StorageInterface is the basic interface implemented by all storage adapters. namespace Zend\\Cache\\Storage; use Traversable; interface StorageInterface { /** * Set options. * * @param array|Traversable|Adapter\\AdapterOptions $options * @return StorageInterface Fluent interface */ public function setOptions($options); /** * Get options * * @return Adapter\\AdapterOptions */ public function getOptions(); /* reading */ /** * Get an item. * * @param string $key * @param bool $success * @param mixed $casToken * @return mixed Data on success, null on failure * @throws \\Zend\\Cache\\Exception\\ExceptionInterface */ public function getItem($key, & $success = null, & $casToken = null); /** * Get multiple items. * * @param array $keys * @return array Associative array of keys and values * @throws \\Zend\\Cache\\Exception\\ExceptionInterface */ public function getItems(array $keys); /** * Test if an item exists. * * @param string $key * @return bool * @throws \\Zend\\Cache\\Exception\\ExceptionInterface */ public function hasItem($key); /** * Test multiple items. * * @param array $keys * @return array Array of found keys * @throws \\Zend\\Cache\\Exception\\ExceptionInterface */ public function hasItems(array $keys); /** * Get metadata of an item. * * @param string $key * @return array|bool Metadata on success, false on failure * @throws \\Zend\\Cache\\Exception\\ExceptionInterface */ public function getMetadata($key); /** * Get multiple metadata * * @param array $keys * @return array Associative array of keys and metadata * @throws \\Zend\\Cache\\Exception\\ExceptionInterface */ public function getMetadatas(array $keys); /* writing */ /** * Store an item. * * @param string $key * @param mixed $value * @return bool * @throws \\Zend\\Cache\\Exception\\ExceptionInterface */ public function setItem($key, $value); /** * Store multiple items. * * @param array $keyValuePairs * @return array Array of not stored keys * @throws \\Zend\\Cache\\Exception\\ExceptionInterface */ public function setItems(array $keyValuePairs); /** * Add an item. * * @param string $key * @param mixed $value * @return bool * @throws \\Zend\\Cache\\Exception\\ExceptionInterface */ public function addItem($key, $value); /** * Add multiple items. * * @param array $keyValuePairs * @return array Array of not stored keys * @throws \\Zend\\Cache\\Exception\\ExceptionInterface */ public function addItems(array $keyValuePairs); /** * Replace an existing item. * * @param string $key * @param mixed $value * @return bool * @throws \\Zend\\Cache\\Exception\\ExceptionInterface */ public function replaceItem($key, $value); /** * Replace multiple existing items. * * @param array $keyValuePairs * @return array Array of not stored keys * @throws \\Zend\\Cache\\Exception\\ExceptionInterface */ public function replaceItems(array $keyValuePairs); /** * Set an item only if token matches * * It uses the token received from getItem() to check if the item has * changed before overwriting it. * * @param mixed $token * @param string $key * @param mixed $value * @return bool * @throws \\Zend\\Cache\\Exception\\ExceptionInterface * @see getItem() * @see setItem() */ public function checkAndSetItem($token, $key, $value); /** * Reset lifetime of an item * * @param string $key * @return bool * @throws \\Zend\\Cache\\Exception\\ExceptionInterface */ public function touchItem($key); /** * Reset lifetime of multiple items. * * @param array $keys * @return array Array of not updated keys * @throws \\Zend\\Cache\\Exception\\ExceptionInterface */ public function touchItems(array $keys); /** * Remove an item. * * @param string $key * @return bool * @throws \\Zend\\Cache\\Exception\\ExceptionInterface */ public function removeItem($key); /** * Remove multiple items. * * @param array $keys * @return array Array of not removed keys * @throws \\Zend\\Cache\\Exception\\ExceptionInterface */ public function removeItems(array $keys); /** * Increment an item. * * @param string $key * @param int $value * @return int|bool The new value on success, false on failure * @throws \\Zend\\Cache\\Exception\\ExceptionInterface */ public function incrementItem($key, $value); /** * Increment multiple items. * * @param array $keyValuePairs * @return array Associative array of keys and new values * @throws \\Zend\\Cache\\Exception\\ExceptionInterface */ public function incrementItems(array $keyValuePairs); /** * Decrement an item. * * @param string $key * @param int $value * @return int|bool The new value on success, false on failure * @throws \\Zend\\Cache\\Exception\\ExceptionInterface */ public function decrementItem($key, $value); /** * Decrement multiple items. * * @param array $keyValuePairs * @return array Associative array of keys and new values * @throws \\Zend\\Cache\\Exception\\ExceptionInterface */ public function decrementItems(array $keyValuePairs); /* status */ /** * Capabilities of this storage * * @return Capabilities */ public function getCapabilities(); }","title":"The StorageInterface"},{"location":"storage/adapter/#the-availablespacecapableinterface","text":"Zend\\Cache\\Storage\\AvailableSpaceCapableInterface implements a method to allow retrieving the current available space remaining in storage. namespace Zend\\Cache\\Storage; interface AvailableSpaceCapableInterface { /** * Get available space in bytes * * @return int|float */ public function getAvailableSpace(); }","title":"The AvailableSpaceCapableInterface"},{"location":"storage/adapter/#the-totalspacecapableinterface","text":"Zend\\Cache\\Storage\\TotalSpaceCapableInterface implements a method to allow retrieving the total storage space. namespace Zend\\Cache\\Storage; interface TotalSpaceCapableInterface { /** * Get total space in bytes * * @return int|float */ public function getTotalSpace(); }","title":"The TotalSpaceCapableInterface"},{"location":"storage/adapter/#the-clearbynamespaceinterface","text":"Zend\\Cache\\Storage\\ClearByNamespaceInterface implements a method to allow clearing all cached items within a given namespace. namespace Zend\\Cache\\Storage; interface ClearByNamespaceInterface { /** * Remove items of given namespace * * @param string $namespace * @return bool */ public function clearByNamespace($namespace); }","title":"The ClearByNamespaceInterface"},{"location":"storage/adapter/#the-clearbyprefixinterface","text":"Zend\\Cache\\Storage\\ClearByPrefixInterface implements a method to allow clearing all cached items that have a given prefix (within the currently configured namespace). namespace Zend\\Cache\\Storage; interface ClearByPrefixInterface { /** * Remove items matching given prefix * * @param string $prefix * @return bool */ public function clearByPrefix($prefix); }","title":"The ClearByPrefixInterface"},{"location":"storage/adapter/#the-clearexpiredinterface","text":"Zend\\Cache\\Storage\\ClearExpiredInterface implements a method to allow clearing all expired items (within the current configured namespace). namespace Zend\\Cache\\Storage; interface ClearExpiredInterface { /** * Remove expired items * * @return bool */ public function clearExpired(); }","title":"The ClearExpiredInterface"},{"location":"storage/adapter/#the-flushableinterface","text":"Zend\\Cache\\Storage\\FlushableInterface implements a method for flushing the entire cache storage. namespace Zend\\Cache\\Storage; interface FlushableInterface { /** * Flush the whole storage * * @return bool */ public function flush(); }","title":"The FlushableInterface"},{"location":"storage/adapter/#the-iterableinterface","text":"Zend\\Cache\\Storage\\IterableInterface implements a method for retrieving an iterator of all items in storage. It extends IteratorAggregate , so it's possible to directly iterate over the storage implementations that implement this interface using foreach . namespace Zend\\Cache\\Storage; use IteratorAggregate; /** * * @method IteratorInterface getIterator() Get the storage iterator */ interface IterableInterface extends IteratorAggregate { /** * @return \\Traversable */ public function getIterator(); }","title":"The IterableInterface"},{"location":"storage/adapter/#the-optimizableinterface","text":"Zend\\Cache\\Storage\\OptimizableInterface implements a method for running optimization processes on the storage adapter. namespace Zend\\Cache\\Storage; interface OptimizableInterface { /** * Optimize the storage * * @return bool */ public function optimize(); }","title":"The OptimizableInterface"},{"location":"storage/adapter/#the-taggableinterface","text":"Zend\\Cache\\Storage\\TaggableInterface implements methods for tagging items, and cleaning (expiring) items matching tags. namespace Zend\\Cache\\Storage; interface TaggableInterface { /** * Set tags to an item by given key. * An empty array will remove all tags. * * @param string $key * @param string[] $tags * @return bool */ public function setTags($key, array $tags); /** * Get tags of an item by given key * * @param string $key * @return string[]|FALSE */ public function getTags($key); /** * Remove items matching given tags. * * If $disjunction only one of the given tags must match * else all given tags must match. * * @param string[] $tags * @param bool $disjunction * @return bool */ public function clearByTags(array $tags, $disjunction = false); }","title":"The TaggableInterface"},{"location":"storage/adapter/#the-apc-adapter","text":"Zend\\Cache\\Storage\\Adapter\\Apc stores cache items in shared memory through the PHP extension APC (Alternative PHP Cache). This adapter implements the following interfaces: Zend\\Cache\\Storage\\StorageInterface Zend\\Cache\\Storage\\AvailableSpaceCapableInterface Zend\\Cache\\Storage\\ClearByNamespaceInterface Zend\\Cache\\Storage\\ClearByPrefixInterface Zend\\Cache\\Storage\\FlushableInterface Zend\\Cache\\Storage\\IterableInterface Zend\\Cache\\Storage\\TotalSpaceCapableInterface","title":"The Apc Adapter"},{"location":"storage/adapter/#capabilities","text":"Capability Value supportedDatatypes null , bool , int , float , string , array (serialized), object (serialized) supportedMetadata internal_key, atime, ctime, mtime, rtime, size, hits, ttl minTtl 1 maxTtl 0 staticTtl true ttlPrecision 1 useRequestTime value of apc.use_request_time from php.ini lockOnExpire 0 maxKeyLength 5182 namespaceIsPrefix true namespaceSeparator Option value of namespace_separator","title":"Capabilities"},{"location":"storage/adapter/#adapter-specific-options","text":"Name Data Type Default Value Description namespace_separator string \":\" A separator for the namespace and prefix.","title":"Adapter specific options"},{"location":"storage/adapter/#the-dba-adapter","text":"Zend\\Cache\\Storage\\Adapter\\Dba stores cache items into dbm -like databases using the PHP extension dba . This adapter implements the following interfaces: Zend\\Cache\\Storage\\StorageInterface Zend\\Cache\\Storage\\AvailableSpaceCapableInterface Zend\\Cache\\Storage\\ClearByNamespaceInterface Zend\\Cache\\Storage\\ClearByPrefixInterface Zend\\Cache\\Storage\\FlushableInterface Zend\\Cache\\Storage\\IterableInterface Zend\\Cache\\Storage\\OptimizableInterface Zend\\Cache\\Storage\\TotalSpaceCapableInterface","title":"The Dba Adapter"},{"location":"storage/adapter/#capabilities_1","text":"Capability Value supportedDatatypes string , null => string , boolean => string , integer => string , double => string supportedMetadata none minTtl 0 maxKeyLength 0 namespaceIsPrefix true namespaceSeparator Option value of namespace_separator","title":"Capabilities"},{"location":"storage/adapter/#adapter-specific-options_1","text":"Name Data Type Default Value Description namespace_separator string \":\" A separator for the namespace and prefix. pathname string \"\" Pathname to the database file. mode string \"c\" The mode with which to open the database; please read dba_open for more information. handler string \"flatfile\" The name of the handler which shall be used for accessing the database.","title":"Adapter specific options"},{"location":"storage/adapter/#this-adapter-doesnt-support-automatic-expiry","text":"Because this adapter doesn't support automatic expiry, it's very important to clean outdated items periodically!","title":"This adapter doesn't support automatic expiry"},{"location":"storage/adapter/#the-filesystem-adapter","text":"Zend\\Cache\\Storage\\Adapter\\Filesystem stores cache items on the filesystem. This adapter implements the following interfaces: Zend\\Cache\\Storage\\StorageInterface Zend\\Cache\\Storage\\AvailableSpaceCapableInterface Zend\\Cache\\Storage\\ClearByNamespaceInterface Zend\\Cache\\Storage\\ClearByPrefixInterface Zend\\Cache\\Storage\\ClearExpiredInterface Zend\\Cache\\Storage\\FlushableInterface Zend\\Cache\\Storage\\IterableInterface Zend\\Cache\\Storage\\OptimizableInterface Zend\\Cache\\Storage\\TaggableInterface Zend\\Cache\\Storage\\TotalSpaceCapableInterface","title":"The Filesystem Adapter"},{"location":"storage/adapter/#capabilities_2","text":"Capability Value supportedDatatypes string , null => string , boolean => string , integer => string , double => string supportedMetadata mtime, filespec, atime, ctime minTtl 1 maxTtl 0 staticTtl false ttlPrecision 1 useRequestTime false lockOnExpire 0 maxKeyLength 251 namespaceIsPrefix true namespaceSeparator Option value of namespace_separator","title":"Capabilities"},{"location":"storage/adapter/#adapter-specific-options_2","text":"Name Data Type Default Value Description namespace_separator string \":\" A separator for the namespace and prefix cache_dir string \"\" Directory to store cache files. clear_stat_cache boolean true Call clearstatcache() enabled? dir_level integer 1 Defines how much sub-directories should be created. dir_permission integer false 0700 Set explicit permission on creating new directories. file_locking boolean true Lock files on writing. file_permission integer false 0600 Set explicit permission on creating new files. key_pattern string /^[a-z0-9_\\+\\-]*$/Di Validate key against pattern. no_atime boolean true Don\u2019t get \u2018fileatime\u2019 as \u2018atime\u2019 on metadata. no_ctime boolean true Don\u2019t get \u2018filectime\u2019 as \u2018ctime\u2019 on metadata. umask integer|false false Use umask to set file and directory permissions. suffix string dat Suffix for cache files tag_suffix string tag Suffix for tag files Note: the suffix and tag_suffix options will be escaped in order to be safe for glob operations.","title":"Adapter specific options"},{"location":"storage/adapter/#the-memcached-adapter","text":"Zend\\Cache\\Storage\\Adapter\\Memcached stores cache items over the memcached protocol, using the PHP extension memcached , based on Libmemcached . This adapter implements the following interfaces: Zend\\Cache\\Storage\\StorageInterface Zend\\Cache\\Storage\\AvailableSpaceCapableInterface Zend\\Cache\\Storage\\FlushableInterface Zend\\Cache\\Storage\\TotalSpaceCapableInterface","title":"The Memcached Adapter"},{"location":"storage/adapter/#capabilities_3","text":"Capability Value supportedDatatypes null , boolean , integer , double , string , array (serialized), object (serialized) supportedMetadata none minTtl 1 maxTtl 0 staticTtl true ttlPrecision 1 useRequestTime false lockOnExpire 0 maxKeyLength 255 namespaceIsPrefix true namespaceSeparator none","title":"Capabilities"},{"location":"storage/adapter/#adapter-specific-options_3","text":"Name Data Type Default Value Description servers array [] List of servers in the format [] = [string host, integer port] lib_options array [] Associative array of Libmemcached options where the array key is the option name (without the prefix OPT_ ) or the constant value. The array value is the option value. Please read the memcached setOption() page for more information","title":"Adapter specific options"},{"location":"storage/adapter/#the-redis-adapter","text":"Zend\\Cache\\Storage\\Adapter\\Redis stores cache items over the redis protocol using the PHP extension redis . This adapter implements the following interfaces: Zend\\Cache\\Storage\\FlushableInterface Zend\\Cache\\Storage\\TotalSpaceCapableInterface","title":"The Redis Adapter"},{"location":"storage/adapter/#capabilities_4","text":"Capability Value supportedDatatypes string , array (serialized), object (serialized) supportedMetadata none minTtl 1 maxTtl 0 staticTtl true ttlPrecision 1 useRequestTime false lockOnExpire 0 maxKeyLength 255 namespaceIsPrefix true namespaceSeparator none","title":"Capabilities"},{"location":"storage/adapter/#adapter-specific-options_4","text":"Name Data Type Default Value Description database integer 0 Set database identifier. lib_options array [] Associative array of redis options where the array key is the option name. namespace_separator string \":\" A separator for the namespace and prefix. password string \"\" Set password. persistent_id string Set persistent id (name of the connection, leave blank to not use a persistent connection). resource_manager string Set the redis resource manager to use server See below. server can be described as any of the following: URI: /path/to/sock.sock Associative array: ['host' => <host>[, 'port' => <port>[, 'timeout' => <timeout>]]] List: [<host>[, <port>, [, <timeout>]]]","title":"Adapter specific options"},{"location":"storage/adapter/#the-memory-adapter","text":"The Zend\\Cache\\Storage\\Adapter\\Memory stores items in-memory in the current process only. This adapter implements the following interfaces: Zend\\Cache\\Storage\\StorageInterface Zend\\Cache\\Storage\\AvailableSpaceCapableInterface Zend\\Cache\\Storage\\ClearByPrefixInterface Zend\\Cache\\Storage\\ClearExpiredInterface Zend\\Cache\\Storage\\FlushableInterface Zend\\Cache\\Storage\\IterableInterface Zend\\Cache\\Storage\\TaggableInterface Zend\\Cache\\Storage\\TotalSpaceCapableInterface","title":"The Memory Adapter"},{"location":"storage/adapter/#capabilities_5","text":"Capability Value supportedDatatypes string , null , boolean , integer , double , array , object , resource supportedMetadata mtime minTtl 1 maxTtl Value of PHP_INT_MAX staticTtl false ttlPrecision 0.05 useRequestTime false lockOnExpire 0 maxKeyLength 0 namespaceIsPrefix false","title":"Capabilities"},{"location":"storage/adapter/#adapter-specific-options_5","text":"Name Data Type Default Value Description memory_limit string|integer 50% of memory_limit INI value Limit of how much memory can PHP allocate to allow store items.","title":"Adapter specific options"},{"location":"storage/adapter/#memory-limit","text":"The adapter has the following behavior with regards to the memory limit: If the consumed memory exceeds the limit provided, an OutOfSpaceException is thrown. A number less the or equal to zero disables the memory limit. When a value is provided for the memory limit, the value is measured in bytes. Shorthand notation may also be provided.","title":"Memory limit"},{"location":"storage/adapter/#current-process-only","text":"All stored items will be lost on termination of the script. For web-facing requests, this typically means the cache is volatile.","title":"Current process only!"},{"location":"storage/adapter/#the-mongodb-adapter","text":"Zend\\Cache\\Storage\\Adapter\\MongoDB stores cache items using MongoDB, via either the PHP extension mongo , or a MongoDB polyfill library, such as Mongofill .","title":"The MongoDB Adapter"},{"location":"storage/adapter/#ext-mongodb","text":"If you are using the mongodb extension (vs the mongo extension), you will need to use the ExtMongoDb adapter instead. This adapter implements the following interfaces: Zend\\Cache\\Storage\\FlushableInterface","title":"ext-mongodb"},{"location":"storage/adapter/#capabilities_6","text":"Capability Value supportedDatatypes string , null , boolean , integer , double , array supportedMetadata _id minTtl 0 maxTtl 0 staticTtl true ttlPrecision 1 useRequestTime false lockOnExpire 0 maxKeyLength 255 namespaceIsPrefix true namespaceSeparator","title":"Capabilities"},{"location":"storage/adapter/#adapter-specific-options_6","text":"Name Data Type Default Value Description lib_option array Associative array of options where the array key is the option name. namespace_separator string \":\" A separator for the namespace and prefix. Available keys for lib_option include: Key Default Description server mongodb://localhost:27017 The MongoDB server connection string (see the MongoClient docs ). database zend Name of the database to use; MongoDB will create this database if it does not exist. collection cache Name of the collection to use; MongoDB will create this collection if it does not exist. connectionOptions ['fsync' => false, 'journal' => true] Associative array of options to pass to MongoClient (see the MongoClient docs ). driverOptions [] Associative array of driver options to pass to MongoClient (see the MongoClient docs ).","title":"Adapter specific options"},{"location":"storage/adapter/#the-extmongodb-adapter","text":"Since 2.8.0 Zend\\Cache\\Storage\\Adapter\\ExtMongoDB stores cache items using the mongodb extension, and requires that the MongoDB PHP Client library is also installed. You can install the client library using the following: $ composer require mongodb/mongodb","title":"The ExtMongoDB Adapter"},{"location":"storage/adapter/#ext-mongo","text":"If you are using the mongo extension (vs the mongodb extension), you will need to use the MongoDb adapter instead. This adapter implements the following interfaces: Zend\\Cache\\Storage\\FlushableInterface","title":"ext-mongo"},{"location":"storage/adapter/#capabilities_7","text":"Capability Value supportedDatatypes string , null , boolean , integer , double , array supportedMetadata _id minTtl 0 maxTtl 0 staticTtl true ttlPrecision 1 useRequestTime false lockOnExpire 0 maxKeyLength 255 namespaceIsPrefix true namespaceSeparator","title":"Capabilities"},{"location":"storage/adapter/#adapter-specific-options_7","text":"Name Data Type Default Value Description lib_option array Associative array of options where the array key is the option name. namespace_separator string \":\" A separator for the namespace and prefix. Available keys for lib_option include: Key Default Description server mongodb://localhost:27017 The MongoDB server connection string (see the MongoDB\\Client docs ). database zend Name of the database to use; MongoDB will create this database if it does not exist. collection cache Name of the collection to use; MongoDB will create this collection if it does not exist. connectionOptions ['fsync' => false, 'journal' => true] Associative array of URI options (such as authentication credentials or query string parameters) to pass to MongoDB\\\\Client (see the MongoDB\\Client docs ). driverOptions [] Associative array of driver options to pass to MongoDB\\\\Client (see the MongoDB\\Client docs ).","title":"Adapter specific options"},{"location":"storage/adapter/#the-wincache-adapter","text":"Zend\\Cache\\Storage\\Adapter\\WinCache stores cache items into shared memory through the PHP extension WinCache . This adapter implements the following interfaces: Zend\\Cache\\Storage\\StorageInterface Zend\\Cache\\Storage\\AvailableSpaceCapableInterface Zend\\Cache\\Storage\\FlushableInterface Zend\\Cache\\Storage\\TotalSpaceCapableInterface","title":"The WinCache Adapter"},{"location":"storage/adapter/#capabilities_8","text":"Capability Value supportedDatatypes null , boolean , integer , double , string , array (serialized), object (serialized) supportedMetadata internal_key, ttl, hits, size minTtl 1 maxTtl 0 staticTtl true ttlPrecision 1 useRequestTime apc.use_request_time php.ini value. lockOnExpire 0 namespaceIsPrefix true namespaceSeparator Option value of namespace_separator","title":"Capabilities"},{"location":"storage/adapter/#adapter-specific-options_8","text":"Name Data Type Default Value Description namespace_separator string \":\" A separator for the namespace and prefix.","title":"Adapter specific options"},{"location":"storage/adapter/#the-xcache-adapter","text":"Zend\\Cache\\Storage\\Adapter\\XCache stores cache items into shared memory through the PHP extension XCache . This adapter implements the following interfaces: Zend\\Cache\\Storage\\StorageInterface Zend\\Cache\\Storage\\AvailableSpaceCapableInterface Zend\\Cache\\Storage\\ClearByNamespaceInterface Zend\\Cache\\Storage\\ClearByPrefixInterface Zend\\Cache\\Storage\\FlushableInterface Zend\\Cache\\Storage\\IterableInterface Zend\\Cache\\Storage\\TotalSpaceCapableInterface","title":"The XCache Adapter"},{"location":"storage/adapter/#capabilities_9","text":"Capability Value supportedDatatypes boolean , integer , double , string , array (serialized), object (serialized) supportedMetadata internal_key, size, refcount, hits, ctime, atime, hvalue minTtl 1 maxTtl xcache.var_maxttl php.ini value staticTtl true ttlPrecision 1 useRequestTime true lockOnExpire 0 maxKeyLength 5182 namespaceIsPrefix true namespaceSeparator Option value of namespace_separator","title":"Capabilities"},{"location":"storage/adapter/#adapter-specific-options_9","text":"Name Data Type Default Value Description namespace_separator string \":\" A separator for the namespace and prefix. admin_auth boolean false Enable admin authentication by configuration options admin_user and admin_pass . This makes XCache administration functions accessible without the need of HTTP-Authentication if xcache.admin.enable_auth is enabled. admin_user string \"\" The username of xcache.admin.user . admin_pass string \"\" The password of xcache.admin.pass in plain text.","title":"Adapter specific options"},{"location":"storage/adapter/#the-zendserverdisk-adapter","text":"Zend\\Cache\\Storage\\Adapter\\ZendServerDisk stores cache items on the filesystem using the Zend Server Data Caching API . This adapter implements the following interfaces: Zend\\Cache\\Storage\\StorageInterface Zend\\Cache\\Storage\\AvailableSpaceCapableInterface Zend\\Cache\\Storage\\ClearByNamespaceInterface Zend\\Cache\\Storage\\FlushableInterface Zend\\Cache\\Storage\\TotalSpaceCapableInterface","title":"The ZendServerDisk Adapter"},{"location":"storage/adapter/#capabilities_10","text":"Capability Value supportedDatatypes null , boolean , integer , double , string , array (serialized), object (serialized) supportedMetadata none minTtl 1 maxTtl 0 maxKeyLength 0 staticTtl true ttlPrecision 1 useRequestTime false lockOnExpire if 'zend_datacache.lock_on_expire' is enabled 120 else 0 namespaceIsPrefix true namespaceSeparator ::","title":"Capabilities"},{"location":"storage/adapter/#the-zendservershm-adapter","text":"Zend\\Cache\\Storage\\Adapter\\ZendServerShm stores cache items in shared memory through the Zend Server Data Caching API . This adapter implements the following interfaces: Zend\\Cache\\Storage\\StorageInterface Zend\\Cache\\Storage\\ClearByNamespaceInterface Zend\\Cache\\Storage\\FlushableInterface Zend\\Cache\\Storage\\TotalSpaceCapableInterface","title":"The ZendServerShm Adapter"},{"location":"storage/adapter/#capabilities_11","text":"Capability Value supportedDatatypes null , boolean , integer , double , string , array (serialized), object (serialized) supportedMetadata none minTtl 1 maxTtl 0 maxKeyLength 0 staticTtl true ttlPrecision 1 useRequestTime false lockOnExpire if 'zend_datacache.lock_on_expire' is enabled 120 else 0 namespaceIsPrefix true namespaceSeparator ::","title":"Capabilities"},{"location":"storage/adapter/#examples","text":"","title":"Examples"},{"location":"storage/adapter/#basic-usage","text":"use Zend\\Cache\\StorageFactory; $cache = StorageFactory::factory([ 'adapter' => [ 'name' => 'filesystem' ], 'plugins' => [ // Don't throw exceptions on cache errors 'exception_handler' => [ 'throw_exceptions' => false ], ], ]); $key = 'unique-cache-key'; $result = $cache->getItem($key, $success); if (! $success) { $result = doExpensiveStuff(); $cache->setItem($key, $result); }","title":"Basic usage"},{"location":"storage/adapter/#get-multiple-rows-from-a-database","text":"use Zend\\Cache\\StorageFactory; // Instantiate the cache instance using a namespace for the same type of items $cache = StorageFactory::factory([ 'adapter' => [ 'name' => 'filesystem', // With a namespace, we can indicate the same type of items, // so we can simply use the database id as the cache key 'options' => [ 'namespace' => 'dbtable', ], ], 'plugins' => [ // Don't throw exceptions on cache errors 'exception_handler' => [ 'throw_exceptions' => false, ], // We store database rows on filesystem so we need to serialize them 'Serializer', ], ]); // Load two rows from cache if possible $ids = [1, 2]; $results = $cache->getItems($ids); if (count($results) < count($ids)) { // Load rows from db if loading from cache failed $missingIds = array_diff($ids, array_keys($results)); $missingResults = []; $query = 'SELECT * FROM dbtable WHERE id IN (' . implode(',', $missingIds) . ')'; foreach ($pdo->query($query, PDO::FETCH_ASSOC) as $row) { $missingResults[ $row['id'] ] = $row; } // Update cache items of the loaded rows from db $cache->setItems($missingResults); // merge results from cache and db $results = array_merge($results, $missingResults); }","title":"Get multiple rows from a database"},{"location":"storage/capabilities/","text":"Storage Capabilities Storage capabilities describe how a storage adapter works, and which features it supports. To get capabilities of a storage adapter, you can use the method getCapabilities() , but only the storage adapter and its plugins have permissions to change them. Because capabilities are mutable, you can subscribe to the \"change\" event to get notifications; see the examples for details. If you are writing your own plugin or adapter, you can also change capabilities because you have access to the marker object and can create your own marker to instantiate a new instance of Zend\\Cache\\Storage\\Capabilities . Available Methods namespace Zend\\Cache\\Storage; use ArrayObject; use stdClass; use Zend\\Cache\\Exception; use Zend\\EventManager\\EventsCapableInterface; class Capabilities { /** * Constructor * * @param StorageInterface $storage * @param stdClass $marker * @param array $capabilities * @param null|Capabilities $baseCapabilities */ public function __construct( StorageInterface $storage, stdClass $marker, array $capabilities = [], Capabilities $baseCapabilities = null ); /** * Get the storage adapter * * @return StorageInterface */ public function getAdapter(); /** * Get supported datatypes * * @return array */ public function getSupportedDatatypes(); /** * Set supported datatypes * * @param stdClass $marker * @param array $datatypes * @throws Exception\\InvalidArgumentException * @return Capabilities Fluent interface */ public function setSupportedDatatypes(stdClass $marker, array $datatypes); /** * Get supported metadata * * @return array */ public function getSupportedMetadata(); /** * Set supported metadata * * @param stdClass $marker * @param string[] $metadata * @throws Exception\\InvalidArgumentException * @return Capabilities Fluent interface */ public function setSupportedMetadata(stdClass $marker, array $metadata); /** * Get minimum supported time-to-live * * @return int 0 means items never expire */ public function getMinTtl(); /** * Set minimum supported time-to-live * * @param stdClass $marker * @param int $minTtl * @throws Exception\\InvalidArgumentException * @return Capabilities Fluent interface */ public function setMinTtl(stdClass $marker, $minTtl); /** * Get maximum supported time-to-live * * @return int 0 means infinite */ public function getMaxTtl(); /** * Set maximum supported time-to-live * * @param stdClass $marker * @param int $maxTtl * @throws Exception\\InvalidArgumentException * @return Capabilities Fluent interface */ public function setMaxTtl(stdClass $marker, $maxTtl); /** * Is the time-to-live handled static (on write) * or dynamic (on read) * * @return bool */ public function getStaticTtl(); /** * Set if the time-to-live handled static (on write) or dynamic (on read) * * @param stdClass $marker * @param bool $flag * @return Capabilities Fluent interface */ public function setStaticTtl(stdClass $marker, $flag); /** * Get time-to-live precision * * @return float */ public function getTtlPrecision(); /** * Set time-to-live precision * * @param stdClass $marker * @param float $ttlPrecision * @throws Exception\\InvalidArgumentException * @return Capabilities Fluent interface */ public function setTtlPrecision(stdClass $marker, $ttlPrecision); /** * Get use request time * * @return bool */ public function getUseRequestTime(); /** * Set use request time * * @param stdClass $marker * @param bool $flag * @return Capabilities Fluent interface */ public function setUseRequestTime(stdClass $marker, $flag); /** * Get if expired items are readable * * @return bool * @deprecated This capability has been deprecated and will be removed in the future. * Please use getStaticTtl() instead */ public function getExpiredRead(); /** * Set if expired items are readable * * @param stdClass $marker * @param bool $flag * @return Capabilities Fluent interface * @deprecated This capability has been deprecated and will be removed in the future. * Please use setStaticTtl() instead */ public function setExpiredRead(stdClass $marker, $flag); /** * Get \"lock-on-expire\" support in seconds. * * @return int 0 = Expired items will never be retrieved * >0 = Time in seconds an expired item could be retrieved * -1 = Expired items could be retrieved forever */ public function getLockOnExpire() { return $this->getCapability('lockOnExpire', 0); } /** * Set \"lock-on-expire\" support in seconds. * * @param stdClass $marker * @param int $timeout * @return Capabilities Fluent interface */ public function setLockOnExpire(stdClass $marker, $timeout) { return $this->setCapability($marker, 'lockOnExpire', (int) $timeout); } /** * Get maximum key length * * @return int -1 means unknown, 0 means infinite */ public function getMaxKeyLength(); /** * Set maximum key length * * @param stdClass $marker * @param int $maxKeyLength * @throws Exception\\InvalidArgumentException * @return Capabilities Fluent interface */ public function setMaxKeyLength(stdClass $marker, $maxKeyLength); /** * Get if namespace support is implemented as prefix * * @return bool */ public function getNamespaceIsPrefix(); /** * Set if namespace support is implemented as prefix * * @param stdClass $marker * @param bool $flag * @return Capabilities Fluent interface */ public function setNamespaceIsPrefix(stdClass $marker, $flag); /** * Get namespace separator if namespace is implemented as prefix * * @return string */ public function getNamespaceSeparator(); /** * Set the namespace separator if namespace is implemented as prefix * * @param stdClass $marker * @param string $separator * @return Capabilities Fluent interface */ public function setNamespaceSeparator(stdClass $marker, $separator); } Examples Get storage capabilities and do specific stuff based on them use Zend\\Cache\\StorageFactory; $cache = StorageFactory::adapterFactory('filesystem'); $supportedDatatypes = $cache->getCapabilities()->getSupportedDatatypes(); // now you can run specific stuff in base of supported feature if ($supportedDatatypes['object']) { $cache->set($key, $object); } else { $cache->set($key, serialize($object)); } Listen to the change event use Zend\\Cache\\StorageFactory; $cache = StorageFactory::adapterFactory('filesystem', [ 'no_atime' => false, ]); // Catching capability changes $cache->getEventManager()->attach('capability', function($event) { echo count($event->getParams()) . ' capabilities changed'; }); // change option which changes capabilities $cache->getOptions()->setNoATime(true);","title":"Capabilities"},{"location":"storage/capabilities/#storage-capabilities","text":"Storage capabilities describe how a storage adapter works, and which features it supports. To get capabilities of a storage adapter, you can use the method getCapabilities() , but only the storage adapter and its plugins have permissions to change them. Because capabilities are mutable, you can subscribe to the \"change\" event to get notifications; see the examples for details. If you are writing your own plugin or adapter, you can also change capabilities because you have access to the marker object and can create your own marker to instantiate a new instance of Zend\\Cache\\Storage\\Capabilities .","title":"Storage Capabilities"},{"location":"storage/capabilities/#available-methods","text":"namespace Zend\\Cache\\Storage; use ArrayObject; use stdClass; use Zend\\Cache\\Exception; use Zend\\EventManager\\EventsCapableInterface; class Capabilities { /** * Constructor * * @param StorageInterface $storage * @param stdClass $marker * @param array $capabilities * @param null|Capabilities $baseCapabilities */ public function __construct( StorageInterface $storage, stdClass $marker, array $capabilities = [], Capabilities $baseCapabilities = null ); /** * Get the storage adapter * * @return StorageInterface */ public function getAdapter(); /** * Get supported datatypes * * @return array */ public function getSupportedDatatypes(); /** * Set supported datatypes * * @param stdClass $marker * @param array $datatypes * @throws Exception\\InvalidArgumentException * @return Capabilities Fluent interface */ public function setSupportedDatatypes(stdClass $marker, array $datatypes); /** * Get supported metadata * * @return array */ public function getSupportedMetadata(); /** * Set supported metadata * * @param stdClass $marker * @param string[] $metadata * @throws Exception\\InvalidArgumentException * @return Capabilities Fluent interface */ public function setSupportedMetadata(stdClass $marker, array $metadata); /** * Get minimum supported time-to-live * * @return int 0 means items never expire */ public function getMinTtl(); /** * Set minimum supported time-to-live * * @param stdClass $marker * @param int $minTtl * @throws Exception\\InvalidArgumentException * @return Capabilities Fluent interface */ public function setMinTtl(stdClass $marker, $minTtl); /** * Get maximum supported time-to-live * * @return int 0 means infinite */ public function getMaxTtl(); /** * Set maximum supported time-to-live * * @param stdClass $marker * @param int $maxTtl * @throws Exception\\InvalidArgumentException * @return Capabilities Fluent interface */ public function setMaxTtl(stdClass $marker, $maxTtl); /** * Is the time-to-live handled static (on write) * or dynamic (on read) * * @return bool */ public function getStaticTtl(); /** * Set if the time-to-live handled static (on write) or dynamic (on read) * * @param stdClass $marker * @param bool $flag * @return Capabilities Fluent interface */ public function setStaticTtl(stdClass $marker, $flag); /** * Get time-to-live precision * * @return float */ public function getTtlPrecision(); /** * Set time-to-live precision * * @param stdClass $marker * @param float $ttlPrecision * @throws Exception\\InvalidArgumentException * @return Capabilities Fluent interface */ public function setTtlPrecision(stdClass $marker, $ttlPrecision); /** * Get use request time * * @return bool */ public function getUseRequestTime(); /** * Set use request time * * @param stdClass $marker * @param bool $flag * @return Capabilities Fluent interface */ public function setUseRequestTime(stdClass $marker, $flag); /** * Get if expired items are readable * * @return bool * @deprecated This capability has been deprecated and will be removed in the future. * Please use getStaticTtl() instead */ public function getExpiredRead(); /** * Set if expired items are readable * * @param stdClass $marker * @param bool $flag * @return Capabilities Fluent interface * @deprecated This capability has been deprecated and will be removed in the future. * Please use setStaticTtl() instead */ public function setExpiredRead(stdClass $marker, $flag); /** * Get \"lock-on-expire\" support in seconds. * * @return int 0 = Expired items will never be retrieved * >0 = Time in seconds an expired item could be retrieved * -1 = Expired items could be retrieved forever */ public function getLockOnExpire() { return $this->getCapability('lockOnExpire', 0); } /** * Set \"lock-on-expire\" support in seconds. * * @param stdClass $marker * @param int $timeout * @return Capabilities Fluent interface */ public function setLockOnExpire(stdClass $marker, $timeout) { return $this->setCapability($marker, 'lockOnExpire', (int) $timeout); } /** * Get maximum key length * * @return int -1 means unknown, 0 means infinite */ public function getMaxKeyLength(); /** * Set maximum key length * * @param stdClass $marker * @param int $maxKeyLength * @throws Exception\\InvalidArgumentException * @return Capabilities Fluent interface */ public function setMaxKeyLength(stdClass $marker, $maxKeyLength); /** * Get if namespace support is implemented as prefix * * @return bool */ public function getNamespaceIsPrefix(); /** * Set if namespace support is implemented as prefix * * @param stdClass $marker * @param bool $flag * @return Capabilities Fluent interface */ public function setNamespaceIsPrefix(stdClass $marker, $flag); /** * Get namespace separator if namespace is implemented as prefix * * @return string */ public function getNamespaceSeparator(); /** * Set the namespace separator if namespace is implemented as prefix * * @param stdClass $marker * @param string $separator * @return Capabilities Fluent interface */ public function setNamespaceSeparator(stdClass $marker, $separator); }","title":"Available Methods"},{"location":"storage/capabilities/#examples","text":"","title":"Examples"},{"location":"storage/capabilities/#get-storage-capabilities-and-do-specific-stuff-based-on-them","text":"use Zend\\Cache\\StorageFactory; $cache = StorageFactory::adapterFactory('filesystem'); $supportedDatatypes = $cache->getCapabilities()->getSupportedDatatypes(); // now you can run specific stuff in base of supported feature if ($supportedDatatypes['object']) { $cache->set($key, $object); } else { $cache->set($key, serialize($object)); }","title":"Get storage capabilities and do specific stuff based on them"},{"location":"storage/capabilities/#listen-to-the-change-event","text":"use Zend\\Cache\\StorageFactory; $cache = StorageFactory::adapterFactory('filesystem', [ 'no_atime' => false, ]); // Catching capability changes $cache->getEventManager()->attach('capability', function($event) { echo count($event->getParams()) . ' capabilities changed'; }); // change option which changes capabilities $cache->getOptions()->setNoATime(true);","title":"Listen to the change event"},{"location":"storage/plugin/","text":"Storage Plugins Cache storage plugins are objects that provide additional functionality to or influence behavior of a storage adapter. The plugins listen to events the adapter triggers, and can: change the arguments provided to the method triggering the event (via *.post events) skip and directly return a result (by calling stopPropagation ) change the result (by calling setResult on the provided Zend\\Cache\\Storage\\PostEvent ) catch exceptions (by reacting to Zend\\Cache\\Storage\\ExceptionEvent ) Quick Start Storage plugins can either be created from Zend\\Cache\\StorageFactory::pluginFactory() , or by instantiating one of the Zend\\Cache\\Storage\\Plugin\\* classes. To make life easier, Zend\\Cache\\StorageFactory::factory() can create both the requested adapter and all specified plugins at once. use Zend\\Cache\\StorageFactory; // All at once: $cache = StorageFactory::factory([ 'adapter' => 'filesystem', 'plugins' => ['serializer'], ]); // Alternately, via discrete factory methods: $cache = StorageFactory::adapterFactory('filesystem'); $plugin = StorageFactory::pluginFactory('serializer'); $cache->addPlugin($plugin); // Or manually: $cache = new Zend\\Cache\\Storage\\Adapter\\Filesystem(); $plugin = new Zend\\Cache\\Storage\\Plugin\\Serializer(); $cache->addPlugin($plugin); The ClearExpiredByFactor Plugin Zend\\Cache\\Storage\\Plugin\\ClearExpiredByFactor calls the storage method clearExpired() randomly (by factor) after every call of setItem() , setItems() , addItem() , and addItems() . Plugin specific options Name Data Type Default Value Description clearing_factor integer 0 The automatic clearing factor. Adapter must implement ClearExpiredInterface The storage adapter must implement Zend\\Cache\\Storage\\ClearExpiredInterface to work with this plugin. The ExceptionHandler Plugin Zend\\Cache\\Storage\\Plugin\\ExceptionHandler catches all exceptions thrown on reading from or writing to the cache, and sends the exception to a defined callback function. You may also configure the plugin to re-throw exceptions. Plugin specific options Name Data Type Default Value Description exception_callback callable|null null Callback to invoke on exception; receives the exception as the sole argument. throw_exceptions boolean true Re-throw caught exceptions. The IgnoreUserAbort Plugin Zend\\Cache\\Storage\\Plugin\\IgnoreUserAbort ignores user-invoked script termination when, allowing cache write operations to complete first. Plugin specific options Name Data Type Default Value Description exit_on_abort boolean true Terminate script execution on user abort. The OptimizeByFactor Plugin Zend\\Cache\\Storage\\Plugin\\OptimizeByFactor calls the storage method optimize() randomly (by factor) after removing items from the cache. Plugin specific options Name Data Type Default Value Description optimizing_factor integer 0 The automatic optimization factor. Adapter must implement OptimizableInterface The storage adapter must implement Zend\\Cache\\Storage\\OptimizableInterface to work with this plugin. The Serializer Plugin Zend\\Cache\\Storage\\Plugin\\Serializer will serialize data when writing to cache, and deserialize when reading. This allows storing datatypes not supported by the underlying storage adapter. Plugin specific options Name Data Type Default Value Description serializer null|string|Zend\\Serializer\\Adapter\\AdapterInterface null The serializer to use; see below. serializer_options array [] Array of options to use when instantiating the specified serializer. The serializer value has two special cases: When null , the default serializer is used (JSON). When a string , the value will be pulled via Zend\\Serializer\\AdapterPluginManager , with the provided serializer_options . Available Methods The following methods are available to all Zend\\Cache\\Storage\\Plugin\\PluginInterface implementations: namespace Zend\\Cache\\Storage\\Plugin; use Zend\\EventManager\\EventManagerInterface; use Zend\\EventManager\\ListenerAggregateInterface; interface PluginInterface extends ListenerAggregateInterface { /** * Set options * * @param PluginOptions $options * @return PluginInterface */ public function setOptions(PluginOptions $options); /** * Get options * * @return PluginOptions */ public function getOptions(); /** * Attach listeners; inherited from ListenerAggregateInterface. * * @param EventManagerInterface $events * @return void */ public function attach(EventManagerInterface $events); /** * Detach listeners; inherited from ListenerAggregateInterface. * * @param EventManagerInterface $events * @return void */ public function attach(EventManagerInterface $events); } Examples Basic plugin implementation use Zend\\Cache\\Storage\\Event; use Zend\\Cache\\Storage\\Plugin\\AbstractPlugin; use Zend\\EventManager\\EventManagerInterface; class MyPlugin extends AbstractPlugin { protected $handles = []; /** * Attach to all events this plugin is interested in. */ public function attach(EventManagerInterface $events) { $this->handles[] = $events->attach('getItem.pre', array($this, 'onGetItemPre')); $this->handles[] = $events->attach('getItem.post', array($this, 'onGetItemPost')); } /** * Detach all handlers this plugin previously attached. */ public function detach(EventManagerInterface $events) { foreach ($this->handles as $handle) { $events->detach($handle); } $this->handles = []; } public function onGetItemPre(Event $event) { $params = $event->getParams(); echo sprintf(\"Method 'getItem' with key '%s' started\\n\", $params['key']); } public function onGetItemPost(Event $event) { $params = $event->getParams(); echo sprintf(\"Method 'getItem' with key '%s' finished\\n\", $params['key']); } } // After defining this plugin, we can instantiate and add it to an adapter // instance: $plugin = new MyPlugin(); $cache->addPlugin($plugin); // Now when calling getItem(), our plugin should print the expected output: $cache->getItem('cache-key'); // Method 'getItem' with key 'cache-key' started // Method 'getItem' with key 'cache-key' finished","title":"Plugins"},{"location":"storage/plugin/#storage-plugins","text":"Cache storage plugins are objects that provide additional functionality to or influence behavior of a storage adapter. The plugins listen to events the adapter triggers, and can: change the arguments provided to the method triggering the event (via *.post events) skip and directly return a result (by calling stopPropagation ) change the result (by calling setResult on the provided Zend\\Cache\\Storage\\PostEvent ) catch exceptions (by reacting to Zend\\Cache\\Storage\\ExceptionEvent )","title":"Storage Plugins"},{"location":"storage/plugin/#quick-start","text":"Storage plugins can either be created from Zend\\Cache\\StorageFactory::pluginFactory() , or by instantiating one of the Zend\\Cache\\Storage\\Plugin\\* classes. To make life easier, Zend\\Cache\\StorageFactory::factory() can create both the requested adapter and all specified plugins at once. use Zend\\Cache\\StorageFactory; // All at once: $cache = StorageFactory::factory([ 'adapter' => 'filesystem', 'plugins' => ['serializer'], ]); // Alternately, via discrete factory methods: $cache = StorageFactory::adapterFactory('filesystem'); $plugin = StorageFactory::pluginFactory('serializer'); $cache->addPlugin($plugin); // Or manually: $cache = new Zend\\Cache\\Storage\\Adapter\\Filesystem(); $plugin = new Zend\\Cache\\Storage\\Plugin\\Serializer(); $cache->addPlugin($plugin);","title":"Quick Start"},{"location":"storage/plugin/#the-clearexpiredbyfactor-plugin","text":"Zend\\Cache\\Storage\\Plugin\\ClearExpiredByFactor calls the storage method clearExpired() randomly (by factor) after every call of setItem() , setItems() , addItem() , and addItems() .","title":"The ClearExpiredByFactor Plugin"},{"location":"storage/plugin/#plugin-specific-options","text":"Name Data Type Default Value Description clearing_factor integer 0 The automatic clearing factor.","title":"Plugin specific options"},{"location":"storage/plugin/#adapter-must-implement-clearexpiredinterface","text":"The storage adapter must implement Zend\\Cache\\Storage\\ClearExpiredInterface to work with this plugin.","title":"Adapter must implement ClearExpiredInterface"},{"location":"storage/plugin/#the-exceptionhandler-plugin","text":"Zend\\Cache\\Storage\\Plugin\\ExceptionHandler catches all exceptions thrown on reading from or writing to the cache, and sends the exception to a defined callback function. You may also configure the plugin to re-throw exceptions.","title":"The ExceptionHandler Plugin"},{"location":"storage/plugin/#plugin-specific-options_1","text":"Name Data Type Default Value Description exception_callback callable|null null Callback to invoke on exception; receives the exception as the sole argument. throw_exceptions boolean true Re-throw caught exceptions.","title":"Plugin specific options"},{"location":"storage/plugin/#the-ignoreuserabort-plugin","text":"Zend\\Cache\\Storage\\Plugin\\IgnoreUserAbort ignores user-invoked script termination when, allowing cache write operations to complete first.","title":"The IgnoreUserAbort Plugin"},{"location":"storage/plugin/#plugin-specific-options_2","text":"Name Data Type Default Value Description exit_on_abort boolean true Terminate script execution on user abort.","title":"Plugin specific options"},{"location":"storage/plugin/#the-optimizebyfactor-plugin","text":"Zend\\Cache\\Storage\\Plugin\\OptimizeByFactor calls the storage method optimize() randomly (by factor) after removing items from the cache.","title":"The OptimizeByFactor Plugin"},{"location":"storage/plugin/#plugin-specific-options_3","text":"Name Data Type Default Value Description optimizing_factor integer 0 The automatic optimization factor.","title":"Plugin specific options"},{"location":"storage/plugin/#adapter-must-implement-optimizableinterface","text":"The storage adapter must implement Zend\\Cache\\Storage\\OptimizableInterface to work with this plugin.","title":"Adapter must implement OptimizableInterface"},{"location":"storage/plugin/#the-serializer-plugin","text":"Zend\\Cache\\Storage\\Plugin\\Serializer will serialize data when writing to cache, and deserialize when reading. This allows storing datatypes not supported by the underlying storage adapter.","title":"The Serializer Plugin"},{"location":"storage/plugin/#plugin-specific-options_4","text":"Name Data Type Default Value Description serializer null|string|Zend\\Serializer\\Adapter\\AdapterInterface null The serializer to use; see below. serializer_options array [] Array of options to use when instantiating the specified serializer. The serializer value has two special cases: When null , the default serializer is used (JSON). When a string , the value will be pulled via Zend\\Serializer\\AdapterPluginManager , with the provided serializer_options .","title":"Plugin specific options"},{"location":"storage/plugin/#available-methods","text":"The following methods are available to all Zend\\Cache\\Storage\\Plugin\\PluginInterface implementations: namespace Zend\\Cache\\Storage\\Plugin; use Zend\\EventManager\\EventManagerInterface; use Zend\\EventManager\\ListenerAggregateInterface; interface PluginInterface extends ListenerAggregateInterface { /** * Set options * * @param PluginOptions $options * @return PluginInterface */ public function setOptions(PluginOptions $options); /** * Get options * * @return PluginOptions */ public function getOptions(); /** * Attach listeners; inherited from ListenerAggregateInterface. * * @param EventManagerInterface $events * @return void */ public function attach(EventManagerInterface $events); /** * Detach listeners; inherited from ListenerAggregateInterface. * * @param EventManagerInterface $events * @return void */ public function attach(EventManagerInterface $events); }","title":"Available Methods"},{"location":"storage/plugin/#examples","text":"","title":"Examples"},{"location":"storage/plugin/#basic-plugin-implementation","text":"use Zend\\Cache\\Storage\\Event; use Zend\\Cache\\Storage\\Plugin\\AbstractPlugin; use Zend\\EventManager\\EventManagerInterface; class MyPlugin extends AbstractPlugin { protected $handles = []; /** * Attach to all events this plugin is interested in. */ public function attach(EventManagerInterface $events) { $this->handles[] = $events->attach('getItem.pre', array($this, 'onGetItemPre')); $this->handles[] = $events->attach('getItem.post', array($this, 'onGetItemPost')); } /** * Detach all handlers this plugin previously attached. */ public function detach(EventManagerInterface $events) { foreach ($this->handles as $handle) { $events->detach($handle); } $this->handles = []; } public function onGetItemPre(Event $event) { $params = $event->getParams(); echo sprintf(\"Method 'getItem' with key '%s' started\\n\", $params['key']); } public function onGetItemPost(Event $event) { $params = $event->getParams(); echo sprintf(\"Method 'getItem' with key '%s' finished\\n\", $params['key']); } } // After defining this plugin, we can instantiate and add it to an adapter // instance: $plugin = new MyPlugin(); $cache->addPlugin($plugin); // Now when calling getItem(), our plugin should print the expected output: $cache->getItem('cache-key'); // Method 'getItem' with key 'cache-key' started // Method 'getItem' with key 'cache-key' finished","title":"Basic plugin implementation"}]}